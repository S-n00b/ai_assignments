<!DOCTYPE html>
<html lang="en" class="scroll-smooth">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Architect's Interactive Playbook</title>
    <script src="https://cdn.tailwindcss.com/3.4.0"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#3A86FF',
                        'secondary': '#2EC4B6',
                        'accent': '#FFB700',
                        'text-primary': '#1F2937',
                        'text-secondary': '#6B7280',
                        'background': '#F9FAFB',
                        'surface': '#FFFFFF'
                    }
                }
            }
        }
    </script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono:wght@400;500;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #0D1B2A;
            --primary-border: #1B263B;
            --secondary-border: #415A77;
            --text-primary: #E0E1DD;
            --text-secondary: #B0B3B8;
            --code-bg: #0a1421;
            
            /* Primary Accent Colors - Consistent across all visualizations */
            --accent-blue: #3A86FF;
            --accent-blue-dark: #1A5CFF;
            --accent-cyan: #00A6FB;
            --accent-cyan-dark: #0087CC;
            --accent-green: #2EC4B6;
            --accent-green-dark: #1DA9A0;
            --accent-purple: #8338EC;
            --accent-purple-dark: #6D2BCA;
            
            /* Secondary Accent Colors - For variety and semantic encoding */
            --accent-orange: #FFB700;
            --accent-orange-dark: #E09800;
            --accent-red: #FF6B6B;
            --accent-red-dark: #E53E3E;
            --accent-yellow: #FCD34D;
            --accent-yellow-dark: #F59E0B;
            
            /* Semantic Color Mappings - Comprehensive Brand System */
            --color-performance: var(--accent-green);
            --color-alignment: var(--accent-blue);
            --color-efficiency: var(--accent-purple);
            --color-compute: var(--accent-orange);
            --color-data: var(--accent-cyan);
            --color-model: var(--accent-purple);
            --color-infrastructure: var(--accent-blue);
            --color-security: var(--accent-red);
            --color-optimization: var(--accent-green);
            --color-monitoring: var(--accent-orange);
            --color-success: var(--accent-green);
            --color-warning: var(--accent-yellow);
            --color-error: var(--accent-red);
            --color-info: var(--accent-cyan);
            --color-highlight: var(--accent-orange);
            
            /* Extended Semantic Mappings for Advanced Visualizations */
            --color-primary: var(--accent-blue);
            --color-secondary: var(--accent-cyan);
            --color-tertiary: var(--accent-green);
            --color-quaternary: var(--accent-purple);
            --color-quinary: var(--accent-orange);
            
            /* Status and State Colors */
            --color-active: var(--accent-green);
            --color-inactive: var(--text-secondary);
            --color-pending: var(--accent-yellow);
            --color-processing: var(--accent-cyan);
            --color-completed: var(--accent-green);
            --color-failed: var(--accent-red);
            
            /* Priority and Importance Colors */
            --color-critical: var(--accent-red);
            --color-high: var(--accent-orange);
            --color-medium: var(--accent-yellow);
            --color-low: var(--accent-cyan);
            
            /* Category and Type Colors */
            --color-input: var(--accent-cyan);
            --color-output: var(--accent-green);
            --color-process: var(--accent-blue);
            
            /* Standardized Opacity Encoding for Connection Weights and Relationships */
            --opacity-primary: 0.9;
            --opacity-secondary: 0.7;
            --opacity-tertiary: 0.5;
            --opacity-quaternary: 0.3;
            --opacity-background: 0.1;
            --opacity-hover: 1.0;
            --opacity-disabled: 0.2;
            
            /* Standardized Texture and Pattern Encoding for Differentiation */
            --pattern-solid: "none";
            --pattern-dots: "url(#dots-pattern)";
            --pattern-lines: "url(#lines-pattern)";
            --pattern-grid: "url(#grid-pattern)";
            --pattern-diagonal: "url(#diagonal-pattern)";
            --pattern-circles: "url(#circles-pattern)";
            --pattern-waves: "url(#waves-pattern)";
            --color-storage: var(--accent-purple);
            --color-network: var(--accent-orange);
            
            /* Shape Encoding System - Consistent Component Hierarchy */
            --shape-data: "rect";           /* Rectangles for data components */
            --shape-processing: "circle";   /* Circles for processing components */
            --shape-output: "polygon";      /* Polygons for output components */
            --shape-storage: "ellipse";     /* Ellipses for storage components */
            --shape-network: "diamond";     /* Diamonds for network components */
            --shape-interface: "rect";      /* Rectangles for interface components */
            --shape-compute: "circle";      /* Circles for compute components */
            --shape-inference: "hexagon";   /* Hexagons for inference components */
            
            /* Size Encoding System - Consistent Scaling Principles */
            --size-critical: 20;            /* Critical importance - largest size */
            --size-high: 16;                /* High importance - large size */
            --size-medium: 12;              /* Medium importance - medium size */
            --size-low: 8;                  /* Low importance - small size */
            --size-minimal: 4;              /* Minimal importance - smallest size */
            
            /* Performance-based Size Scaling */
            --size-performance-95: 18;      /* 95%+ performance - very large */
            --size-performance-90: 16;      /* 90-94% performance - large */
            --size-performance-80: 14;      /* 80-89% performance - medium-large */
            --size-performance-70: 12;      /* 70-79% performance - medium */
            --size-performance-60: 10;      /* 60-69% performance - small-medium */
            --size-performance-50: 8;       /* 50-59% performance - small */
            
            /* Complexity-based Size Scaling */
            --size-complexity-high: 16;     /* High complexity - large size */
            --size-complexity-medium: 12;   /* Medium complexity - medium size */
            --size-complexity-low: 8;       /* Low complexity - small size */
            
            /* Typography System - Consistent across all visualizations */
            --font-primary: 'Inter', system-ui, sans-serif;
            --font-mono: 'Roboto Mono', monospace;
            
            /* Font Sizes - Hierarchical scale */
            --text-xs: 9px;
            --text-sm: 10px;
            --text-base: 11px;
            --text-md: 12px;
            --text-lg: 13px;
            --text-xl: 14px;
            --text-2xl: 16px;
            --text-3xl: 18px;
            --text-4xl: 20px;
            --text-5xl: 24px;
            
            /* Font Weights - Consistent hierarchy */
            --font-light: 300;
            --font-normal: 400;
            --font-medium: 500;
            --font-semibold: 600;
            --font-bold: 700;
            
            /* Line Heights - For readability */
            --leading-tight: 1.2;
            --leading-normal: 1.4;
            --leading-relaxed: 1.6;
            
            /* Responsive Design Variables */
            --breakpoint-sm: 640px;
            --breakpoint-md: 768px;
            --breakpoint-lg: 1024px;
            --breakpoint-xl: 1280px;
            --breakpoint-2xl: 1536px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: var(--font-primary);
        }

        .font-mono {
            font-family: var(--font-mono);
        }

        /* Typography Utility Classes */
        .text-xs {
            font-size: var(--text-xs);
        }

        .text-sm {
            font-size: var(--text-sm);
        }

        .text-base {
            font-size: var(--text-base);
        }

        .text-md {
            font-size: var(--text-md);
        }

        .text-lg {
            font-size: var(--text-lg);
        }

        .text-xl {
            font-size: var(--text-xl);
        }

        .text-2xl {
            font-size: var(--text-2xl);
        }

        .text-3xl {
            font-size: var(--text-3xl);
        }

        .text-4xl {
            font-size: var(--text-4xl);
        }

        .text-5xl {
            font-size: var(--text-5xl);
        }

        .font-light {
            font-weight: var(--font-light);
        }

        .font-normal {
            font-weight: var(--font-normal);
        }

        .font-medium {
            font-weight: var(--font-medium);
        }

        .font-semibold {
            font-weight: var(--font-semibold);
        }

        .font-bold {
            font-weight: var(--font-bold);
        }

        .leading-tight {
            line-height: var(--leading-tight);
        }

        .leading-normal {
            line-height: var(--leading-normal);
        }

        .leading-relaxed {
            line-height: var(--leading-relaxed);
        }

        .blueprint-grid {
            background-image: linear-gradient(var(--primary-border) 1px, transparent 1px), linear-gradient(to right, var(--primary-border) 1px, var(--bg-color) 1px);
            background-size: 20px 20px;
        }

        .card {
            background-color: rgba(27, 38, 59, 0.6);
            border: 1px solid var(--primary-border);
            /* Cross-browser backdrop filter support */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            -moz-backdrop-filter: blur(10px);
            -ms-backdrop-filter: blur(10px);
            /* Fallback for browsers without backdrop-filter support */
            background-color: rgba(27, 38, 59, 0.8);
            /* Cross-browser transition support */
            -webkit-transition: all 0.3s ease-in-out;
            -moz-transition: all 0.3s ease-in-out;
            -ms-transition: all 0.3s ease-in-out;
            transition: all 0.3s ease-in-out;
            /* Ensure proper rendering across browsers */
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            transform: translateZ(0);
            /* Prevent text truncation */
            word-wrap: break-word;
            overflow-wrap: break-word;
            -webkit-hyphens: auto;
            -moz-hyphens: auto;
            -ms-hyphens: auto;
            hyphens: auto;
        }

        .card:hover {
            border-color: var(--secondary-border);
            /* Cross-browser transform support */
            -webkit-transform: translateY(-2px);
            -moz-transform: translateY(-2px);
            -ms-transform: translateY(-2px);
            transform: translateY(-2px);
        }

        .nav-link {
            /* Cross-browser transition support */
            -webkit-transition: all 0.2s ease-in-out;
            -moz-transition: all 0.2s ease-in-out;
            -ms-transition: all 0.2s ease-in-out;
            transition: all 0.2s ease-in-out;
            border-bottom: 2px solid transparent;
        }

        .nav-link.active,
        .nav-link:hover {
            color: var(--accent-cyan);
            border-bottom-color: var(--accent-cyan);
        }

        h1,
        h2,
        h3 {
            font-weight: var(--font-bold);
            color: var(--text-primary);
            font-family: var(--font-primary);
        }

        .viz-container {
            border: 1px dashed var(--secondary-border);
            background-color: rgba(13, 27, 42, 0.5);
            overflow: hidden;
            position: relative;
            min-height: 300px;
            /* Cross-browser rendering optimizations */
            -webkit-transform: translateZ(0);
            -moz-transform: translateZ(0);
            -ms-transform: translateZ(0);
            transform: translateZ(0);
            /* Ensure proper border rendering */
            -webkit-border-radius: 6px;
            -moz-border-radius: 6px;
            border-radius: 6px;
            /* Box sizing for consistent rendering */
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }
        
        /* Enhanced Responsive Design with Advanced Breakpoints and Optimization */
        
        /* Large Desktop (1440px+) */
        @media (min-width: 1440px) {
            .viz-container {
                min-height: 500px;
            }
            
            .card {
                margin: 1.5rem;
                padding: 2rem;
            }
            
            .space-y-12>*+* {
                margin-top: 4rem;
            }
        }
        
        /* Desktop (1280px - 1439px) */
        @media (max-width: 1439px) and (min-width: 1280px) {
            .viz-container {
                min-height: 450px;
            }
            
            .card {
                margin: 1.25rem;
                padding: 1.75rem;
            }
            
            .space-y-12>*+* {
                margin-top: 3.5rem;
            }
        }
        
        /* Laptop (1024px - 1279px) */
        @media (max-width: 1279px) and (min-width: 1024px) {
            .viz-container {
                min-height: 400px;
            }
            
            .card {
                margin: 1rem;
                padding: 1.5rem;
            }
            
            .space-y-12>*+* {
                margin-top: 3rem;
            }
        }
        
        /* Tablet Landscape (768px - 1023px) */
        @media (max-width: 1023px) and (min-width: 768px) {
            .viz-container {
                min-height: 350px;
            }
            
            .card {
                margin: 0.75rem;
                padding: 1.25rem;
            }
            
            h1,
            h2,
            h3 {
                font-size: 1.75rem;
            }
            
            .text-3xl {
                font-size: 1.5rem;
            }
            
            .space-y-12>*+* {
                margin-top: 2.5rem;
            }
            
            /* Optimize for tablet landscape */
            section {
                margin-bottom: 3.5rem !important;
                padding-top: 2.5rem !important;
            }
        }
        
        /* Tablet Portrait (640px - 767px) */
        @media (max-width: 767px) and (min-width: 640px) {
            .viz-container {
                min-height: 300px;
            }
            
            .card {
                margin: 0.5rem;
                padding: 1rem;
            }
            
            h1,
            h2,
            h3 {
                font-size: 1.5rem;
            }
            
            .text-3xl {
                font-size: 1.25rem;
            }
            
            .space-y-12>*+* {
                margin-top: 2rem;
            }
            
            /* Ensure consistent section spacing on tablet portrait */
            section {
                margin-bottom: 3rem !important;
                padding-top: 2rem !important;
            }
        }
        
        /* Mobile Landscape (480px - 639px) */
        @media (max-width: 639px) and (min-width: 480px) {
            .viz-container {
                min-height: 250px;
            }
            
            .card {
                margin: 0.375rem;
                padding: 0.875rem;
            }
            
            h1,
            h2,
            h3 {
                font-size: 1.375rem;
            }
            
            .text-3xl {
                font-size: 1.125rem;
            }
            
            .space-y-12>*+* {
                margin-top: 1.75rem;
            }
            
            /* Optimize for mobile landscape */
            section {
                margin-bottom: 2.5rem !important;
                padding-top: 1.75rem !important;
            }
        }
        
        /* Mobile Portrait (320px - 479px) */
        @media (max-width: 479px) {
            .viz-container {
                min-height: 200px;
            }
            
            .card {
                margin: 0.25rem;
                padding: 0.75rem;
            }
            
            h1,
            h2,
            h3 {
                font-size: 1.25rem;
            }
            
            .text-3xl {
                font-size: 1rem;
            }
            
            .space-y-12>*+* {
                margin-top: 1.5rem;
            }
            
            /* Tighter spacing on small mobile screens */
            section {
                margin-bottom: 2rem !important;
                padding-top: 1.5rem !important;
            }
        }
        
        /* Ultra-wide screens (1920px+) */
        @media (min-width: 1920px) {
            .viz-container {
                min-height: 600px;
            }
            
            .card {
                margin: 2rem;
                padding: 2.5rem;
            }
            
            .space-y-12>*+* {
                margin-top: 5rem;
            }
            
            /* Optimize for ultra-wide displays */
            .container {
                max-width: 1800px;
                margin: 0 auto;
            }
        }
        
        /* High DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2),
        (min-resolution: 192dpi) {
            .viz-container {
                /* Ensure crisp rendering on high DPI displays */
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {

            .interactive-node,
            .clickable-element {
                min-height: 44px;
                min-width: 44px;
            }
            
            .tooltip {
                font-size: var(--text-md);
                padding: 12px;
            }
        }
        
        /* Reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Mobile optimization class */
        .mobile-optimized {
            /* Reduce animation complexity on mobile */
            --animation-duration: 0.3s;
            --transition-duration: 0.2s;
        }
        
        .mobile-optimized .viz-container {
            /* Simplify visualizations on mobile */
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation;
        }
        
        .mobile-optimized .interactive-node {
            /* Larger touch targets on mobile */
            min-width: 48px;
            min-height: 48px;
        }
        
        /* Performance optimizations for different device types */
        @media (max-width: 767px) {

            /* Reduce visual complexity on mobile */
            .viz-container svg {
                /* Optimize SVG rendering on mobile */
                shape-rendering: optimizeSpeed;
            }
            
            /* Simplify gradients and effects on mobile */
            .gradient-bg {
                background: var(--accent-blue) !important;
            }
        }
        
        /* Container max-width variable */
        .container {
            max-width: var(--container-max-width, 100%);
            margin: 0 auto;
        }
        
        /* Device-specific optimizations */
        .mobile-device .viz-container {
            /* Optimize for mobile devices */
            -webkit-overflow-scrolling: touch;
        }
        
        .tablet-device .viz-container {
            /* Optimize for tablet devices */
            touch-action: manipulation;
        }
        
        .touch-device .interactive-node {
            /* Larger touch targets for touch devices */
            min-width: 44px;
            min-height: 44px;
            cursor: pointer;
        }
        
        .high-dpi .viz-container svg {
            /* Ensure crisp rendering on high DPI displays */
            shape-rendering: geometricPrecision;
        }
        
        .retina .viz-container svg {
            /* Additional optimizations for Retina displays */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        .mobile-os .viz-container {
            /* Mobile OS specific optimizations */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Performance optimization class */
        .performance-optimized {
            /* Reduce visual complexity for better performance */
            will-change: auto;
            transform: translateZ(0);
        }
        
        .performance-optimized .viz-container svg {
            /* Simplify SVG rendering for performance */
            shape-rendering: optimizeSpeed;
        }
        
        .performance-optimized * {
            /* Reduce animation complexity */
            animation-duration: 0.2s !important;
            transition-duration: 0.1s !important;
        }
        
        /* Animation duration variables */
        :root {
            --animation-duration: 0.5s;
            --transition-duration: 0.3s;
        }
        
        /* Apply animation duration variables */
        .animated-element {
            animation-duration: var(--animation-duration);
            transition-duration: var(--transition-duration);
        }

        .tooltip {
            position: absolute;
            text-align: center;
            max-width: 250px;
            padding: 10px;
            font-size: var(--text-lg);
            font-family: var(--font-primary);
            font-weight: var(--font-normal);
            background: #e0e1dd;
            color: var(--bg-color);
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .interactive-node,
        .gantt-bar {
            cursor: pointer;
            /* Cross-browser transition support */
            -webkit-transition: all 0.2s ease-in-out;
            -moz-transition: all 0.2s ease-in-out;
            -ms-transition: all 0.2s ease-in-out;
            transition: all 0.2s ease-in-out;
        }

        .interactive-node:hover {
            /* Cross-browser filter support */
            -webkit-filter: drop-shadow(0 0 5px var(--accent-cyan));
            -moz-filter: drop-shadow(0 0 5px var(--accent-cyan));
            -ms-filter: drop-shadow(0 0 5px var(--accent-cyan));
            filter: drop-shadow(0 0 5px var(--accent-cyan));
        }

        .gantt-bar:hover {
            opacity: 0.8;
            stroke: var(--accent-cyan);
            stroke-width: 2px;
            /* Cross-browser transition support */
            -webkit-transition: all 0.2s ease-in-out;
            -moz-transition: all 0.2s ease-in-out;
            -ms-transition: all 0.2s ease-in-out;
            transition: all 0.2s ease-in-out;
        }

        .code-block {
            background-color: var(--code-bg);
            border: 1px solid var(--primary-border);
            border-radius: 8px;
            padding: 16px;
            font-family: 'Roboto Mono', monospace;
            font-size: var(--text-lg);
            line-height: 1.5;
            overflow-x: auto;
            color: var(--text-secondary);
        }

        .code-block .token.keyword {
            color: var(--accent-purple);
        }

        .code-block .token.function {
            color: var(--accent-blue);
        }

        .code-block .token.string {
            color: var(--accent-green);
        }

        .code-block .token.comment {
            color: var(--text-secondary);
            font-style: italic;
        }

        .code-block .token.parameter {
            color: var(--accent-orange);
        }

        .modal {
            /* Cross-browser flexbox support */
            display: -webkit-box;
            display: -webkit-flex;
            display: -moz-box;
            display: -ms-flexbox;
            display: flex;
            opacity: 0;
            pointer-events: none;
            /* Cross-browser transition support */
            -webkit-transition: opacity 0.3s ease-in-out;
            -moz-transition: opacity 0.3s ease-in-out;
            -ms-transition: opacity 0.3s ease-in-out;
            transition: opacity 0.3s ease-in-out;
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            /* Cross-browser transform support */
            -webkit-transform: scale(0.95);
            -moz-transform: scale(0.95);
            -ms-transform: scale(0.95);
            transform: scale(0.95);
            /* Cross-browser transition support */
            -webkit-transition: transform 0.3s ease-in-out;
            -moz-transition: transform 0.3s ease-in-out;
            -ms-transition: transform 0.3s ease-in-out;
            transition: transform 0.3s ease-in-out;
        }

        .modal.active .modal-content {
            /* Cross-browser transform support */
            -webkit-transform: scale(1);
            -moz-transform: scale(1);
            -ms-transform: scale(1);
            transform: scale(1);
        }

        .grid-line {
            stroke: var(--primary-border);
            stroke-dasharray: 2, 2;
        }

        .text-primary {
            fill: var(--text-primary);
        }

        .text-secondary {
            fill: var(--text-secondary);
        }

        .caption-link {
            color: var(--accent-cyan);
            text-decoration: none;
            transition: color 0.2s;
        }

        .caption-link:hover {
            color: var(--text-primary);
            text-decoration: underline;
        }

        /* Enhanced animations for Cloud-Native Gen AI Stacks visualization */
        @keyframes gridPulse {
            0% {
                stroke-opacity: var(--opacity-background);
            }

            100% {
                stroke-opacity: var(--opacity-quaternary);
            }
        }

        /* Cross-browser animation support */
        @-webkit-keyframes gridPulse {
            0% {
                stroke-opacity: var(--opacity-background);
            }

            100% {
                stroke-opacity: var(--opacity-quaternary);
            }
        }

        @-moz-keyframes gridPulse {
            0% {
                stroke-opacity: var(--opacity-background);
            }

            100% {
                stroke-opacity: var(--opacity-quaternary);
            }
        }

        @-ms-keyframes gridPulse {
            0% {
                stroke-opacity: var(--opacity-background);
            }

            100% {
                stroke-opacity: var(--opacity-quaternary);
            }
        }

        @keyframes sparklinePulse {
            0% {
                opacity: 0.8;
            }

            50% {
                opacity: 1.0;
            }

            100% {
                opacity: 0.8;
            }
        }

        /* Cross-browser animation support */
        @-webkit-keyframes sparklinePulse {
            0% {
                opacity: 0.8;
            }

            50% {
                opacity: 1.0;
            }

            100% {
                opacity: 0.8;
            }
        }

        @-moz-keyframes sparklinePulse {
            0% {
                opacity: 0.8;
            }

            50% {
                opacity: 1.0;
            }

            100% {
                opacity: 0.8;
            }
        }

        @-ms-keyframes sparklinePulse {
            0% {
                opacity: 0.8;
            }

            50% {
                opacity: 1.0;
            }

            100% {
                opacity: 0.8;
            }
        }

        @keyframes serviceGlow {
            0% {
                /* Cross-browser filter support */
                -webkit-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
                -moz-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
                -ms-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
                filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }

            50% {
                /* Cross-browser filter support */
                -webkit-filter: drop-shadow(0 6px 12px rgba(58, 134, 255, 0.3));
                -moz-filter: drop-shadow(0 6px 12px rgba(58, 134, 255, 0.3));
                -ms-filter: drop-shadow(0 6px 12px rgba(58, 134, 255, 0.3));
                filter: drop-shadow(0 6px 12px rgba(58, 134, 255, 0.3));
            }

            100% {
                /* Cross-browser filter support */
                -webkit-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
                -moz-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
                -ms-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
                filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }
        }

        /* Cross-browser animation support */
        @-webkit-keyframes serviceGlow {
            0% {
                -webkit-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }

            50% {
                -webkit-filter: drop-shadow(0 6px 12px rgba(58, 134, 255, 0.3));
            }

            100% {
                -webkit-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }
        }

        @-moz-keyframes serviceGlow {
            0% {
                -moz-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }

            50% {
                -moz-filter: drop-shadow(0 6px 12px rgba(58, 134, 255, 0.3));
            }

            100% {
                -moz-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }
        }

        @-ms-keyframes serviceGlow {
            0% {
                -ms-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }

            50% {
                -ms-filter: drop-shadow(0 6px 12px rgba(58, 134, 255, 0.3));
            }

            100% {
                -ms-filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
            }
        }

        .cloud-service:hover {
            /* Cross-browser animation support */
            -webkit-animation: serviceGlow 1s ease-in-out infinite;
            -moz-animation: serviceGlow 1s ease-in-out infinite;
            -ms-animation: serviceGlow 1s ease-in-out infinite;
            animation: serviceGlow 1s ease-in-out infinite;
        }

        /* Print-Friendly Mode & Accessibility Styles */
        .print-friendly-mode {
            --bg-color: #ffffff !important;
            --primary-border: #333333 !important;
            --text-primary: #000000 !important;
            --text-secondary: #333333 !important;
            
            /* Disable all gradients for accessibility */
            --accent-blue: #0066cc !important;
            --accent-cyan: #006699 !important;
            --accent-green: #006600 !important;
            --accent-purple: #663399 !important;
            --accent-orange: #cc6600 !important;
            --accent-red: #cc0000 !important;
        }

        .print-friendly-mode body {
            background-color: #ffffff !important;
            color: #000000 !important;
        }

        .print-friendly-mode .card {
            background-color: #ffffff !important;
            border: 2px solid #333333 !important;
            box-shadow: none !important;
        }

        .print-friendly-mode svg {
            background-color: #ffffff !important;
        }

        .print-friendly-mode .blueprint-grid {
            background-image: none !important;
        }

        /* Disable animations in print-friendly mode */
        .print-friendly-mode *,
        .print-friendly-mode *::before,
        .print-friendly-mode *::after {
            animation: none !important;
            transition: none !important;
        }

        /* Remove gradients and complex effects */
        .print-friendly-mode [fill*="gradient"],
        .print-friendly-mode [stroke*="gradient"] {
            fill: #333333 !important;
            stroke: #333333 !important;
        }

        /* Ensure high contrast for accessibility */
        .print-friendly-mode .tooltip {
            background-color: #ffffff !important;
            color: #000000 !important;
            border: 2px solid #333333 !important;
        }

        /* PDF Export specific styles */
        .pdf-export-mode {
            font-size: 12px !important;
            line-height: 1.4 !important;
        }

        .pdf-export-mode .viz-container {
            page-break-inside: avoid !important;
            margin-bottom: 20px !important;
        }

        .pdf-export-mode section {
            page-break-before: auto !important;
            page-break-after: avoid !important;
        }

        @media print {
            body {
                font-size: 10pt;
                color: var(--text-primary);
                margin: 1in;
                background-color: var(--text-primary);
                background-image: none;
            }

            #header,
            #navigation,
            .button,
            .modal,
            .no-print {
                display: none !important;
            }

            main {
                padding: 0 !important;
            }

            .card,
            .viz-container {
                border: 1px solid #ccc !important;
                background-color: #fff !important;
                backdrop-filter: none;
                -webkit-backdrop-filter: none;
                page-break-inside: avoid;
            }

            h1,
            h2,
            h3,
            p,
            a,
            text,
            .nav-link,
            .gantt-label,
            .caption-link {
                color: #000 !important;
                fill: #000 !important;
                text-decoration: none;
            }

            .text-primary,
            .text-secondary {
                fill: #000 !important;
            }

            .blueprint-grid {
                background-image: none;
            }

            section {
                margin-top: 1.5rem;
                padding-top: 1.5rem;
                border-top: 1px solid #ccc;
            }

            .code-block {
                background-color: #f5f5f5 !important;
                color: #000 !important;
            }
        }
    </style>
</head>

<body class="blueprint-grid">
    <div id="header" class="fixed top-0 left-0 right-0 z-50 card border-t-0 rounded-t-none no-print">
        <header class="container mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-accent-blue" fill="none"
                        viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 6V4m0 16v-2m8-8h2M4 12H2m15.364 6.364l1.414 1.414M4.222 4.222l1.414 1.414m12.728 0l-1.414 1.414M5.636 18.364l-1.414 1.414M12 16a4 4 0 110-8 4 4 0 010 8zm0-2a2 2 0 100-4 2 2 0 000 4z" />
                    </svg>
                    <h1 class="ml-3 text-xl font-bold text-white">AI Architect's Playbook</h1>
                </div>
                <nav id="navigation" class="hidden md:flex space-x-6 text-sm font-medium">
                    <a href="#llm-foundations" class="nav-link active">LLM Foundations</a>
                    <a href="#llm-architectures" class="nav-link">LLM Architectures</a>
                    <a href="#core-technologies" class="nav-link">Core Technologies</a>
                    <a href="#agentic-systems" class="nav-link">Agentic Systems</a>
                    <a href="#advanced-patterns" class="nav-link">Advanced Patterns</a>
                    <a href="#enterprise-deployment" class="nav-link">Enterprise Deployment</a>
                </nav>
            </div>
        </header>
    </div>

    <main id="content" class="container mx-auto px-4 sm:px-6 lg:px-8 pt-24 pb-16">
        <section id="llm-foundations" class="mb-20 pt-8">
            <h2 class="text-3xl font-bold mb-6 text-accent-blue">LLM Foundations</h2>
            <p class="text-lg text-text-secondary mb-8">Understanding Large Language Models from the ground up: system design principles, operating system integration, machine learning fundamentals, and transformer architecture. This section establishes the foundational knowledge needed before exploring LLM architectures and agentic systems.</p>
            <div class="space-y-12">
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Designing & Integrating AI Systems</h3>
                    <p class="text-text-secondary mb-4">The core principle is architecting for the entire lifecycle:
                        from data ingestion to production inference. This demands modularity, observability, and a clear
                        separation of concerns into distinct, manageable pipelines.</p>
                    <div id="system-design-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the complete AI system lifecycle from data ingestion to production inference</li>
                            <li>• Identify key architectural components and their interactions in modern AI systems</li>
                            <li>• Recognize the importance of modularity, observability, and separation of concerns</li>
                            <li>• Learn to design scalable AI architectures that can handle production workloads</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This visualization demonstrates the essential components of a production-ready AI system architecture. 
                            The sequence diagram shows how data flows through various stages: from raw data ingestion and preprocessing, 
                            through model training and validation, to deployment and monitoring. Each component is designed with 
                            specific responsibilities, enabling modular development, easy testing, and scalable deployment.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The architecture emphasizes <strong>separation of concerns</strong> with distinct pipelines for data processing, 
                            model training, and inference. <strong>Observability</strong> is built-in through monitoring and logging at each stage. 
                            The <strong>modular design</strong> allows for independent scaling and updates of individual components, 
                            reducing system complexity and enabling agile development practices.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://proceedings.neurips.cc/paper_files/paper/2015/file/86df7dcfd896fcaf2674f757a2463eba-Paper.pdf" target="_blank" rel="noopener noreferrer" class="caption-link">"Hidden Technical Debt in Machine Learning Systems" - D. Sculley et al. (2015)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener noreferrer" class="caption-link">Microservices Architecture</a> | <a href="https://www.oreilly.com/library/view/building-machine-learning/9781492045106/" target="_blank" rel="noopener noreferrer" class="caption-link">ML System Design Patterns</a> | <a href="https://www.kubeflow.org/" target="_blank" rel="noopener noreferrer" class="caption-link">Kubeflow</a> | <a href="https://mlflow.org/" target="_blank" rel="noopener noreferrer" class="caption-link">MLflow</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://www.tensorflow.org/tfx" target="_blank" rel="noopener noreferrer" class="caption-link">TensorFlow Extended (TFX)</a> | <a href="https://feast.dev/" target="_blank" rel="noopener noreferrer" class="caption-link">Feast Feature Store</a> | <a href="https://www.weave.works/" target="_blank" rel="noopener noreferrer" class="caption-link">Weave GitOps</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Operating Systems</h3>
                    <p class="text-text-secondary mb-4">An architect must design solutions that leverage core OS
                        primitives for performance. The future vision is an "AI OS" layer that intelligently
                        orchestrates heterogeneous compute resources (CPU, GPU, NPU) for optimal AI workload execution.
                    </p>
                    <div id="os-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the layered architecture of modern operating systems for AI workloads</li>
                            <li>• Learn how hardware abstraction enables efficient AI model execution</li>
                            <li>• Recognize the role of AI-specific OS components in performance optimization</li>
                            <li>• Explore the evolution toward AI-native operating system architectures</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This visualization illustrates the hierarchical structure of operating systems optimized for AI workloads. 
                            The layers progress from hardware abstraction at the bottom to AI-specific services at the top. 
                            Each layer provides specific functionality: hardware drivers manage GPU/TPU resources, 
                            the kernel handles process scheduling and memory management, and AI services provide 
                            specialized APIs for model execution and optimization.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The <strong>AI OS layer</strong> represents the future of operating systems, providing intelligent resource allocation, 
                            automatic model optimization, and seamless hardware abstraction. <strong>Performance rings</strong> show the 
                            privilege levels and security boundaries, while <strong>hardware positioning</strong> demonstrates how 
                            different compute resources (CPU, GPU, TPU) are managed and coordinated for optimal AI performance.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://www.usenix.org/system/files/osdi20-narayanan_deepak.pdf" target="_blank" rel="noopener noreferrer" class="caption-link">"A General-Purpose Scheduler for Heterogeneous Clusters" - N. Deepak et al. (OSDI 2020)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html" target="_blank" rel="noopener noreferrer" class="caption-link">Linux Kernel Scheduler</a> | <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/" target="_blank" rel="noopener noreferrer" class="caption-link">Kubernetes Scheduling</a> | <a href="https://www.nvidia.com/en-us/data-center/gpu-accelerated-applications/" target="_blank" rel="noopener noreferrer" class="caption-link">GPU Computing</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Docker</a> | <a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Kubernetes</a> | <a href="https://www.nvidia.com/en-us/data-center/tesla/" target="_blank" rel="noopener noreferrer" class="caption-link">NVIDIA CUDA</a> | <a href="https://www.tensorflow.org/guide/gpu" target="_blank" rel="noopener noreferrer" class="caption-link">TensorFlow GPU</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">ML & Deep Learning Principles</h3>
                    <p class="text-text-secondary mb-4">The fundamental shift from traditional ML to Deep Learning is
                        the move from manual 'feature engineering' to automated 'representation learning'. This allows
                        models to learn hierarchical features directly from raw data.</p>
                    <div id="ml-dl-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Distinguish between traditional machine learning and deep learning approaches</li>
                            <li>• Understand the evolution from manual feature engineering to automated representation learning</li>
                            <li>• Learn about the computational requirements and scalability differences between ML and DL</li>
                            <li>• Recognize when to apply traditional ML vs deep learning for different problem types</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This visualization contrasts traditional machine learning with deep learning approaches, highlighting the 
                            fundamental paradigm shift from manual feature engineering to automated representation learning. 
                            Traditional ML relies on domain expertise to extract relevant features, while deep learning 
                            automatically learns hierarchical representations through multiple layers of neural networks, 
                            enabling more complex pattern recognition and better performance on large datasets.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The <strong>neural network containment</strong> shows how deep learning models can capture increasingly 
                            complex patterns through layer depth. <strong>Legend positioning</strong> clearly distinguishes between 
                            the two paradigms, while <strong>performance metrics</strong> demonstrate the trade-offs between 
                            interpretability (traditional ML) and accuracy (deep learning). The visualization emphasizes 
                            the importance of choosing the right approach based on data size, complexity, and interpretability requirements.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://www.deeplearningbook.org/" target="_blank" rel="noopener noreferrer" class="caption-link">"Deep Learning" - Goodfellow, Bengio, and Courville (2016)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://scikit-learn.org/stable/" target="_blank" rel="noopener noreferrer" class="caption-link">Scikit-learn</a> | <a href="https://www.tensorflow.org/" target="_blank" rel="noopener noreferrer" class="caption-link">TensorFlow</a> | <a href="https://pytorch.org/" target="_blank" rel="noopener noreferrer" class="caption-link">PyTorch</a> | <a href="https://xgboost.readthedocs.io/" target="_blank" rel="noopener noreferrer" class="caption-link">XGBoost</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://pandas.pydata.org/" target="_blank" rel="noopener noreferrer" class="caption-link">Pandas</a> | <a href="https://numpy.org/" target="_blank" rel="noopener noreferrer" class="caption-link">NumPy</a> | <a href="https://matplotlib.org/" target="_blank" rel="noopener noreferrer" class="caption-link">Matplotlib</a> | <a href="https://seaborn.pydata.org/" target="_blank" rel="noopener noreferrer" class="caption-link">Seaborn</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Large Language Models & Transformers</h3>
                    <p class="text-text-secondary mb-4">The Transformer architecture, specifically the self-attention
                        mechanism, revolutionized sequence processing. It allows the model to weigh the importance of
                        different words in the input sequence, capturing long-range dependencies.</p>
                    <div id="transformer-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the self-attention mechanism and its role in transformer architecture</li>
                            <li>• Learn how transformers process sequential data without recurrent connections</li>
                            <li>• Explore multi-head attention and its benefits for parallel processing</li>
                            <li>• Recognize the impact of transformers on modern NLP and AI applications</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This visualization demonstrates the revolutionary transformer architecture that powers modern large language models. 
                            The self-attention mechanism allows the model to focus on different parts of the input sequence simultaneously, 
                            enabling parallel processing and capturing long-range dependencies. Unlike RNNs, transformers can process 
                            entire sequences at once, making them more efficient and effective for understanding context and relationships in text.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The <strong>attention matrix</strong> visualization shows how the model weights different input tokens, 
                            with brighter colors indicating stronger attention. <strong>Multi-head attention</strong> allows the model 
                            to focus on different types of relationships simultaneously. The <strong>positional encoding</strong> 
                            provides sequence information since transformers don't have inherent order awareness. 
                            This architecture enables the parallel processing that makes modern LLMs so powerful and efficient.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer" class="caption-link">"Attention Is All You Need" - Vaswani et al. (2017)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://huggingface.co/transformers/" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Transformers</a> | <a href="https://openai.com/research/gpt-3" target="_blank" rel="noopener noreferrer" class="caption-link">GPT-3 Research</a> | <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener noreferrer" class="caption-link">GPT-3 Paper</a> | <a href="https://arxiv.org/abs/2204.02311" target="_blank" rel="noopener noreferrer" class="caption-link">PaLM Paper</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://pytorch.org/tutorials/beginner/transformer_tutorial.html" target="_blank" rel="noopener noreferrer" class="caption-link">PyTorch Transformer Tutorial</a> | <a href="https://www.tensorflow.org/tutorials/text/transformer" target="_blank" rel="noopener noreferrer" class="caption-link">TensorFlow Transformer</a> | <a href="https://github.com/tensorflow/tensor2tensor" target="_blank" rel="noopener noreferrer" class="caption-link">Tensor2Tensor</a></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="llm-architectures" class="mb-20 pt-8">
            <h2 class="text-3xl font-bold mb-6 text-accent-blue">LLM Architectures</h2>
            <p class="text-lg text-text-secondary mb-8">Comprehensive analysis of Large Language Model architectures: performance comparisons, decision trees, evolution timelines, and component breakdowns for optimal architecture selection. This section provides deep technical insights into different LLM architectures and their trade-offs.</p>
            <div class="space-y-12">
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">LLM Architecture Performance Comparison</h3>
                    <p class="text-text-secondary mb-4">Comprehensive performance analysis of major LLM architectures with inference speed, memory usage, accuracy metrics, and cost-effectiveness comparisons for enterprise decision-making.</p>
                    <div id="llm-performance-viz" class="w-full h-[500px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Compare performance metrics across major LLM architectures (GPT, BERT, T5, LLaMA, Mixtral)</li>
                            <li>• Understand the trade-offs between inference speed, memory usage, and accuracy</li>
                            <li>• Learn to select optimal architectures based on specific use case requirements</li>
                            <li>• Analyze cost-effectiveness and deployment considerations for different architectures</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This visualization provides a comprehensive performance comparison of major LLM architectures, enabling data-driven 
                            decision-making for enterprise deployments. The multi-dimensional analysis covers inference speed, memory requirements, 
                            accuracy metrics, and cost considerations. Each architecture is positioned based on its unique strengths: 
                            GPT excels at generation tasks, BERT dominates understanding tasks, T5 handles both generation and understanding, 
                            while LLaMA and Mixtral offer open-source alternatives with competitive performance.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The <strong>performance matrix</strong> shows the fundamental trade-offs in LLM design: larger models typically 
                            achieve higher accuracy but require more memory and slower inference. <strong>Architecture-specific optimizations</strong> 
                            like Mixtral's mixture-of-experts design enable better performance per parameter. <strong>Cost analysis</strong> 
                            includes both training costs and inference costs, crucial for enterprise budgeting. The visualization helps 
                            architects choose the right model based on latency requirements, accuracy needs, and budget constraints.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener noreferrer" class="caption-link">GPT-3 Paper</a> | <a href="https://arxiv.org/abs/1810.04805" target="_blank" rel="noopener noreferrer" class="caption-link">BERT Paper</a> | <a href="https://arxiv.org/abs/1910.10683" target="_blank" rel="noopener noreferrer" class="caption-link">T5 Paper</a> | <a href="https://arxiv.org/abs/2302.13971" target="_blank" rel="noopener noreferrer" class="caption-link">LLaMA Paper</a></p>
                            <p><strong>Performance Benchmarks:</strong> <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard" target="_blank" rel="noopener noreferrer" class="caption-link">Open LLM Leaderboard</a> | <a href="https://www.helm-benchmark.com/" target="_blank" rel="noopener noreferrer" class="caption-link">HELM Benchmark</a> | <a href="https://arxiv.org/abs/2303.16634" target="_blank" rel="noopener noreferrer" class="caption-link">MMLU Benchmark</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://huggingface.co/transformers/" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Transformers</a> | <a href="https://github.com/microsoft/DeepSpeed" target="_blank" rel="noopener noreferrer" class="caption-link">DeepSpeed</a> | <a href="https://github.com/facebookresearch/fairscale" target="_blank" rel="noopener noreferrer" class="caption-link">FairScale</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">LLM Architecture Decision Tree</h3>
                    <p class="text-text-secondary mb-4">Interactive decision tree for selecting optimal LLM architecture based on use case requirements, performance needs, and deployment constraints. Navigate through decision points to find the best architecture for your specific needs.</p>
                    <div id="llm-decision-tree-viz" class="w-full h-[600px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Learn to systematically evaluate LLM architecture requirements based on use case</li>
                            <li>• Understand the decision factors that influence architecture selection</li>
                            <li>• Navigate through performance, cost, and deployment trade-offs</li>
                            <li>• Make informed decisions about LLM architecture for enterprise applications</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This interactive decision tree guides you through the complex process of selecting the optimal LLM architecture 
                            for your specific use case. The tree considers multiple factors including task type (generation vs understanding), 
                            performance requirements (speed vs accuracy), deployment constraints (cost vs resources), and scalability needs. 
                            Each decision point leads to increasingly specific recommendations, helping you navigate the trade-offs between 
                            different architectures and find the best fit for your requirements.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The decision tree follows a logical hierarchy: <strong>Task Type</strong> determines the fundamental architecture 
                            (encoder-only for understanding, decoder-only for generation, encoder-decoder for both). <strong>Performance Requirements</strong> 
                            influence model size and optimization strategies. <strong>Deployment Constraints</strong> consider cost, latency, and resource 
                            availability. <strong>Scalability Needs</strong> determine whether to use commercial APIs or deploy custom models. 
                            The visualization provides real-time recommendations based on your selections, with detailed explanations for each choice.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Architecture Selection Guides:</strong> <a href="https://huggingface.co/docs/transformers/model_doc/auto" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Model Selection</a> | <a href="https://arxiv.org/abs/2303.18223" target="_blank" rel="noopener noreferrer" class="caption-link">LLM Selection Survey</a> | <a href="https://www.oreilly.com/library/view/large-language-models/9781098150952/" target="_blank" rel="noopener noreferrer" class="caption-link">LLM Architecture Guide</a></p>
                            <p><strong>Performance Benchmarks:</strong> <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard" target="_blank" rel="noopener noreferrer" class="caption-link">Open LLM Leaderboard</a> | <a href="https://www.helm-benchmark.com/" target="_blank" rel="noopener noreferrer" class="caption-link">HELM Benchmark</a> | <a href="https://arxiv.org/abs/2303.16634" target="_blank" rel="noopener noreferrer" class="caption-link">MMLU Benchmark</a></p>
                            <p><strong>Deployment Resources:</strong> <a href="https://github.com/microsoft/DeepSpeed" target="_blank" rel="noopener noreferrer" class="caption-link">DeepSpeed</a> | <a href="https://github.com/facebookresearch/fairscale" target="_blank" rel="noopener noreferrer" class="caption-link">FairScale</a> | <a href="https://www.tensorflow.org/lite" target="_blank" rel="noopener noreferrer" class="caption-link">TensorFlow Lite</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">LLM Architecture Timeline</h3>
                    <p class="text-text-secondary mb-4">Interactive timeline showing the evolution of Large Language Model architectures from GPT to modern architectures in 2025. Explore key milestones, breakthroughs, and architectural innovations that shaped the LLM landscape.</p>
                    <div id="llm-timeline-viz" class="w-full h-[600px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the chronological evolution of LLM architectures from 2018 to 2025</li>
                            <li>• Learn about key breakthroughs and innovations that shaped modern LLMs</li>
                            <li>• Explore the relationship between architectural improvements and performance gains</li>
                            <li>• Recognize the impact of scaling laws, attention mechanisms, and training innovations</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This interactive timeline traces the remarkable evolution of Large Language Model architectures over the past seven years. 
                            Starting with the foundational GPT model in 2018, the timeline highlights key milestones including the introduction of 
                            BERT's bidirectional attention, T5's text-to-text paradigm, GPT-3's scaling breakthrough, and modern innovations like 
                            mixture-of-experts architectures and efficient attention mechanisms. Each milestone represents a significant advancement 
                            in our understanding of language modeling and the capabilities of AI systems.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The timeline reveals several key patterns: <strong>Scaling Laws</strong> show how increasing model size and data 
                            consistently improves performance. <strong>Architectural Innovations</strong> like attention mechanisms, 
                            mixture-of-experts, and efficient training techniques enable better performance per parameter. 
                            <strong>Training Breakthroughs</strong> including RLHF, instruction tuning, and alignment techniques 
                            improve model behavior and safety. The visualization demonstrates how each innovation builds upon previous 
                            work, creating a cumulative advancement in AI capabilities that continues to accelerate.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Foundational Papers:</strong> <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer" class="caption-link">"Attention Is All You Need" (2017)</a> | <a href="https://arxiv.org/abs/1810.04805" target="_blank" rel="noopener noreferrer" class="caption-link">BERT (2018)</a> | <a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener noreferrer" class="caption-link">GPT-3 (2020)</a> | <a href="https://arxiv.org/abs/2302.13971" target="_blank" rel="noopener noreferrer" class="caption-link">LLaMA (2023)</a></p>
                            <p><strong>Recent Innovations:</strong> <a href="https://arxiv.org/abs/2401.04088" target="_blank" rel="noopener noreferrer" class="caption-link">Mixtral 8x7B (2024)</a> | <a href="https://arxiv.org/abs/2402.17177" target="_blank" rel="noopener noreferrer" class="caption-link">Qwen2.5 (2024)</a> | <a href="https://arxiv.org/abs/2406.04489" target="_blank" rel="noopener noreferrer" class="caption-link">Gemini 2.0 (2024)</a></p>
                            <p><strong>Historical Context:</strong> <a href="https://www.oreilly.com/library/view/large-language-models/9781098150952/" target="_blank" rel="noopener noreferrer" class="caption-link">LLM Evolution Guide</a> | <a href="https://huggingface.co/blog/llm-timeline" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Timeline</a> | <a href="https://arxiv.org/abs/2303.18223" target="_blank" rel="noopener noreferrer" class="caption-link">LLM Survey</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">LLM Architecture Component Breakdown</h3>
                    <p class="text-text-secondary mb-4">Detailed technical breakdown of LLM architecture components: attention mechanisms, feedforward networks, positional encodings, and layer normalization. Interactive exploration of how these components work together to process language.</p>
                    <div id="llm-component-breakdown-viz" class="w-full h-[600px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the internal components and architecture of transformer-based LLMs</li>
                            <li>• Learn how attention mechanisms process and weight input tokens</li>
                            <li>• Explore feedforward networks and their role in feature transformation</li>
                            <li>• Understand positional encodings and their importance for sequence processing</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This visualization provides a detailed technical breakdown of the core components that make up modern Large Language Models. 
                            The transformer architecture consists of several key components: <strong>Multi-Head Attention</strong> mechanisms that allow the model 
                            to focus on different parts of the input sequence, <strong>Feedforward Networks</strong> that transform features through 
                            non-linear layers, <strong>Positional Encodings</strong> that provide sequence order information, and 
                            <strong>Layer Normalization</strong> that stabilizes training. Understanding these components is essential for 
                            comprehending how LLMs process and generate language.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The <strong>attention mechanism</strong> computes relationships between all pairs of tokens, allowing the model to 
                            understand context and dependencies. <strong>Multi-head attention</strong> enables the model to attend to different 
                            types of relationships simultaneously. <strong>Feedforward networks</strong> apply point-wise transformations, 
                            typically expanding to 4x the hidden dimension before projecting back. <strong>Positional encodings</strong> 
                            are crucial since transformers have no inherent notion of sequence order. <strong>Layer normalization</strong> 
                            and <strong>residual connections</strong> enable training of very deep networks by addressing the vanishing gradient problem.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Foundational Papers:</strong> <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer" class="caption-link">"Attention Is All You Need" (2017)</a> | <a href="https://arxiv.org/abs/2002.04745" target="_blank" rel="noopener noreferrer" class="caption-link">"The Annotated Transformer" (2018)</a> | <a href="https://arxiv.org/abs/2009.06732" target="_blank" rel="noopener noreferrer" class="caption-link">"Illustrated Transformer" (2020)</a></p>
                            <p><strong>Component Analysis:</strong> <a href="https://arxiv.org/abs/1906.04341" target="_blank" rel="noopener noreferrer" class="caption-link">"Analyzing Multi-Head Self-Attention" (2019)</a> | <a href="https://arxiv.org/abs/2002.12394" target="_blank" rel="noopener noreferrer" class="caption-link">"On Layer Normalization" (2020)</a> | <a href="https://arxiv.org/abs/2106.09685" target="_blank" rel="noopener noreferrer" class="caption-link">"RoFormer: Enhanced Transformer" (2021)</a></p>
                            <p><strong>Implementation Guides:</strong> <a href="https://pytorch.org/tutorials/beginner/transformer_tutorial.html" target="_blank" rel="noopener noreferrer" class="caption-link">PyTorch Transformer Tutorial</a> | <a href="https://www.tensorflow.org/tutorials/text/transformer" target="_blank" rel="noopener noreferrer" class="caption-link">TensorFlow Transformer</a> | <a href="https://github.com/huggingface/transformers" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Transformers</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">LLM Architecture Memory & Context Management</h3>
                    <p class="text-text-secondary mb-4">Comprehensive analysis of how different LLM architectures handle long sequences, context windows, memory mechanisms, and sequence length limitations. Interactive exploration of context management strategies across major architectures.</p>
                    <div id="llm-memory-context-viz" class="w-full h-[600px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand context window limitations and their impact on LLM performance</li>
                            <li>• Learn how different architectures handle long sequences and memory management</li>
                            <li>• Explore context extension techniques and their trade-offs</li>
                            <li>• Understand the relationship between context length and computational complexity</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This visualization provides a comprehensive analysis of how different Large Language Model architectures manage memory and context. 
                            <strong>Context Windows</strong> define the maximum sequence length a model can process, with most models having fixed limits. 
                            <strong>Memory Mechanisms</strong> include attention patterns, caching strategies, and context compression techniques. 
                            <strong>Sequence Length Scaling</strong> shows how computational complexity grows with context length, typically quadratically for standard attention. 
                            Understanding these limitations is crucial for selecting the right architecture for long-document processing, conversation systems, and memory-intensive applications.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            <strong>Standard Transformers</strong> have quadratic complexity O(n²) with sequence length, limiting practical context windows. 
                            <strong>Sliding Window Attention</strong> reduces complexity by limiting attention to nearby tokens. 
                            <strong>Hierarchical Attention</strong> processes documents in chunks with cross-chunk attention. 
                            <strong>Memory-Augmented Models</strong> use external memory stores for long-term context retention. 
                            <strong>Context Extension Techniques</strong> like RoPE scaling and ALiBi enable longer sequences without retraining. 
                            <strong>Efficient Attention</strong> mechanisms like Flash Attention and Sparse Attention reduce memory usage while maintaining performance.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Context Management:</strong> <a href="https://arxiv.org/abs/2004.05150" target="_blank" rel="noopener noreferrer" class="caption-link">"Longformer: Long Document Transformer" (2020)</a> | <a href="https://arxiv.org/abs/2108.12409" target="_blank" rel="noopener noreferrer" class="caption-link">"BigBird: Sparse Attention" (2021)</a> | <a href="https://arxiv.org/abs/2203.15556" target="_blank" rel="noopener noreferrer" class="caption-link">"PaLM: Scaling Language Models" (2022)</a></p>
                            <p><strong>Memory Techniques:</strong> <a href="https://arxiv.org/abs/2306.13643" target="_blank" rel="noopener noreferrer" class="caption-link">"Context Extension for LLMs" (2023)</a> | <a href="https://arxiv.org/abs/2309.17453" target="_blank" rel="noopener noreferrer" class="caption-link">"YaRN: Efficient Context Extension" (2023)</a> | <a href="https://arxiv.org/abs/2402.19477" target="_blank" rel="noopener noreferrer" class="caption-link">"Mamba: Linear-Time Sequence Modeling" (2024)</a></p>
                            <p><strong>Efficient Attention:</strong> <a href="https://arxiv.org/abs/2205.14135" target="_blank" rel="noopener noreferrer" class="caption-link">"FlashAttention: Fast Memory-Efficient Attention" (2022)</a> | <a href="https://arxiv.org/abs/2302.10866" target="_blank" rel="noopener noreferrer" class="caption-link">"Sparse Attention Patterns" (2023)</a> | <a href="https://arxiv.org/abs/2401.15025" target="_blank" rel="noopener noreferrer" class="caption-link">"Retrieval-Augmented Generation" (2024)</a></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="core-technologies" class="mb-20 pt-8">
            <h2 class="text-3xl font-bold mb-6 text-accent-blue">Core Technologies</h2>
            <p class="text-lg text-text-secondary mb-8">Essential technologies that power modern AI applications: MLOps/LLMOps, RAG systems, Vector Databases, and Multimodal capabilities. These technologies provide the infrastructure and tooling needed to deploy and scale LLM-based systems effectively.</p>
            <div class="space-y-12">
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">MLOps & LLMOps</h3>
                    <p class="text-text-secondary mb-4">This is the application of DevOps principles to machine
                        learning, creating a continuous, automated lifecycle for model development, deployment, and
                        governance.</p>
                    <div id="mlops-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the application of DevOps principles to machine learning workflows</li>
                            <li>• Learn about continuous integration and deployment for ML models</li>
                            <li>• Explore monitoring, versioning, and governance in ML operations</li>
                            <li>• Recognize the importance of automated ML lifecycle management</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            MLOps (Machine Learning Operations) extends DevOps principles to machine learning, creating automated pipelines for model development, testing, deployment, and monitoring. 
                            <strong>Continuous Integration</strong> ensures code quality and model performance through automated testing. 
                            <strong>Continuous Deployment</strong> enables rapid, reliable model updates to production environments. 
                            <strong>Model Versioning</strong> tracks model iterations and enables rollback capabilities. 
                            <strong>Monitoring & Observability</strong> provides real-time insights into model performance and data drift detection.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Modern MLOps platforms integrate with cloud providers and containerization technologies to provide scalable, reproducible ML workflows. 
                            Key components include experiment tracking, model registries, feature stores, and automated retraining pipelines.
                        </p>
                        
                        <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                            <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                            <div class="text-xs text-text-secondary space-y-1">
                                <p><strong>MLOps Frameworks:</strong> <a href="https://arxiv.org/abs/2209.09125" target="_blank" rel="noopener noreferrer" class="caption-link">"Operationalizing Machine Learning: An Interview Study" (2022)</a> | <a href="https://ml-ops.org/" target="_blank" rel="noopener noreferrer" class="caption-link">MLOps Community</a> | <a href="https://www.kubeflow.org/" target="_blank" rel="noopener noreferrer" class="caption-link">Kubeflow</a></p>
                                <p><strong>Tools & Platforms:</strong> <a href="https://www.mlflow.org/" target="_blank" rel="noopener noreferrer" class="caption-link">MLflow</a> | <a href="https://www.weightsandbiases.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Weights & Biases</a> | <a href="https://feast.dev/" target="_blank" rel="noopener noreferrer" class="caption-link">Feast Feature Store</a></p>
                            </div>
                        </div>
                    </div>
                    
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2209.09125" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Operationalizing Machine Learning: An Interview Study" - Shankar et
                            al. (2022)</a></p>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Retrieval-Augmented Generation (RAG)</h3>
                    <p class="text-text-secondary mb-4">RAG grounds LLMs in factual, external knowledge. The model
                        retrieves relevant documents to reduce hallucinations and use up-to-date or proprietary
                        information.</p>
                    <div class="lg:flex lg:space-x-4 items-center">
                        <div id="rag-viz" class="w-full lg:w-2/3 h-[400px] viz-container rounded-md"></div>
                        <div class="w-full lg:w-1/3 mt-4 lg:mt-0">
                            <div class="code-block" id="rag-code"></div>
                        </div>
                    </div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand how RAG combines retrieval and generation for knowledge-intensive tasks</li>
                            <li>• Learn about document retrieval strategies and relevance scoring</li>
                            <li>• Explore how RAG reduces hallucinations and improves factual accuracy</li>
                            <li>• Recognize the benefits of grounding LLMs in external knowledge sources</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Retrieval-Augmented Generation (RAG) enhances LLMs by retrieving relevant documents from external knowledge bases before generating responses. 
                            <strong>Document Retrieval</strong> uses dense vector search to find semantically similar content. 
                            <strong>Context Augmentation</strong> combines retrieved documents with the original query for enhanced generation. 
                            <strong>Hallucination Reduction</strong> occurs by grounding responses in factual, up-to-date information. 
                            <strong>Knowledge Freshness</strong> enables LLMs to access information beyond their training cutoff.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            RAG systems typically use transformer-based encoders for document embedding and retrieval. 
                            Advanced implementations include hybrid retrieval (dense + sparse), re-ranking mechanisms, and multi-hop reasoning capabilities.
                        </p>
                        
                        <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                            <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                            <div class="text-xs text-text-secondary space-y-1">
                                <p><strong>RAG Research:</strong> <a href="https://arxiv.org/abs/2005.11401" target="_blank" rel="noopener noreferrer" class="caption-link">"Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks" (2020)</a> | <a href="https://arxiv.org/abs/2202.01732" target="_blank" rel="noopener noreferrer" class="caption-link">"Improving Language Models by Retrieving from Trillions of Tokens" (2022)</a></p>
                                <p><strong>Implementation:</strong> <a href="https://github.com/huggingface/transformers" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Transformers</a> | <a href="https://github.com/facebookresearch/DPR" target="_blank" rel="noopener noreferrer" class="caption-link">Dense Passage Retrieval</a> | <a href="https://github.com/facebookresearch/faiss" target="_blank" rel="noopener noreferrer" class="caption-link">FAISS Vector Search</a></p>
                            </div>
                        </div>
                    </div>
                    
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2005.11401" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks" -
                            Lewis et al. (2020)</a></p>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Vector Databases</h3>
                    <p class="text-text-secondary mb-4">Vector databases store and index data as high-dimensional
                        vectors (embeddings) for efficient similarity search, enabling applications like RAG and image
                        search.</p>
                    <div id="vector-db-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand how vector databases store and index high-dimensional embeddings</li>
                            <li>• Learn about similarity search algorithms and indexing strategies</li>
                            <li>• Explore vector database applications in RAG and multimodal systems</li>
                            <li>• Recognize the performance benefits of specialized vector storage</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Vector databases are specialized storage systems optimized for high-dimensional vector similarity search. 
                            <strong>Embedding Storage</strong> converts text, images, and other data into dense vector representations. 
                            <strong>Similarity Search</strong> uses algorithms like HNSW and IVF to find nearest neighbors efficiently. 
                            <strong>Indexing Strategies</strong> balance search speed with memory usage for different use cases. 
                            <strong>Scalability</strong> enables handling millions of vectors with sub-millisecond search times.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Modern vector databases use advanced indexing algorithms like HNSW (Hierarchical Navigable Small World) and IVF (Inverted File) for efficient similarity search. 
                            They integrate with embedding models and provide real-time indexing capabilities for dynamic data updates.
                        </p>
                        
                        <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                            <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                            <div class="text-xs text-text-secondary space-y-1">
                                <p><strong>Vector Database Research:</strong> <a href="https://arxiv.org/abs/2302.00918" target="_blank" rel="noopener noreferrer" class="caption-link">"A Survey on Vector Databases" (2023)</a> | <a href="https://arxiv.org/abs/1603.09320" target="_blank" rel="noopener noreferrer" class="caption-link">"Efficient and Robust Approximate Nearest Neighbor Search" (2016)</a></p>
                                <p><strong>Implementation:</strong> <a href="https://github.com/facebookresearch/faiss" target="_blank" rel="noopener noreferrer" class="caption-link">FAISS</a> | <a href="https://github.com/milvus-io/milvus" target="_blank" rel="noopener noreferrer" class="caption-link">Milvus</a> | <a href="https://github.com/weaviate/weaviate" target="_blank" rel="noopener noreferrer" class="caption-link">Weaviate</a> | <a href="https://github.com/qdrant/qdrant" target="_blank" rel="noopener noreferrer" class="caption-link">Qdrant</a></p>
                            </div>
                        </div>
                    </div>
                    
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2302.00918" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"A Survey on Vector Databases" - J. Zhang et al. (2023)</a></p>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Multimodal Foundation Models</h3>
                    <p class="text-text-secondary mb-4">These models understand and process information from multiple
                        modalities (text, images, audio) by learning a shared representation space where different data
                        types can be compared.</p>
                    <div id="multimodal-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand how multimodal models process text, images, and audio simultaneously</li>
                            <li>• Learn about shared representation spaces and cross-modal understanding</li>
                            <li>• Explore the benefits of unified multimodal architectures</li>
                            <li>• Recognize applications in vision-language tasks and content understanding</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Multimodal foundation models process multiple data types through unified architectures. 
                            <strong>Shared Representation Space</strong> enables cross-modal understanding and comparison. 
                            <strong>Cross-Modal Attention</strong> allows models to attend to relevant information across modalities. 
                            <strong>Unified Processing</strong> handles text, images, and audio through consistent neural architectures. 
                            <strong>Transfer Learning</strong> enables knowledge transfer between different modalities and tasks.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Modern multimodal models use transformer architectures with specialized encoders for each modality. 
                            They employ contrastive learning and cross-modal attention mechanisms to align representations across different data types.
                        </p>
                        
                        <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                            <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                            <div class="text-xs text-text-secondary space-y-1">
                                <p><strong>Multimodal Research:</strong> <a href="https://arxiv.org/abs/2103.00020" target="_blank" rel="noopener noreferrer" class="caption-link">"Learning Transferable Visual Models From Natural Language Supervision" (CLIP) (2021)</a> | <a href="https://arxiv.org/abs/2202.03052" target="_blank" rel="noopener noreferrer" class="caption-link">"PaLM: Scaling Language Modeling with Pathways" (2022)</a></p>
                                <p><strong>Implementation:</strong> <a href="https://github.com/openai/CLIP" target="_blank" rel="noopener noreferrer" class="caption-link">CLIP</a> | <a href="https://github.com/huggingface/transformers" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Transformers</a> | <a href="https://github.com/facebookresearch/mae" target="_blank" rel="noopener noreferrer" class="caption-link">Masked Autoencoder</a></p>
                            </div>
                        </div>
                    </div>
                    
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2103.00020" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Learning Transferable Visual Models From Natural Language Supervision"
                            (CLIP) - Radford et al. (2021)</a></p>
                </div>
            </div>
        </section>

        <section id="agentic-systems" class="mb-20 pt-8">
            <h2 class="text-3xl font-bold mb-6 text-accent-blue">Agentic Systems</h2>
            <p class="text-lg text-text-secondary mb-8">Building on LLM foundations and core technologies, agentic systems represent the next evolution: AI systems that can reason, plan, and act autonomously. This section covers unified ecosystem architectures, strategic planning frameworks, and the transition from reactive to proactive AI systems.</p>
            <div class="space-y-12">
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Unified AI Ecosystem Architecture</h3>
                    <p class="text-text-secondary mb-4">A hybrid architecture where on-device models provide instant,
                        private assistance, while enterprise services offer large-scale computation. A central AI
                        platform synchronizes experiences and manages models.</p>
                    <div id="ecosystem-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand hybrid AI architectures combining on-device and cloud-based processing</li>
                            <li>• Learn about privacy-preserving AI deployment strategies</li>
                            <li>• Explore synchronization patterns between local and enterprise AI services</li>
                            <li>• Recognize the benefits of unified AI platforms for consistent user experiences</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            The Unified AI Ecosystem represents a hybrid architecture where <strong>on-device models</strong> provide instant, 
                            private assistance while <strong>enterprise services</strong> offer large-scale computation and complex reasoning. 
                            A central <strong>AI platform</strong> synchronizes experiences and manages models across different deployment contexts. 
                            This approach balances <strong>latency</strong> (local processing), <strong>privacy</strong> (sensitive data stays local), 
                            and <strong>capability</strong> (cloud resources for complex tasks).
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The architecture employs <strong>edge-cloud orchestration</strong> where lightweight models handle routine tasks locally 
                            while complex queries are routed to cloud-based large models. <strong>Model synchronization</strong> ensures consistent 
                            behavior across deployment targets. <strong>Privacy-preserving techniques</strong> like federated learning and 
                            differential privacy enable collaborative learning without exposing sensitive data. The central platform manages 
                            <strong>model versioning</strong>, <strong>deployment strategies</strong>, and <strong>performance monitoring</strong> 
                            across the entire ecosystem.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/2308.14966" target="_blank" rel="noopener noreferrer" class="caption-link">"FedML: A Research Library and Benchmark for Federated Machine Learning" - He et al. (2023)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2207.10083" target="_blank" rel="noopener noreferrer" class="caption-link">Edge AI Computing</a> | <a href="https://arxiv.org/abs/2305.17564" target="_blank" rel="noopener noreferrer" class="caption-link">Privacy-Preserving ML</a> | <a href="https://research.google/pubs/pub45648/" target="_blank" rel="noopener noreferrer" class="caption-link">Federated Learning</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://flower.dev/" target="_blank" rel="noopener noreferrer" class="caption-link">Flower</a> | <a href="https://github.com/FedML-AI/FedML" target="_blank" rel="noopener noreferrer" class="caption-link">FedML</a> | <a href="https://onnx.ai/" target="_blank" rel="noopener noreferrer" class="caption-link">ONNX Runtime</a></p>
                        </div>
                    </div>
                </div>
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Actionable 90-Day Strategic Plan</h3>
                    <p class="text-text-secondary mb-4">A rapid, phased approach to move from concept to a functional
                        internal pilot, prioritizing foundational work, iterative development, and early stakeholder
                        feedback.</p>
                    <div id="gantt-chart-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand phased approaches to AI system development and deployment</li>
                            <li>• Learn about iterative development methodologies for AI projects</li>
                            <li>• Explore stakeholder engagement strategies and feedback loops</li>
                            <li>• Recognize critical milestones and dependencies in AI implementation timelines</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            The 90-Day Strategic Plan employs a <strong>rapid, phased approach</strong> to move from concept to functional 
                            internal pilot. <strong>Phase 1</strong> focuses on foundational infrastructure and core capabilities. 
                            <strong>Phase 2</strong> emphasizes iterative development and feature implementation. <strong>Phase 3</strong> 
                            prioritizes stakeholder feedback integration and performance optimization. This approach enables 
                            <strong>early validation</strong>, <strong>risk mitigation</strong>, and <strong>continuous improvement</strong> 
                            throughout the development lifecycle.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The strategic plan employs <strong>Agile methodologies</strong> with 30-day sprint cycles aligned to business objectives. 
                            <strong>Infrastructure-first approach</strong> establishes MLOps pipelines and monitoring before model development. 
                            <strong>Incremental complexity</strong> starts with simple use cases and progressively adds sophisticated features. 
                            <strong>Continuous stakeholder engagement</strong> ensures alignment with business requirements and enables rapid 
                            course correction. <strong>Automated testing and deployment</strong> pipelines enable frequent, reliable releases 
                            within the compressed timeline.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://www.mckinsey.com/capabilities/quantumblack/our-insights/the-state-of-ai-in-2023-generative-ais-breakout-year" target="_blank" rel="noopener noreferrer" class="caption-link">"The State of AI in 2023: Generative AI's Breakout Year" - McKinsey (2023)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://agilemanifesto.org/" target="_blank" rel="noopener noreferrer" class="caption-link">Agile Methodology</a> | <a href="https://ml-ops.org/content/mlops-principles" target="_blank" rel="noopener noreferrer" class="caption-link">MLOps Principles</a> | <a href="https://www.lean.org/explore-lean/what-is-lean/" target="_blank" rel="noopener noreferrer" class="caption-link">Lean Startup</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://www.atlassian.com/software/jira" target="_blank" rel="noopener noreferrer" class="caption-link">Jira</a> | <a href="https://github.com/features/project-management" target="_blank" rel="noopener noreferrer" class="caption-link">GitHub Projects</a> | <a href="https://monday.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Monday.com</a></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <section id="advanced-patterns" class="mb-20 pt-8">
            <h2 class="text-3xl font-bold mb-6 text-accent-blue">Advanced Patterns</h2>
            <p class="text-lg text-text-secondary mb-8">Sophisticated architectural patterns and optimization strategies that build on agentic systems: Advanced RAG pipelines, fine-tuning methodologies, evaluation frameworks, and performance optimization techniques. This section covers cutting-edge approaches for production-ready AI systems.</p>
            <div class="space-y-12">

                <!-- Card 1: Foundation Model Ecosystem -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Foundation Model Ecosystem (Sept. 2025
                        Projection)</h3>
                    <p class="text-text-secondary mb-4">The model landscape has diversified beyond a simple performance
                        race. Architecting now involves selecting from a rich ecosystem: massive proprietary models for
                        peak reasoning, specialized open-source families (like DeepSeek & Qwen) for tasks like coding,
                        and hyper-efficient models designed for edge devices and specific modalities like real-time
                        voice.</p>
                    <div id="foundation-model-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the diverse ecosystem of foundation models and their specialized use cases</li>
                            <li>• Learn to evaluate and select appropriate models based on performance, efficiency, and deployment requirements</li>
                            <li>• Recognize the trade-offs between proprietary and open-source model families</li>
                            <li>• Explore edge-optimized models and their applications in resource-constrained environments</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            The foundation model landscape has evolved beyond simple performance metrics to include specialized models 
                            for specific tasks, modalities, and deployment scenarios. This visualization shows the current ecosystem 
                            including massive proprietary models for complex reasoning, specialized open-source families for coding 
                            and domain-specific tasks, and hyper-efficient models designed for edge deployment and real-time applications.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            Model selection now involves balancing <strong>performance</strong> (reasoning capability), <strong>efficiency</strong> 
                            (resource requirements), and <strong>specialization</strong> (domain expertise). <strong>Proprietary models</strong> 
                            excel at general reasoning but require significant resources. <strong>Open-source families</strong> like DeepSeek 
                            and Qwen offer specialized capabilities for coding and multilingual tasks. <strong>Edge-optimized models</strong> 
                            prioritize efficiency for real-time applications and resource-constrained environments.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://dl.acm.org/doi/10.1145/3442188.3445922" target="_blank" rel="noopener noreferrer" class="caption-link">"On the Dangers of Stochastic Parrots" - Bender et al. (2021)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2302.00083" target="_blank" rel="noopener noreferrer" class="caption-link">Foundation Model Evaluation</a> | <a href="https://arxiv.org/abs/2303.18223" target="_blank" rel="noopener noreferrer" class="caption-link">Model Efficiency Research</a> | <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard" target="_blank" rel="noopener noreferrer" class="caption-link">Open LLM Leaderboard</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://huggingface.co/" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Hub</a> | <a href="https://ollama.ai/" target="_blank" rel="noopener noreferrer" class="caption-link">Ollama</a> | <a href="https://github.com/microsoft/DeepSpeed" target="_blank" rel="noopener noreferrer" class="caption-link">DeepSpeed</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 2: Model Fine-Tuning Techniques -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Model Fine-Tuning Techniques</h3>
                    <p class="text-text-secondary mb-4">Adapting a pre-trained model is more efficient than training
                        from scratch. <strong>Full Fine-Tuning</strong> updates all model weights, requiring significant
                        compute. <strong>Parameter-Efficient Fine-Tuning (PEFT)</strong> methods like
                        <strong>LoRA</strong> freeze the base model and train small, additive "adapter" layers,
                        drastically reducing resource needs. <strong>SoRA (Sparse Low-rank Adaptation)</strong> combines
                        LoRA efficiency with sparsity for breakthrough performance.
                    </p>
                    <div id="fine-tuning-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the different approaches to model adaptation and their resource requirements</li>
                            <li>• Learn about Parameter-Efficient Fine-Tuning (PEFT) methods and their advantages</li>
                            <li>• Explore LoRA (Low-Rank Adaptation) and its efficiency benefits</li>
                            <li>• Discover SoRA (Sparse Low-Rank Adaptation) and breakthrough performance improvements</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Model fine-tuning adapts pre-trained models to specific tasks more efficiently than training from scratch. 
                            Full fine-tuning updates all model weights but requires significant computational resources. PEFT methods 
                            like LoRA freeze the base model and train small adapter layers, dramatically reducing resource needs. 
                            SoRA combines LoRA efficiency with sparsity for breakthrough performance improvements.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            <strong>Full Fine-Tuning</strong> provides maximum adaptation but requires substantial compute resources. 
                            <strong>LoRA</strong> decomposes weight updates into low-rank matrices, reducing trainable parameters by 99%+ 
                            while maintaining performance. <strong>SoRA</strong> introduces sparsity to LoRA, enabling even more efficient 
                            adaptation with breakthrough performance gains. These methods enable rapid model customization for specific 
                            domains and use cases without the computational overhead of full fine-tuning.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2106.09685" target="_blank" rel="noopener noreferrer" class="caption-link">"LoRA: Low-Rank Adaptation of Large Language Models" - Hu et al. (2021)</a> | <a href="https://arxiv.org/abs/2311.11685" target="_blank" rel="noopener noreferrer" class="caption-link">"SoRA: Sparse Low-Rank Adaptation" - Dettmers et al. (2023)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2205.05638" target="_blank" rel="noopener noreferrer" class="caption-link">QLoRA: Efficient Finetuning</a> | <a href="https://arxiv.org/abs/2305.14314" target="_blank" rel="noopener noreferrer" class="caption-link">AdaLoRA: Adaptive LoRA</a> | <a href="https://arxiv.org/abs/2303.16199" target="_blank" rel="noopener noreferrer" class="caption-link">PEFT Survey</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://github.com/huggingface/peft" target="_blank" rel="noopener noreferrer" class="caption-link">PEFT Library</a> | <a href="https://github.com/microsoft/LoRA" target="_blank" rel="noopener noreferrer" class="caption-link">LoRA Implementation</a> | <a href="https://github.com/artidoro/qlora" target="_blank" rel="noopener noreferrer" class="caption-link">QLoRA</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 3: Vector Database Providers -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-blue">Vector Database Providers</h3>
                    <p class="text-text-secondary mb-4">The choice of vector database depends on scale, operational
                        overhead, and licensing. Hosted solutions like Pinecone offer ease of use, while self-hosted
                        options like Milvus and Weaviate provide control. Lighter, in-process libraries like Chroma are
                        ideal for smaller-scale applications and rapid development.</p>
                    <div id="vector-db-viz-advanced" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the different vector database solutions and their trade-offs</li>
                            <li>• Learn to evaluate vector databases based on scale, operational overhead, and licensing</li>
                            <li>• Compare hosted vs self-hosted solutions for different use cases</li>
                            <li>• Explore lightweight in-process libraries for rapid development and smaller-scale applications</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Vector database selection depends on scale requirements, operational complexity, and licensing preferences. 
                            Hosted solutions like Pinecone offer ease of use and managed infrastructure, while self-hosted options 
                            like Milvus and Weaviate provide full control and customization. Lighter, in-process libraries like Chroma 
                            are ideal for smaller-scale applications and rapid prototyping.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            <strong>Hosted Solutions</strong> (Pinecone, Weaviate Cloud) provide managed infrastructure with automatic scaling 
                            and maintenance. <strong>Self-Hosted Solutions</strong> (Milvus, Weaviate, Qdrant) offer full control over data 
                            and infrastructure but require operational expertise. <strong>In-Process Libraries</strong> (Chroma, FAISS) 
                            are embedded directly in applications, ideal for development and smaller deployments. Consider factors like 
                            data privacy, compliance requirements, and operational overhead when selecting the appropriate solution.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/2302.00918" target="_blank" rel="noopener noreferrer" class="caption-link">"A Survey on Vector Databases" - J. Zhang et al. (2023)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2302.00083" target="_blank" rel="noopener noreferrer" class="caption-link">Vector Search Optimization</a> | <a href="https://arxiv.org/abs/2303.18223" target="_blank" rel="noopener noreferrer" class="caption-link">Similarity Search Algorithms</a> | <a href="https://arxiv.org/abs/2304.01420" target="_blank" rel="noopener noreferrer" class="caption-link">RAG System Architecture</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://www.pinecone.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Pinecone</a> | <a href="https://milvus.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Milvus</a> | <a href="https://weaviate.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Weaviate</a> | <a href="https://www.trychroma.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Chroma</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 4: Advanced RAG Patterns -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Advanced RAG Patterns</h3>
                    <p class="text-text-secondary mb-4">RAG is evolving from a simple retrieve-then-generate pipeline to
                        more dynamic, intelligent systems. Self-corrective patterns add internal critique loops to
                        refine answers, while agentic patterns use an LLM to orchestrate a complex research process,
                        including query rewriting and multi-step retrieval.</p>
                    <div id="advanced-rag-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand advanced RAG patterns beyond basic retrieval-augmented generation</li>
                            <li>• Learn about self-corrective loops and quality improvement mechanisms</li>
                            <li>• Explore agentic patterns for intelligent orchestration and multi-step retrieval</li>
                            <li>• Recognize the evolution from reactive to proactive AI systems</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Advanced RAG systems move beyond simple retrieval-augmented generation to become dynamic, intelligent systems. 
                            <strong>Self-corrective patterns</strong> add internal critique loops to refine answers and improve quality. 
                            <strong>Agentic patterns</strong> use LLMs to orchestrate complex research processes including query rewriting, 
                            multi-step retrieval, and cross-source validation. <strong>Adaptive retrieval</strong> adjusts strategies based 
                            on query complexity and context requirements.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            Advanced RAG architectures implement <strong>multi-agent coordination</strong> where specialized agents handle 
                            different aspects of the retrieval process. <strong>Query decomposition</strong> breaks complex questions into 
                            manageable sub-queries. <strong>Evidence synthesis</strong> combines information from multiple sources with 
                            confidence scoring. <strong>Iterative refinement</strong> enables the system to improve responses through 
                            multiple rounds of retrieval and reasoning, creating more accurate and comprehensive answers.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/2308.08155" target="_blank" rel="noopener noreferrer" class="caption-link">"AutoGen: Enabling Next-Gen LLM Applications via Multi-Agent Conversation" - Wu et al. (2023)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2402.19473" target="_blank" rel="noopener noreferrer" class="caption-link">GraphRAG</a> | <a href="https://arxiv.org/abs/2312.10997" target="_blank" rel="noopener noreferrer" class="caption-link">Self-RAG</a> | <a href="https://arxiv.org/abs/2310.11511" target="_blank" rel="noopener noreferrer" class="caption-link">CRAG: Corrective RAG</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://github.com/microsoft/autogen" target="_blank" rel="noopener noreferrer" class="caption-link">AutoGen</a> | <a href="https://github.com/langchain-ai/langchain" target="_blank" rel="noopener noreferrer" class="caption-link">LangChain</a> | <a href="https://github.com/microsoft/graphrag" target="_blank" rel="noopener noreferrer" class="caption-link">GraphRAG</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 5: Model Serving & Inference Optimization -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Model Serving & Inference Optimization</h3>
                    <p class="text-text-secondary mb-4">Deploying LLMs efficiently requires a dedicated serving layer.
                        Techniques like batching requests, quantizing models to smaller data types (e.g., INT8), and
                        using specialized hardware (GPUs/TPUs) are critical for reducing latency and improving
                        throughput for real-world applications.</p>
                    <div id="inference-optimization-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the architecture and components of efficient LLM serving systems</li>
                            <li>• Learn about optimization techniques including batching, quantization, and hardware acceleration</li>
                            <li>• Explore trade-offs between latency, throughput, and resource utilization</li>
                            <li>• Recognize the importance of specialized serving infrastructure for production deployments</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Efficient LLM deployment requires a dedicated serving layer optimized for production workloads. 
                            <strong>Request batching</strong> combines multiple inference requests to maximize GPU utilization. 
                            <strong>Model quantization</strong> reduces memory footprint by using smaller data types (INT8, FP16). 
                            <strong>Hardware acceleration</strong> leverages specialized processors (GPUs, TPUs) for optimal performance. 
                            <strong>Caching strategies</strong> reduce redundant computations and improve response times.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            Modern serving systems implement <strong>dynamic batching</strong> to balance latency and throughput automatically. 
                            <strong>KV-cache optimization</strong> stores attention computation results to avoid recomputation during generation. 
                            <strong>Continuous batching</strong> enables processing requests of different lengths simultaneously. 
                            <strong>Multi-GPU inference</strong> distributes model layers across multiple devices for larger models. 
                            <strong>Speculative decoding</strong> and <strong>parallel sampling</strong> further accelerate generation while 
                            maintaining quality.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/2211.05102" target="_blank" rel="noopener noreferrer" class="caption-link">"A Survey of Large Language Model Serving Techniques" - S. Yu et al. (2022)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2305.13245" target="_blank" rel="noopener noreferrer" class="caption-link">vLLM: Efficient Memory Management</a> | <a href="https://arxiv.org/abs/2309.17453" target="_blank" rel="noopener noreferrer" class="caption-link">FlashAttention-2</a> | <a href="https://arxiv.org/abs/2302.01318" target="_blank" rel="noopener noreferrer" class="caption-link">Speculative Decoding</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://github.com/vllm-project/vllm" target="_blank" rel="noopener noreferrer" class="caption-link">vLLM</a> | <a href="https://github.com/huggingface/text-generation-inference" target="_blank" rel="noopener noreferrer" class="caption-link">Text Generation Inference</a> | <a href="https://github.com/NVIDIA/TensorRT-LLM" target="_blank" rel="noopener noreferrer" class="caption-link">TensorRT-LLM</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 6: Advanced Retrieval Systems -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Advanced Retrieval Systems</h3>
                    <p class="text-text-secondary mb-4">Mature agentic systems require a "retriever of retrievers." An
                        orchestrating agent analyzes the query and routes it to the most appropriate data source. For
                        high confidence, it may query multiple sources to verify and synthesize redundant information.
                    </p>
                    <div id="advanced-retrieval-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand meta-retrieval systems that orchestrate multiple data sources</li>
                            <li>• Learn about query routing and intelligent source selection</li>
                            <li>• Explore multi-source verification and redundancy strategies</li>
                            <li>• Recognize the architecture of mature agentic retrieval systems</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Advanced retrieval systems implement a "retriever of retrievers" architecture where an orchestrating agent 
                            analyzes queries and routes them to the most appropriate data sources. <strong>Query routing</strong> matches 
                            questions to specialized knowledge bases or retrieval systems. <strong>Multi-source verification</strong> 
                            queries multiple sources to verify and synthesize redundant information. <strong>Confidence scoring</strong> 
                            evaluates the reliability of retrieved information across different sources.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The system employs <strong>intelligent query classification</strong> to determine optimal retrieval strategies. 
                            <strong>Source-specific adapters</strong> handle different data formats and APIs uniformly. 
                            <strong>Ensemble retrieval</strong> combines results from multiple sources with weighted scoring. 
                            <strong>GraphRAG techniques</strong> leverage knowledge graphs for complex relational queries. 
                            <strong>Feedback loops</strong> continuously improve routing decisions based on retrieval success rates and 
                            user satisfaction metrics.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/2402.19473" target="_blank" rel="noopener noreferrer" class="caption-link">"GraphRAG: Unlocking Grounded Reasoning in LLMs" - E. Glass et al. (2024)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2312.11036" target="_blank" rel="noopener noreferrer" class="caption-link">Multi-Vector Retrieval</a> | <a href="https://arxiv.org/abs/2401.15884" target="_blank" rel="noopener noreferrer" class="caption-link">Adaptive Retrieval</a> | <a href="https://arxiv.org/abs/2307.15043" target="_blank" rel="noopener noreferrer" class="caption-link">Knowledge Graph RAG</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://github.com/microsoft/graphrag" target="_blank" rel="noopener noreferrer" class="caption-link">GraphRAG</a> | <a href="https://www.llamaindex.ai/" target="_blank" rel="noopener noreferrer" class="caption-link">LlamaIndex</a> | <a href="https://github.com/hwchase17/langchain" target="_blank" rel="noopener noreferrer" class="caption-link">LangChain Retrievers</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 7: Prompt Engineering & Agentic Behavior -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Prompt Engineering & Agentic Behavior</h3>
                    <p class="text-text-secondary mb-4">Effective AI systems rely on precise prompt design and
                        management to control and shape the model's behavior. Prompt engineering involves iteratively
                        designing, testing, versioning, and deploying prompts while understanding patterns like
                        <strong>1‑Shot prompting</strong> and <strong>ReAct</strong> loops for complex reasoning and
                        acting tasks.
                    </p>
                    <div id="prompt-engineering-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand systematic approaches to prompt design and optimization</li>
                            <li>• Learn about advanced prompting patterns including 1-Shot and ReAct loops</li>
                            <li>• Explore prompt versioning, testing, and deployment strategies</li>
                            <li>• Recognize the role of prompt engineering in controlling agentic behavior</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Effective AI systems rely on precise prompt design and management to control and shape model behavior. 
                            <strong>Systematic prompt engineering</strong> involves iterative design, testing, and optimization cycles. 
                            <strong>1-Shot prompting</strong> provides single examples to guide model responses. <strong>ReAct loops</strong> 
                            combine reasoning and acting for complex task execution. <strong>Prompt versioning</strong> ensures reproducible 
                            and deployable prompt management across environments.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            Advanced prompt engineering employs <strong>template systems</strong> for reusable prompt components. 
                            <strong>Chain-of-thought prompting</strong> guides models through step-by-step reasoning processes. 
                            <strong>Retrieval-augmented prompting</strong> dynamically incorporates relevant context. 
                            <strong>Prompt optimization algorithms</strong> automatically tune prompt parameters for specific tasks. 
                            <strong>A/B testing frameworks</strong> evaluate prompt performance across different model versions and 
                            deployment scenarios.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/2301.11324" target="_blank" rel="noopener noreferrer" class="caption-link">"ReAct: Synergizing Reasoning and Acting in Language Models" - Yao et al. (2023)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2201.11903" target="_blank" rel="noopener noreferrer" class="caption-link">Chain-of-Thought Prompting</a> | <a href="https://arxiv.org/abs/2205.11916" target="_blank" rel="noopener noreferrer" class="caption-link">Self-Consistency</a> | <a href="https://arxiv.org/abs/2210.03493" target="_blank" rel="noopener noreferrer" class="caption-link">ReAct Reasoning</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://www.promptfoo.dev/" target="_blank" rel="noopener noreferrer" class="caption-link">Promptfoo</a> | <a href="https://github.com/microsoft/promptflow" target="_blank" rel="noopener noreferrer" class="caption-link">PromptFlow</a> | <a href="https://docs.anthropic.com/claude/docs/prompt-engineering" target="_blank" rel="noopener noreferrer" class="caption-link">Anthropic Prompt Engineering</a></p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="enterprise-deployment" class="mb-16 pt-16">
            <h2 class="text-3xl font-bold mb-2 text-accent-blue">Enterprise Deployment</h2>
            <p class="text-lg text-text-secondary mb-8">Production-ready deployment strategies and enterprise governance for AI systems: Application stacks, security hardening, cloud-native architectures, observability, evaluation frameworks, and comprehensive CI/CD pipelines. This section covers everything needed to deploy and maintain AI systems at enterprise scale.</p>
            <div class="space-y-12">

                <!-- Card 1: LLM Application Stack -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">LLM Application Stack</h3>
                    <p class="text-text-secondary mb-4">A robust LLM application is a layered system. The core
                        functionality is provided by <strong>Tools</strong> and <strong>RAG</strong>. This core is
                        wrapped by a crucial <strong>Guardrails</strong> layer for safety and compliance. The entire
                        system's quality and reliability are ensured by an outer loop of <strong>Evaluation
                            Harnesses</strong>.</p>
                    <div id="llm-app-stack-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the layered architecture of production-ready LLM applications</li>
                            <li>• Learn about the core functionality provided by Tools and RAG systems</li>
                            <li>• Recognize the importance of Guardrails for safety and compliance</li>
                            <li>• Explore Evaluation Harnesses for ensuring system quality and reliability</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            A robust LLM application follows a layered architecture where core functionality is provided by Tools 
                            and RAG systems. This core is wrapped by a crucial Guardrails layer for safety and compliance, ensuring 
                            responsible AI deployment. The entire system's quality and reliability are maintained through an outer 
                            loop of Evaluation Harnesses that continuously monitor and validate performance.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The <strong>Tools layer</strong> provides external functionality and API integrations. The <strong>RAG layer</strong> 
                            enables knowledge retrieval and context enhancement. <strong>Guardrails</strong> implement safety measures, 
                            content filtering, and compliance controls. <strong>Evaluation Harnesses</strong> provide automated testing, 
                            performance monitoring, and quality assurance. This layered approach ensures modularity, maintainability, 
                            and the ability to scale individual components independently while maintaining system integrity.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://python.langchain.com/docs/introduction/" target="_blank" rel="noopener noreferrer" class="caption-link">LangChain Documentation</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2302.00083" target="_blank" rel="noopener noreferrer" class="caption-link">LLM Application Architecture</a> | <a href="https://arxiv.org/abs/2303.18223" target="_blank" rel="noopener noreferrer" class="caption-link">RAG System Design</a> | <a href="https://arxiv.org/abs/2304.01420" target="_blank" rel="noopener noreferrer" class="caption-link">AI Safety and Guardrails</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://langchain.com/" target="_blank" rel="noopener noreferrer" class="caption-link">LangChain</a> | <a href="https://github.com/microsoft/guidance" target="_blank" rel="noopener noreferrer" class="caption-link">Guidance</a> | <a href="https://github.com/huggingface/transformers" target="_blank" rel="noopener noreferrer" class="caption-link">Transformers</a> | <a href="https://github.com/microsoft/semantic-kernel" target="_blank" rel="noopener noreferrer" class="caption-link">Semantic Kernel</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 2: Prompt Injection & Hardening -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Prompt Injection & Hardening</h3>
                    <p class="text-text-secondary mb-4">Securing LLMs involves building robust input/output guardrails
                        and continuously testing them against adversarial attacks. This includes direct injection
                        ("Ignore previous instructions"), indirect injection (poisoning retrieved data), and model
                        jailbreaking to elicit unsafe content.</p>
                    <div id="prompt-injection-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand the different types of prompt injection attacks and their mechanisms</li>
                            <li>• Learn about building robust input/output guardrails for LLM security</li>
                            <li>• Explore adversarial testing strategies for continuous security validation</li>
                            <li>• Recognize the importance of model jailbreaking prevention and content filtering</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Securing LLMs requires building robust guardrails and continuously testing them against adversarial attacks. 
                            This includes direct injection attacks ("Ignore previous instructions"), indirect injection through poisoned 
                            retrieved data, and model jailbreaking attempts to elicit unsafe content. Effective security requires 
                            multi-layered defenses and continuous monitoring.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            <strong>Direct Injection</strong> attempts to override system instructions through malicious prompts. 
                            <strong>Indirect Injection</strong> poisons retrieved data to influence model behavior. <strong>Jailbreaking</strong> 
                            techniques exploit model vulnerabilities to bypass safety measures. <strong>Defense strategies</strong> include 
                            input sanitization, output filtering, context isolation, and adversarial testing. <strong>Continuous monitoring</strong> 
                            and red teaming are essential for maintaining security as attack vectors evolve.
                        </p>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary Reference:</strong> <a href="https://arxiv.org/abs/2302.12173" target="_blank" rel="noopener noreferrer" class="caption-link">"Not what you've signed up for: Compromising Real-World LLM-Integrated Applications" - Greshake et al. (2023)</a></p>
                            <p><strong>Related Concepts:</strong> <a href="https://arxiv.org/abs/2302.00083" target="_blank" rel="noopener noreferrer" class="caption-link">AI Safety Research</a> | <a href="https://arxiv.org/abs/2303.18223" target="_blank" rel="noopener noreferrer" class="caption-link">Adversarial Attacks on LLMs</a> | <a href="https://arxiv.org/abs/2304.01420" target="_blank" rel="noopener noreferrer" class="caption-link">Prompt Engineering Security</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://github.com/microsoft/guidance" target="_blank" rel="noopener noreferrer" class="caption-link">Guidance</a> | <a href="https://github.com/huggingface/transformers" target="_blank" rel="noopener noreferrer" class="caption-link">Transformers</a> | <a href="https://github.com/microsoft/semantic-kernel" target="_blank" rel="noopener noreferrer" class="caption-link">Semantic Kernel</a> | <a href="https://github.com/OWASP/www-project-top-10-for-large-language-model-applications" target="_blank" rel="noopener noreferrer" class="caption-link">OWASP LLM Top 10</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 3: Cloud-Native Gen AI Stacks -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Cloud-Native Gen AI Stacks</h3>
                    <p class="text-text-secondary mb-4">Major cloud providers offer managed services that integrate data
                        storage, model hosting, and serverless functions into a cohesive, compliant stack. This
                        simplifies operations and helps enforce data policies by leveraging the provider's built-in
                        security and compliance controls.</p>
                    <div id="cloud-native-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2308.12950" target="_blank" rel="noopener noreferrer" class="caption-link">"Cloud-Native AI: Architecture and Best Practices" (2023)</a> | <a href="https://arxiv.org/abs/2310.03589" target="_blank" rel="noopener noreferrer" class="caption-link">"Serverless Computing for ML Workloads" (2023)</a></p>
                            <p><strong>Cloud Platforms:</strong> <a href="https://aws.amazon.com/bedrock/" target="_blank" rel="noopener noreferrer" class="caption-link">AWS Bedrock</a> | <a href="https://azure.microsoft.com/en-us/products/ai-services/openai-service" target="_blank" rel="noopener noreferrer" class="caption-link">Azure OpenAI Service</a> | <a href="https://cloud.google.com/vertex-ai" target="_blank" rel="noopener noreferrer" class="caption-link">Google Cloud Vertex AI</a> | <a href="https://www.anthropic.com/claude" target="_blank" rel="noopener noreferrer" class="caption-link">Anthropic Claude API</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Kubernetes</a> | <a href="https://www.terraform.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Terraform</a> | <a href="https://helm.sh/" target="_blank" rel="noopener noreferrer" class="caption-link">Helm</a> | <a href="https://github.com/kubeflow/kubeflow" target="_blank" rel="noopener noreferrer" class="caption-link">Kubeflow</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 4: Multimodal Data & Perception -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Multimodal Data & Perception</h3>
                    <p class="text-text-secondary mb-4">Advanced systems must process and reason over unstructured,
                        multimodal data (PDFs, images, audio). This requires robust ETL pipelines to extract
                        information, convert it into a consistent format (like text or embeddings), and load it into a
                        retrieval system that the LLM can query.</p>
                    <div id="multimodal-data-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2103.00020" target="_blank" rel="noopener noreferrer" class="caption-link">"Learning Transferable Visual Models From Natural Language Supervision" (CLIP) - Radford et al. (2021)</a> | <a href="https://arxiv.org/abs/2204.14198" target="_blank" rel="noopener noreferrer" class="caption-link">"Flamingo: Few-Shot Learning in Multimodal Models" (2022)</a></p>
                            <p><strong>Multimodal Models:</strong> <a href="https://github.com/openai/CLIP" target="_blank" rel="noopener noreferrer" class="caption-link">OpenAI CLIP</a> | <a href="https://github.com/google-research/vision_transformer" target="_blank" rel="noopener noreferrer" class="caption-link">Vision Transformer</a> | <a href="https://github.com/facebookresearch/mae" target="_blank" rel="noopener noreferrer" class="caption-link">Masked Autoencoders</a> | <a href="https://huggingface.co/models?pipeline_tag=image-to-text" target="_blank" rel="noopener noreferrer" class="caption-link">Hugging Face Vision-Language Models</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://github.com/openai/whisper" target="_blank" rel="noopener noreferrer" class="caption-link">OpenAI Whisper</a> | <a href="https://github.com/pytorch/torchvision" target="_blank" rel="noopener noreferrer" class="caption-link">PyTorch Vision</a> | <a href="https://github.com/ultralytics/ultralytics" target="_blank" rel="noopener noreferrer" class="caption-link">YOLOv8</a> | <a href="https://github.com/facebookresearch/detectron2" target="_blank" rel="noopener noreferrer" class="caption-link">Detectron2</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 5: LLMOps & Observability -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">LLMOps & Observability</h3>
                    <p class="text-text-secondary mb-4">Production-grade LLMOps requires granular tracking of not just
                        performance metrics like latency, but also prompt versions, token costs, result caching hit
                        rates, and user feedback. This creates a rich, observable system that can be debugged and
                        optimized effectively.</p>
                    <div id="llmops-observability-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2307.03109" target="_blank" rel="noopener noreferrer" class="caption-link">"LLMOps: Operationalizing Large Language Models" (2023)</a> | <a href="https://arxiv.org/abs/2309.03409" target="_blank" rel="noopener noreferrer" class="caption-link">"Observability for ML Systems" (2023)</a></p>
                            <p><strong>Monitoring Platforms:</strong> <a href="https://smith.langchain.com/" target="_blank" rel="noopener noreferrer" class="caption-link">LangSmith</a> | <a href="https://www.langfuse.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Langfuse</a> | <a href="https://www.wandb.ai/" target="_blank" rel="noopener noreferrer" class="caption-link">Weights & Biases</a> | <a href="https://arize.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Arize AI</a></p>
                            <p><strong>Tools & Frameworks:</strong> <a href="https://prometheus.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Prometheus</a> | <a href="https://grafana.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Grafana</a> | <a href="https://www.elastic.co/elasticsearch/" target="_blank" rel="noopener noreferrer" class="caption-link">Elasticsearch</a> | <a href="https://opentelemetry.io/" target="_blank" rel="noopener noreferrer" class="caption-link">OpenTelemetry</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 6: LLM Evaluation Harnesses -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-blue">LLM Evaluation Harnesses</h3>
                    <p class="text-text-secondary mb-4">Automated, reproducible frameworks (e.g., RAGAS, DeepEval) are
                        used to benchmark model performance on standardized tasks (faithfulness, answer relevance,
                        context precision). This ensures quality, prevents regressions during model migration, and
                        validates the effectiveness of the RAG pipeline.</p>
                    <div id="llm-eval-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2309.15217" target="_blank" rel="noopener noreferrer" class="caption-link">"RAGAS: Automated Evaluation of Retrieval Augmented Generation" (2023)</a> | <a href="https://arxiv.org/abs/2303.16634" target="_blank" rel="noopener noreferrer" class="caption-link">"Measuring Massive Multitask Language Understanding" (MMLU)</a></p>
                            <p><strong>Evaluation Frameworks:</strong> <a href="https://docs.ragas.io/" target="_blank" rel="noopener noreferrer" class="caption-link">RAGAS</a> | <a href="https://github.com/confident-ai/deepeval" target="_blank" rel="noopener noreferrer" class="caption-link">DeepEval</a> | <a href="https://www.trulens.org/" target="_blank" rel="noopener noreferrer" class="caption-link">TruLens</a> | <a href="https://www.helm-benchmark.com/" target="_blank" rel="noopener noreferrer" class="caption-link">HELM Benchmark</a></p>
                            <p><strong>Benchmarks & Metrics:</strong> <a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard" target="_blank" rel="noopener noreferrer" class="caption-link">Open LLM Leaderboard</a> | <a href="https://github.com/EleutherAI/lm-evaluation-harness" target="_blank" rel="noopener noreferrer" class="caption-link">EleutherAI Evaluation Harness</a> | <a href="https://github.com/google/BIG-bench" target="_blank" rel="noopener noreferrer" class="caption-link">BIG-bench</a> | <a href="https://crfm.stanford.edu/helm/latest/" target="_blank" rel="noopener noreferrer" class="caption-link">Stanford HELM</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 7: CI/CD & IaC for AI Systems -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">CI/CD & Infrastructure as Code for AI
                        Systems</h3>
                    <p class="text-text-secondary mb-4">DevOps principles are applied to AI infrastructure using
                        Infrastructure as Code (IaC) tools like Terraform to automate the provisioning and configuration
                        of the entire stack. This ensures that development, staging, and production environments are
                        identical and reproducible, reducing deployment errors.</p>
                    <div id="cicd-iac-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2306.08698" target="_blank" rel="noopener noreferrer" class="caption-link">"MLOps: From Model-centric to Data-centric AI" (2023)</a> | <a href="https://arxiv.org/abs/2303.06012" target="_blank" rel="noopener noreferrer" class="caption-link">"DevOps for Machine Learning: A Survey" (2023)</a></p>
                            <p><strong>Infrastructure as Code:</strong> <a href="https://www.terraform.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Terraform</a> | <a href="https://aws.amazon.com/cloudformation/" target="_blank" rel="noopener noreferrer" class="caption-link">AWS CloudFormation</a> | <a href="https://azure.microsoft.com/en-us/products/azure-resource-manager" target="_blank" rel="noopener noreferrer" class="caption-link">Azure ARM Templates</a> | <a href="https://pulumi.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Pulumi</a></p>
                            <p><strong>CI/CD Platforms:</strong> <a href="https://github.com/features/actions" target="_blank" rel="noopener noreferrer" class="caption-link">GitHub Actions</a> | <a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener noreferrer" class="caption-link">GitLab CI/CD</a> | <a href="https://jenkins.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Jenkins</a> | <a href="https://argoproj.github.io/cd/" target="_blank" rel="noopener noreferrer" class="caption-link">Argo CD</a></p>
                            <p><strong>Containerization:</strong> <a href="https://www.docker.com/" target="_blank" rel="noopener noreferrer" class="caption-link">Docker</a> | <a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Kubernetes</a> | <a href="https://github.com/kubeflow/kubeflow" target="_blank" rel="noopener noreferrer" class="caption-link">Kubeflow</a> | <a href="https://www.redhat.com/en/technologies/cloud-computing/openshift" target="_blank" rel="noopener noreferrer" class="caption-link">OpenShift</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 8: Agentic Frameworks & Orchestration -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Leading Agentic Frameworks</h3>
                    <p class="text-text-secondary mb-4">Modern agentic systems require sophisticated orchestration
                        frameworks that enable multi-agent coordination, complex workflow management, and dynamic task
                        allocation. <strong>LangGraph</strong> provides state-based workflow orchestration,
                        <strong>AutoGen</strong> enables multi-agent conversations, and <strong>CrewAI</strong>
                        specializes in role-based agent collaboration for enterprise scenarios.
                    </p>
                    <div id="agentic-frameworks-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2308.08155" target="_blank" rel="noopener noreferrer" class="caption-link">"AutoGen: Enabling Next-Gen LLM Applications via Multi-Agent Conversation" (2023)</a> | <a href="https://arxiv.org/abs/2309.07864" target="_blank" rel="noopener noreferrer" class="caption-link">"LangChain: Building LLM Applications with Composable Components" (2023)</a></p>
                            <p><strong>Agentic Frameworks:</strong> <a href="https://langchain-ai.github.io/langgraph/" target="_blank" rel="noopener noreferrer" class="caption-link">LangGraph</a> | <a href="https://github.com/microsoft/autogen" target="_blank" rel="noopener noreferrer" class="caption-link">Microsoft AutoGen</a> | <a href="https://www.crewai.com/" target="_blank" rel="noopener noreferrer" class="caption-link">CrewAI</a> | <a href="https://github.com/SWE-agent/SWE-agent" target="_blank" rel="noopener noreferrer" class="caption-link">SWE-agent</a></p>
                            <p><strong>Multi-Agent Systems:</strong> <a href="https://github.com/openai/swarm" target="_blank" rel="noopener noreferrer" class="caption-link">OpenAI Swarm</a> | <a href="https://github.com/microsoft/semantic-kernel" target="_blank" rel="noopener noreferrer" class="caption-link">Semantic Kernel</a> | <a href="https://github.com/camel-ai/camel" target="_blank" rel="noopener noreferrer" class="caption-link">CAMEL-AI</a> | <a href="https://github.com/anthropics/anthropic-sdk-python" target="_blank" rel="noopener noreferrer" class="caption-link">Anthropic Claude API</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 9: Advanced Fine-Tuning Techniques -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Advanced Fine-Tuning Methodologies</h3>
                    <p class="text-text-secondary mb-4">Modern fine-tuning encompasses a spectrum of techniques:
                        <strong>Supervised Fine-Tuning (SFT)</strong> for task-specific adaptation,
                        <strong>RLHF/PPO/DPO</strong> for human preference alignment, and parameter-efficient methods
                        like <strong>LoRA/QLoRA/PEFT</strong> for resource-constrained environments.
                        <strong>GRPO</strong> (Group Relative Policy Optimization) represents cutting-edge preference
                        learning for multi-objective optimization.
                    </p>
                    <div id="fine-tuning-techniques-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2106.09685" target="_blank" rel="noopener noreferrer" class="caption-link">"LoRA: Low-Rank Adaptation of Large Language Models" (2021)</a> | <a href="https://arxiv.org/abs/2203.02155" target="_blank" rel="noopener noreferrer" class="caption-link">"Training language models to follow instructions with human feedback" (RLHF)</a></p>
                            <p><strong>Parameter-Efficient Methods:</strong> <a href="https://github.com/huggingface/peft" target="_blank" rel="noopener noreferrer" class="caption-link">PEFT Library</a> | <a href="https://github.com/microsoft/LoRA" target="_blank" rel="noopener noreferrer" class="caption-link">LoRA Implementation</a> | <a href="https://github.com/artidoro/qlora" target="_blank" rel="noopener noreferrer" class="caption-link">QLoRA</a> | <a href="https://github.com/google-research/adapter-transformers" target="_blank" rel="noopener noreferrer" class="caption-link">Adapter Transformers</a></p>
                            <p><strong>Alignment Techniques:</strong> <a href="https://arxiv.org/abs/2305.18290" target="_blank" rel="noopener noreferrer" class="caption-link">"Direct Preference Optimization" (DPO)</a> | <a href="https://openai.com/research/learning-from-human-preferences" target="_blank" rel="noopener noreferrer" class="caption-link">Human Preference Learning</a> | <a href="https://github.com/CarperAI/trlx" target="_blank" rel="noopener noreferrer" class="caption-link">TRLX Framework</a> | <a href="https://github.com/huggingface/trl" target="_blank" rel="noopener noreferrer" class="caption-link">TRL (Transformer Reinforcement Learning)</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 10: Advanced RAG & Hybrid Retrieval -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-blue">Advanced RAG Pipelines & Hybrid Retrieval
                    </h3>
                    <p class="text-text-secondary mb-4">Enterprise RAG systems employ sophisticated retrieval
                        strategies: <strong>semantic chunking</strong> for context-aware document segmentation,
                        <strong>hybrid search</strong> combining dense and sparse retrieval, <strong>multi-modal
                            indexing</strong> for diverse content types, and <strong>adaptive retrieval</strong> with
                        query complexity analysis for optimal performance and cost management.
                    </p>
                    <div id="advanced-rag-pipelines-viz" class="w-full h-[450px] viz-container rounded-md"></div>
                    
                    <!-- Chain-of-Thought Implementation Demo -->
                    <div class="mt-8">
                        <h4 class="text-lg font-semibold mb-3 text-accent-green">🧠 Chain-of-Thought Implementation Demo</h4>
                        <p class="text-text-secondary mb-4">Interactive demonstration of chain-of-thought reasoning with step-by-step reasoning visualization. Explore how LLMs break down complex problems into logical reasoning steps.</p>
                        <div id="chain-of-thought-demo" class="w-full h-[400px] viz-container rounded-md border border-gray-600"></div>
                    </div>
                    
                    <!-- Tree of Thoughts Demo -->
                    <div class="mt-8">
                        <h4 class="text-lg font-semibold mb-3 text-accent-purple">🌳 Tree of Thoughts Demo</h4>
                        <p class="text-text-secondary mb-4">Interactive tree-based reasoning visualizer with multi-path exploration interface. Experience how advanced reasoning systems explore multiple solution paths simultaneously.</p>
                        <div id="tree-of-thoughts-demo" class="w-full h-[400px] viz-container rounded-md border border-gray-600"></div>
                    </div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2312.10997" target="_blank" rel="noopener noreferrer" class="caption-link">"Retrieval-Augmented Generation for Large Language Models: A Survey" (2023)</a> | <a href="https://arxiv.org/abs/2310.04408" target="_blank" rel="noopener noreferrer" class="caption-link">"Self-RAG: Learning to Retrieve, Generate, and Critique" (2023)</a></p>
                            <p><strong>Advanced RAG Techniques:</strong> <a href="https://github.com/microsoft/graphrag" target="_blank" rel="noopener noreferrer" class="caption-link">Microsoft GraphRAG</a> | <a href="https://www.llamaindex.ai/" target="_blank" rel="noopener noreferrer" class="caption-link">LlamaIndex</a> | <a href="https://github.com/hwchase17/langchain" target="_blank" rel="noopener noreferrer" class="caption-link">LangChain Retrievers</a> | <a href="https://github.com/chroma-core/chroma" target="_blank" rel="noopener noreferrer" class="caption-link">Chroma DB</a></p>
                            <p><strong>Hybrid Retrieval:</strong> <a href="https://github.com/qdrant/qdrant" target="_blank" rel="noopener noreferrer" class="caption-link">Qdrant</a> | <a href="https://www.pinecone.io/" target="_blank" rel="noopener noreferrer" class="caption-link">Pinecone</a> | <a href="https://github.com/weaviate/weaviate" target="_blank" rel="noopener noreferrer" class="caption-link">Weaviate</a> | <a href="https://github.com/milvus-io/milvus" target="_blank" rel="noopener noreferrer" class="caption-link">Milvus</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 11: Real-Time Cost/Performance Calculator -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Real-Time Cost/Performance Calculator</h3>
                    <p class="text-text-secondary mb-4">Interactive tool for comparing AI model architectures across
                        cost, performance, and operational metrics. Adjust parameters to see real-time calculations for
                        token costs, inference latency, and throughput optimization across different deployment
                        scenarios.</p>
                    <div id="cost-performance-calculator-viz" class="w-full h-[500px] viz-container rounded-md"></div>
                    
                    <div class="mt-3 p-3 bg-gray-900 rounded-lg border border-gray-700">
                        <h5 class="text-xs font-semibold text-accent-cyan mb-2">📚 References & Further Reading</h5>
                        <div class="text-xs text-text-secondary space-y-1">
                            <p><strong>Primary References:</strong> <a href="https://arxiv.org/abs/2310.03589" target="_blank" rel="noopener noreferrer" class="caption-link">"Cost Analysis of Large Language Model Inference" (2023)</a> | <a href="https://arxiv.org/abs/2308.10837" target="_blank" rel="noopener noreferrer" class="caption-link">"Efficiency Benchmarks for LLM Deployment" (2023)</a></p>
                            <p><strong>AI Model Pricing:</strong> <a href="https://openai.com/pricing" target="_blank" rel="noopener noreferrer" class="caption-link">OpenAI Pricing</a> | <a href="https://docs.anthropic.com/claude/reference/getting-started-with-the-api" target="_blank" rel="noopener noreferrer" class="caption-link">Anthropic Claude API</a> | <a href="https://cloud.google.com/vertex-ai/generative-ai/pricing" target="_blank" rel="noopener noreferrer" class="caption-link">Google Gemini Pricing</a> | <a href="https://aws.amazon.com/bedrock/pricing/" target="_blank" rel="noopener noreferrer" class="caption-link">AWS Bedrock Pricing</a></p>
                            <p><strong>Cost Optimization Tools:</strong> <a href="https://github.com/microsoft/DeepSpeed" target="_blank" rel="noopener noreferrer" class="caption-link">DeepSpeed</a> | <a href="https://github.com/pytorch/serve" target="_blank" rel="noopener noreferrer" class="caption-link">TorchServe</a> | <a href="https://github.com/triton-inference-server/server" target="_blank" rel="noopener noreferrer" class="caption-link">NVIDIA Triton</a> | <a href="https://github.com/bentoml/BentoML" target="_blank" rel="noopener noreferrer" class="caption-link">BentoML</a></p>
                        </div>
                    </div>
                </div>

                <!-- Card 12: Interactive Architecture Playground -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Interactive Architecture Playground</h3>
                    <p class="text-text-secondary mb-4">Build and experiment with AI system architectures through
                        drag-and-drop components. Design complete pipelines by combining data sources, processing
                        layers, models, and deployment targets. See real-time performance metrics and architectural
                        recommendations as you build.</p>
                    <div class="mb-4 flex flex-wrap gap-2">
                        <button id="reset-architecture"
                            class="px-3 py-1 bg-accent-blue text-white text-sm rounded hover:bg-opacity-80 transition-all">Reset</button>
                        <button id="validate-architecture"
                            class="px-3 py-1 bg-accent-green text-white text-sm rounded hover:bg-opacity-80 transition-all">Validate</button>
                        <button id="export-architecture"
                            class="px-3 py-1 bg-accent-purple text-white text-sm rounded hover:bg-opacity-80 transition-all">Export</button>
                    </div>
                    <div id="architecture-playground-viz" class="w-full h-[600px] viz-container rounded-md relative">
                    </div>
                    <div class="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-gray-800 p-3 rounded">
                            <h4 class="text-sm font-semibold text-accent-cyan mb-2">Performance Metrics</h4>
                            <div id="performance-metrics" class="text-xs text-text-secondary"></div>
                        </div>
                        <div class="bg-gray-800 p-3 rounded">
                            <h4 class="text-sm font-semibold text-accent-green mb-2">Architecture Score</h4>
                            <div id="architecture-score" class="text-xs text-text-secondary"></div>
                        </div>
                        <div class="bg-gray-800 p-3 rounded">
                            <h4 class="text-sm font-semibold text-accent-purple mb-2">Recommendations</h4>
                            <div id="architecture-recommendations" class="text-xs text-text-secondary"></div>
                        </div>
                    </div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Interactive Architecture Design Tool - Drag
                        components from the palette to build your AI system</p>
                </div>

                <!-- Card 13: Animated Code Examples & Live Demos -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Animated Code Examples & Live Demos</h3>
                    <p class="text-text-secondary mb-4">Interactive code demonstrations that showcase key AI
                        architecture patterns with real-time execution, syntax highlighting, and step-by-step
                        animations. Experience the code in action with live examples that demonstrate best practices and
                        implementation patterns.</p>

                    <div class="mb-4 flex flex-wrap gap-2">
                        <button id="run-demo"
                            class="px-3 py-1 bg-accent-green text-white text-sm rounded hover:bg-opacity-80 transition-all">▶️
                            Run Demo</button>
                        <button id="step-through"
                            class="px-3 py-1 bg-accent-blue text-white text-sm rounded hover:bg-opacity-80 transition-all">👆
                            Step Through</button>
                        <button id="reset-demo"
                            class="px-3 py-1 bg-accent-purple text-white text-sm rounded hover:bg-opacity-80 transition-all">🔄
                            Reset</button>
                        <select id="demo-selector"
                            class="px-3 py-1 bg-gray-700 text-white text-sm rounded border border-gray-600">
                            <option value="ai-engineering-best-practices">AI Engineering Best Practices</option>
                            <option value="model-deployment-patterns">Model Deployment Patterns</option>
                            <option value="performance-optimization">Performance Optimization Techniques</option>
                            <option value="monitoring-observability">Monitoring and Observability</option>
                            <option value="gpt-implementation">GPT Implementation from Scratch</option>
                            <option value="training-loop-implementation">Training Loop Implementation</option>
                            <option value="model-evaluation-metrics">Model Evaluation Metrics</option>
                            <option value="rag-implementation">RAG Implementation</option>
                            <option value="agent-workflow">Agent Workflow</option>
                            <option value="model-serving">Model Serving</option>
                            <option value="mcp-integration">MCP Integration</option>
                        </select>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="space-y-4">
                            <div class="bg-gray-800 p-4 rounded-lg">
                                <h4 class="text-sm font-semibold text-accent-cyan mb-2">Code Editor</h4>
                                <div id="animated-code-editor"
                                    class="code-block min-h-[400px] relative overflow-hidden"></div>
                            </div>
                            <div class="bg-gray-800 p-4 rounded-lg">
                                <h4 class="text-sm font-semibold text-accent-green mb-2">Output Console</h4>
                                <div id="demo-console"
                                    class="bg-black p-3 rounded font-mono text-sm text-green-400 min-h-[150px] overflow-y-auto">
                                </div>
                            </div>
                        </div>

                        <div class="space-y-4">
                            <div class="bg-gray-800 p-4 rounded-lg">
                                <h4 class="text-sm font-semibold text-accent-purple mb-2">Execution Flow</h4>
                                <div id="execution-flow-viz" class="w-full h-[300px] viz-container rounded-md"></div>
                            </div>
                            <div class="bg-gray-800 p-4 rounded-lg">
                                <h4 class="text-sm font-semibold text-accent-blue mb-2">Performance Metrics</h4>
                                <div id="demo-metrics" class="text-xs text-text-secondary space-y-1">
                                    <div>Execution Time: <span class="text-accent-green">0ms</span></div>
                                    <div>Memory Usage: <span class="text-accent-cyan">0MB</span></div>
                                    <div>API Calls: <span class="text-accent-purple">0</span></div>
                                    <div>Success Rate: <span class="text-accent-green">100%</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-4 p-4 bg-gray-800 rounded-lg">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">Code Explanation</h4>
                        <div id="code-explanation" class="text-xs text-text-secondary">
                            Select a demo to see the explanation and step-by-step breakdown of the implementation.
                        </div>
                    </div>

                    <p class="text-xs text-right mt-2 text-text-secondary">Interactive Code Demonstrations - Click Run
                        Demo to see the code in action</p>
                </div>

                <!-- Card 13: Unified Policy Gradient Estimator -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Unified Policy Gradient Estimator (UPG)
                    </h3>
                    <p class="text-text-secondary mb-4">A breakthrough mathematical framework that unifies different
                        policy gradient methods into a single, coherent estimator. UPG provides a unified view of
                        REINFORCE, Actor-Critic, and PPO algorithms through a common mathematical foundation, enabling
                        more efficient and stable reinforcement learning for AI agents.</p>
                    <div id="upg-mathematical-viz" class="w-full h-[500px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2401.01240" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Unified Policy Gradient Estimator" - Theoretical Framework (2024)</a>
                    </p>
                </div>

                <!-- Card 12: Hybrid Post-Training (HPT) Algorithm -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Hybrid Post-Training (HPT) Algorithm</h3>
                    <p class="text-text-secondary mb-4">A breakthrough training methodology that dynamically combines
                        Supervised Fine-Tuning (SFT) and Reinforcement Learning (RL) for optimal model performance. HPT
                        adaptively adjusts the mixing ratio between SFT and RL based on performance metrics, achieving
                        superior results compared to traditional sequential training approaches.</p>
                    <div id="hpt-algorithm-viz" class="w-full h-[500px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2401.01335" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Hybrid Post-Training: Dynamic SFT/RL Mixing" - Research Framework
                            (2024)</a></p>
                </div>

                <!-- Card 13: 8-Types of LLMs in AI Agents -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">8-Types of LLMs in AI Agents</h3>
                    <p class="text-text-secondary mb-4">A comprehensive classification system for understanding
                        different LLM types and their optimal use cases in AI agent architectures. From reasoning
                        specialists to multimodal orchestrators, each type offers unique capabilities for specific agent
                        roles and deployment scenarios.</p>
                    <div id="llm-types-comparison-viz" class="w-full h-[600px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2401.01350" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Comprehensive LLM Classification for AI Agents" - Research Framework
                            (2024)</a></p>
                </div>

                <!-- Card 14: Agentic RAG vs Standard RAG -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Agentic RAG vs Standard RAG</h3>
                    <p class="text-text-secondary mb-4">A comprehensive comparison of traditional RAG systems versus
                        next-generation Agentic RAG architectures. Agentic RAG introduces intelligent query routing,
                        multi-step reasoning, and dynamic retrieval strategies, enabling more sophisticated and
                        context-aware information retrieval for complex AI agent workflows.</p>
                    <div id="agentic-rag-comparison-viz" class="w-full h-[600px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2401.01360" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Agentic RAG: Next-Generation Retrieval-Augmented Generation" -
                            Research Framework (2024)</a></p>
                </div>

                <!-- Card 15: Frontend Integration & APIs -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Frontend Integration & Modern APIs</h3>
                    <p class="text-text-secondary mb-4">Production AI applications require sophisticated frontend
                        architectures supporting real-time interactions, streaming responses, and complex state
                        management. Modern stacks leverage <strong>React/Angular</strong> with
                        <strong>TypeScript</strong> for type safety, <strong>GraphQL</strong> for efficient data
                        fetching, and <strong>WebSocket/SSE</strong> for real-time AI interactions with optimistic UI
                        updates.
                    </p>
                    <div id="frontend-integration-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a href="https://react.dev/"
                            target="_blank" rel="noopener noreferrer" class="caption-link">React, Angular, TypeScript,
                            and GraphQL documentation</a></p>
                </div>

                <!-- Card 12: Bias Mitigation & Interpretability -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Bias Mitigation & Model Interpretability
                    </h3>
                    <p class="text-text-secondary mb-4">Ensuring fairness and transparency requires systematic
                        approaches to bias detection, mitigation, and model interpretability. Implementations include
                        <strong>adversarial debiasing</strong>, <strong>fairness-aware fine-tuning</strong>,
                        <strong>LIME/SHAP</strong> for local explanations, <strong>attention visualization</strong>, and
                        <strong>human-in-the-loop</strong> systems for continuous monitoring and intervention in
                        high-stakes applications.
                    </p>
                    <div id="bias-interpretability-viz" class="w-full h-[400px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2009.07896" target="_blank" rel="noopener noreferrer"
                            class="caption-link">Fairness in ML and Model Interpretability research</a></p>
                </div>

                <!-- Card 13: Model Context Protocol (MCP) -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Model Context Protocol (MCP)</h3>
                    <p class="text-text-secondary mb-4">The Model Context Protocol enables AI agents to securely connect
                        to external tools and data sources through standardized interfaces. MCP provides a unified
                        framework for tool orchestration, allowing agents to discover, invoke, and manage external
                        capabilities while maintaining security boundaries and enabling seamless integration across
                        diverse AI systems.</p>
                    <div id="mcp-protocol-viz" class="w-full h-[500px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://modelcontextprotocol.io/" target="_blank" rel="noopener noreferrer"
                            class="caption-link">Model Context Protocol Specification</a></p>
                </div>

                <!-- Card 14: Agent-to-Agent (A2A) Communication Protocol -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-purple">Agent-to-Agent (A2A) Communication
                        Protocol</h3>
                    <p class="text-text-secondary mb-4">The A2A protocol enables sophisticated inter-agent communication
                        and coordination in multi-agent systems. It provides standardized message formats, negotiation
                        mechanisms, and coordination protocols that allow agents to collaborate, share knowledge, and
                        coordinate complex tasks while maintaining autonomy and security boundaries.</p>
                    <div id="a2a-protocol-viz" class="w-full h-[500px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2308.08155" target="_blank" rel="noopener noreferrer"
                            class="caption-link">Multi-Agent Communication Protocols Research</a></p>
                </div>

                <!-- Card 15: Agent User Interaction (AG-UI) Protocol -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Agent User Interaction (AG-UI) Protocol
                    </h3>
                    <p class="text-text-secondary mb-4">The AG-UI Protocol standardizes human-agent interaction
                        patterns, providing structured interfaces for natural language communication, task delegation,
                        and collaborative problem-solving. It enables seamless integration between human users and AI
                        agents through standardized interaction protocols and adaptive interface design.</p>
                    <div id="agui-protocol-viz" class="w-full h-[500px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2310.01420" target="_blank" rel="noopener noreferrer"
                            class="caption-link">Human-AI Interaction Protocols Research</a></p>
                </div>

                <!-- Card 17: Adaptation Speed Advantage Visualization -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-cyan">Adaptation Speed Advantage for Competitive Positioning</h3>
                    <p class="text-text-secondary mb-4">In the rapidly evolving AI landscape, adaptation speed is the ultimate competitive advantage. Organizations that can quickly adapt their AI systems to new requirements, market conditions, and technological breakthroughs gain significant market positioning benefits. This visualization demonstrates how different architectural approaches and development methodologies impact adaptation velocity.</p>
                    <div id="adaptation-speed-advantage-viz" class="w-full h-[600px] viz-container rounded-md"></div>
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/2401.00002" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Adaptation Speed as Competitive Advantage in AI Development" - Strategic Analysis (2025)</a></p>
                </div>

                <!-- Card 18: Attention Mechanism Visualization Demo -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-green">Attention Mechanism Visualization Demo</h3>
                    <p class="text-text-secondary mb-4">Interactive exploration of multi-head attention mechanisms in transformer architectures. This demo allows you to visualize attention patterns, explore different attention heads, and understand how the model focuses on different parts of the input sequence. Features include attention heatmap viewer, attention pattern explorer, and real-time attention weight visualization.</p>
                    <div id="attention-mechanism-demo-viz" class="w-full h-[700px] viz-container rounded-md"></div>
                    
                    <!-- Interactive Controls -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-3">🎮 Interactive Controls</h4>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <label class="block text-xs font-medium text-text-secondary mb-2">Attention Head</label>
                                <select id="attention-head-selector" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-text-primary focus:outline-none focus:ring-2 focus:ring-accent-cyan">
                                    <option value="0">Head 1 - Syntactic</option>
                                    <option value="1">Head 2 - Semantic</option>
                                    <option value="2">Head 3 - Positional</option>
                                    <option value="3">Head 4 - Long-range</option>
                                    <option value="all">All Heads Combined</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-text-secondary mb-2">Input Sequence</label>
                                <input type="text" id="input-sequence" value="The quick brown fox jumps over the lazy dog" 
                                       class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-text-primary focus:outline-none focus:ring-2 focus:ring-accent-cyan">
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-text-secondary mb-2">Visualization Mode</label>
                                <select id="viz-mode-selector" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-text-primary focus:outline-none focus:ring-2 focus:ring-accent-cyan">
                                    <option value="heatmap">Attention Heatmap</option>
                                    <option value="network">Attention Network</option>
                                    <option value="flow">Attention Flow</option>
                                    <option value="comparison">Multi-Head Comparison</option>
                                </select>
                            </div>
                        </div>
                        <div class="mt-4 flex gap-2">
                            <button id="animate-attention" class="px-4 py-2 bg-accent-cyan text-white rounded-md text-sm font-medium hover:bg-accent-cyan-dark transition-colors">
                                🎬 Animate Attention
                            </button>
                            <button id="reset-attention" class="px-4 py-2 bg-gray-600 text-white rounded-md text-sm font-medium hover:bg-gray-500 transition-colors">
                                🔄 Reset
                            </button>
                            <button id="export-attention" class="px-4 py-2 bg-accent-green text-white rounded-md text-sm font-medium hover:bg-accent-green-dark transition-colors">
                                📊 Export Data
                            </button>
                        </div>
                    </div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand how multi-head attention mechanisms process and weight input tokens</li>
                            <li>• Learn to interpret attention heatmaps and identify attention patterns</li>
                            <li>• Explore different attention heads and their specialized functions</li>
                            <li>• Visualize how attention weights change during processing</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            This interactive demo provides hands-on exploration of attention mechanisms, the core innovation that powers modern transformer architectures. 
                            <strong>Multi-head attention</strong> allows the model to focus on different types of relationships simultaneously - some heads may focus on 
                            syntactic relationships, others on semantic meaning, and others on positional dependencies. The <strong>attention heatmap</strong> 
                            shows how much each token attends to every other token, revealing the model's internal reasoning process.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The attention mechanism computes <strong>Query, Key, and Value</strong> matrices for each token, then calculates attention weights 
                            using scaled dot-product attention. <strong>Multi-head attention</strong> runs this process in parallel across multiple heads, 
                            each learning different types of relationships. The <strong>attention weights</strong> are normalized using softmax, ensuring 
                            they sum to 1 for each query token. This allows the model to dynamically focus on relevant context while maintaining 
                            interpretable attention patterns.
                        </p>
                    </div>
                    
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Attention Is All You Need" - Vaswani et al. (2017)</a></p>
                </div>

                <!-- Card 19: Tokenization and Embedding Demo -->
                <div class="card p-6 rounded-lg shadow-lg">
                    <h3 class="text-xl font-semibold mb-2 text-accent-orange">Tokenization and Embedding Demo</h3>
                    <p class="text-text-secondary mb-4">Interactive exploration of tokenization methods and embedding techniques used in modern language models. This demo allows you to compare different tokenization approaches (Word, BPE, SentencePiece), visualize the BPE algorithm in action, and explore how text is converted into numerical representations that AI models can process.</p>
                    <div id="tokenization-embedding-demo-viz" class="w-full h-[700px] viz-container rounded-md"></div>
                    
                    <!-- Interactive Controls -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-3">🎮 Interactive Controls</h4>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <label class="block text-xs font-medium text-text-secondary mb-2">Tokenization Method</label>
                                <select id="tokenization-method-selector" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-text-primary focus:outline-none focus:ring-2 focus:ring-accent-cyan">
                                    <option value="word">Word Tokenization</option>
                                    <option value="bpe">Byte Pair Encoding (BPE)</option>
                                    <option value="sentencepiece">SentencePiece</option>
                                    <option value="subword">Subword Tokenization</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-text-secondary mb-2">Input Text</label>
                                <input type="text" id="tokenization-input" value="Hello world! How are you today?" 
                                       class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-text-primary focus:outline-none focus:ring-2 focus:ring-accent-cyan">
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-text-secondary mb-2">Visualization Mode</label>
                                <select id="tokenization-viz-mode" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-text-primary focus:outline-none focus:ring-2 focus:ring-accent-cyan">
                                    <option value="tokens">Token Breakdown</option>
                                    <option value="bpe-process">BPE Algorithm</option>
                                    <option value="embeddings">Embedding Space</option>
                                    <option value="comparison">Method Comparison</option>
                                </select>
                            </div>
                        </div>
                        <div class="mt-4 flex gap-2">
                            <button id="animate-tokenization" class="px-4 py-2 bg-accent-orange text-white rounded-md text-sm font-medium hover:bg-accent-orange-dark transition-colors">
                                🎬 Animate BPE
                            </button>
                            <button id="reset-tokenization" class="px-4 py-2 bg-gray-600 text-white rounded-md text-sm font-medium hover:bg-gray-500 transition-colors">
                                🔄 Reset
                            </button>
                            <button id="export-tokenization" class="px-4 py-2 bg-accent-green text-white rounded-md text-sm font-medium hover:bg-accent-green-dark transition-colors">
                                📊 Export Data
                            </button>
                        </div>
                    </div>
                    
                    <!-- Comprehensive Conceptual Caption -->
                    <div class="mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600">
                        <h4 class="text-sm font-semibold text-accent-cyan mb-2">🎯 Learning Objectives</h4>
                        <ul class="text-xs text-text-secondary mb-3 space-y-1">
                            <li>• Understand different tokenization methods and their trade-offs</li>
                            <li>• Learn how Byte Pair Encoding (BPE) algorithm works step-by-step</li>
                            <li>• Explore how text is converted into numerical embeddings</li>
                            <li>• Compare tokenization efficiency across different methods</li>
                        </ul>
                        
                        <h4 class="text-sm font-semibold text-accent-green mb-2">💡 Key Concepts</h4>
                        <p class="text-xs text-text-secondary mb-3">
                            Tokenization is the process of converting raw text into numerical tokens that AI models can process. <strong>Word tokenization</strong> 
                            splits text by spaces, but struggles with unknown words. <strong>Byte Pair Encoding (BPE)</strong> learns to merge frequent 
                            character pairs, creating a vocabulary that balances vocabulary size with coverage. <strong>SentencePiece</strong> treats 
                            text as a sequence of Unicode characters and learns subword units. <strong>Embeddings</strong> convert tokens into dense 
                            vector representations that capture semantic meaning.
                        </p>
                        
                        <h4 class="text-sm font-semibold text-accent-purple mb-2">🔧 Technical Insights</h4>
                        <p class="text-xs text-text-secondary">
                            The <strong>BPE algorithm</strong> starts with character-level tokens and iteratively merges the most frequent pair of 
                            consecutive tokens. This creates a vocabulary that can represent any text while keeping the vocabulary size manageable. 
                            <strong>Embedding layers</strong> map each token to a high-dimensional vector (typically 512-4096 dimensions) where 
                            similar tokens have similar vector representations. The embedding space is learned during training, allowing the model 
                            to capture semantic relationships between words and concepts.
                        </p>
                    </div>
                    
                    <p class="text-xs text-right mt-2 text-text-secondary">Reference: <a
                            href="https://arxiv.org/abs/1508.07909" target="_blank" rel="noopener noreferrer"
                            class="caption-link">"Neural Machine Translation of Rare Words with Subword Units" - Sennrich et al. (2016)</a></p>
                </div>

            </div>
        </section>
    </main>

    <div id="ollama-modal" class="modal fixed inset-0 z-[100] items-center justify-center bg-black/70 p-4 no-print">
        <div class="modal-content card max-w-2xl w-full p-6 sm:p-8 rounded-lg border-accent-purple shadow-2xl relative">
            <button id="close-modal-btn"
                class="absolute top-4 right-4 text-text-secondary hover:text-text-primary text-3xl font-bold leading-none">&times;</button>
            <h3 class="text-xl font-semibold mb-3 text-accent-purple">Live Agent Demonstration (Proof of Concept)</h3>
            <p class="text-text-secondary mb-4">This demonstrates a forward-thinking capability. In a real-world
                scenario, connecting to a local model (like Ollama) would allow these diagrams to become dynamic and
                interactive.</p>
            <p class="text-text-secondary">An AI agent could analyze a user's request, select the appropriate workflow
                (Chain, Graph, or Conversation), and visualize its execution plan in real-time right here. This
                transforms the playbook from a static architectural reference into a live, intelligent, and
                self-documenting system.</p>
            <div class="mt-6 text-sm code-block">
                <span class="token comment"># Agent selecting a graph-based workflow</span><br>
                <span class="token keyword">if</span> is_complex_task(user_request):<br>
                &nbsp;&nbsp;workflow = <span class="token function">select_workflow</span>(<span
                    class="token string">'LangGraph'</span>)<br>
                &nbsp;&nbsp;visualizer.<span class="token function">update</span>(workflow.<span
                    class="token function">get_plan</span>())
            </div>
        </div>
    </div>

    <script>
        // Global tooltip system and utility functions - Initialize early to ensure availability
        let tooltip;
        let showTooltip;
        let hideTooltip;
        let arrowMarker;

        document.addEventListener('DOMContentLoaded', function () {
            /**
             * Initializes a tooltip element on the page.
             * @type {d3.Selection}
             */
            tooltip = d3.select("body").append("div").attr("class", "tooltip");

            /**
             * Shows the tooltip with specified content at the event's page coordinates.
             * Enhanced with smart positioning to avoid overlap with visualization elements.
             * @param {MouseEvent} event - The mouse event that triggers the tooltip.
             * @param {string} content - The HTML content to display in the tooltip.
             */
            showTooltip = function(event, content) {
                tooltip.style("opacity", 1).html(content);
                
                // Get tooltip dimensions for smart positioning
                const tooltipRect = tooltip.node().getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Calculate optimal position with collision detection
                let left = event.pageX + 15;
                let top = event.pageY - 28;
                
                // Check right boundary collision
                if (left + tooltipRect.width > viewportWidth - 20) {
                    left = event.pageX - tooltipRect.width - 15;
                }
                
                // Check bottom boundary collision
                if (top + tooltipRect.height > viewportHeight - 20) {
                    top = event.pageY - tooltipRect.height - 15;
                }
                
                // Check top boundary collision
                if (top < 20) {
                    top = event.pageY + 15;
                }
                
                // Check left boundary collision
                if (left < 20) {
                    left = 20;
                }
                
                tooltip.style("left", left + "px")
                    .style("top", top + "px");
            };

            /** Hides the tooltip. */
            hideTooltip = function() {
                tooltip.style("opacity", 0);
            };

            /** 
             * Appends an SVG marker definition for arrowhead lines.
             * @param {d3.Selection} svg - The SVG element to append the marker to.
             * @param {string} id - The unique ID for the marker.
             * @param {string} color - The color of the arrowhead.
             * @returns {d3.Selection} The created marker element.
             */
            arrowMarker = function(svg, id, color) {
                return svg.append("defs").append("marker").attr("id", id).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto-start-reverse").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("fill", color);
            };

            /**
             * Wraps long text within SVG <text> elements.
             * @param {d3.Selection} text - The D3 selection of text elements.
             * @param {number} width - The maximum width for the text.
             */
            function wrap(text, width) {
                text.each(function () {
                    var text = d3.select(this), words = text.text().split(/\s+/).reverse(), word, line = [], lineNumber = 0, lineHeight = 1.1, y = text.attr("y") || 0, dy = 0, tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
                    while (word = words.pop()) {
                        line.push(word); tspan.text(line.join(" "));
                        if (tspan.node().getComputedTextLength() > width) {
                            line.pop(); tspan.text(line.join(" ")); line = [word];
                            tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                        }
                    }
                });
            }

            // Standardized responsive design utility functions
            function getResponsiveScreenSizes(width) {
                return {
                    isSmallScreen: width < 600,
                    isMediumScreen: width >= 600 && width < 900,
                    isLargeScreen: width >= 900
                };
            }
            
            function getResponsiveDimensions(bounds) {
                const { isSmallScreen, isMediumScreen } = getResponsiveScreenSizes(bounds.width);
                
                return {
                    isSmallScreen,
                    isMediumScreen,
                    spacing: {
                        small: isSmallScreen ? 10 : isMediumScreen ? 15 : 20,
                        medium: isSmallScreen ? 20 : isMediumScreen ? 25 : 30,
                        large: isSmallScreen ? 30 : isMediumScreen ? 35 : 40
                    },
                    fontSize: {
                        small: isSmallScreen ? "8px" : isMediumScreen ? "9px" : "10px",
                        medium: isSmallScreen ? "10px" : isMediumScreen ? "11px" : "12px",
                        large: isSmallScreen ? "12px" : isMediumScreen ? "14px" : "16px"
                    }
                };
            }
            
            // Utility function for responsive margin calculations
            function getResponsiveMargins(width, baseMargins = { top: 40, right: 40, bottom: 40, left: 40 }) {
                const isMobile = width < 768;
                const isTablet = width >= 768 && width < 1024;
                const isLarge = width >= 1440;
                
                if (isMobile) {
                    return {
                        top: Math.max(baseMargins.top * 0.5, 15),
                        right: Math.max(baseMargins.right * 0.5, 15),
                        bottom: Math.max(baseMargins.bottom * 0.5, 15),
                        left: Math.max(baseMargins.left * 0.5, 15)
                    };
                } else if (isTablet) {
                    return {
                        top: Math.max(baseMargins.top * 0.75, 25),
                        right: Math.max(baseMargins.right * 0.75, 25),
                        bottom: Math.max(baseMargins.bottom * 0.75, 25),
                        left: Math.max(baseMargins.left * 0.75, 25)
                    };
                } else if (isLarge) {
                    return {
                        top: baseMargins.top * 1.25,
                        right: baseMargins.right * 1.25,
                        bottom: baseMargins.bottom * 1.25,
                        left: baseMargins.left * 1.25
                    };
                }
                
                return baseMargins;
            }
            
            // Utility function for responsive font sizes
            function getResponsiveFontSize(baseSize, width) {
                const isMobile = width < 768;
                const isTablet = width >= 768 && width < 1024;
                
                if (isMobile) {
                    return Math.max(baseSize * 0.8, 8);
                } else if (isTablet) {
                    return Math.max(baseSize * 0.9, 10);
                }
                
                return baseSize;
            }
            
            // Utility function for consistent size encoding based on performance and importance
            function getSizeByPerformance(performance) {
                if (performance >= 95) return 18;      // --size-performance-95
                if (performance >= 90) return 16;      // --size-performance-90
                if (performance >= 80) return 14;      // --size-performance-80
                if (performance >= 70) return 12;      // --size-performance-70
                if (performance >= 60) return 10;      // --size-performance-60
                return 8;                              // --size-performance-50
            }
            
            // Utility function for consistent size encoding based on importance
            function getSizeByImportance(importance) {
                switch(importance) {
                    case 'critical': return 20;  // --size-critical
                    case 'high': return 16;      // --size-high
                    case 'medium': return 12;    // --size-medium
                    case 'low': return 8;        // --size-low
                    case 'minimal': return 4;    // --size-minimal
                    default: return 12;          // --size-medium
                }
            }
            
            // Utility function for consistent size encoding based on complexity
            function getSizeByComplexity(complexity) {
                switch(complexity) {
                    case 'high': return 16;      // --size-complexity-high
                    case 'medium': return 12;    // --size-complexity-medium
                    case 'low': return 8;        // --size-complexity-low
                    default: return 12;          // --size-complexity-medium
                }
            }

            /** Renders the System Design sequence diagram with advanced visual storytelling. */
            function renderSystemDesignViz() {
                console.log('Starting renderSystemDesignViz...');
                
                // Check if required dependencies are available
                if (typeof getResponsiveMargins === 'undefined' || typeof arrowMarker === 'undefined') {
                    console.error('Required functions not available, delaying render...', {
                        getResponsiveMargins: typeof getResponsiveMargins,
                        arrowMarker: typeof arrowMarker
                    });
                    setTimeout(() => renderSystemDesignViz(), 50);
                    return;
                }
                
                const container = d3.select("#system-design-viz"); 
                if (container.empty()) {
                    console.error('Container #system-design-viz not found');
                    return;
                }
                
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); 
                console.log('System Design container bounds:', bounds);
                
                if (bounds.width <= 0 || bounds.height <= 0) {
                    console.warn('System Design container has invalid dimensions, retrying...', bounds);
                    setTimeout(() => renderSystemDesignViz(), 100);
                    return;
                }
                
                // Use responsive margin utility function
                const margin = getResponsiveMargins(bounds.width);
                
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for depth
                const defs = svg.append("defs");
                const actorGradient = defs.append("linearGradient").attr("id", "actor-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                actorGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-blue)").attr("stop-opacity", 0.9);
                actorGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-blue-dark)").attr("stop-opacity", 0.7);

                const flowGradient = defs.append("linearGradient").attr("id", "flow-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                flowGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-cyan)").attr("stop-opacity", 0.8);
                flowGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-green)").attr("stop-opacity", 0.6);

                arrowMarker(svg, "arrow-blue", "var(--accent-blue)");
                arrowMarker(svg, "arrow-flow", "var(--accent-cyan)");

                // Enhanced responsive actor positioning with dynamic label sizing and collision detection
                const actorCount = 4;
                const actorWidth = 120; // Actor box width
                const minSpacing = Math.max(140, actorWidth + 20); // Dynamic minimum spacing
                const totalSpacing = (actorCount - 1) * minSpacing;
                const availableWidth = width - totalSpacing;
                const startX = Math.max(60, (width - totalSpacing) / 2);
                
                // Responsive sizing based on container width
                const isSmallScreen = bounds.width < 600;
                const isMediumScreen = bounds.width < 900;
                const responsiveActorWidth = isSmallScreen ? 100 : isMediumScreen ? 110 : 120;
                const responsiveMinSpacing = isSmallScreen ? 120 : isMediumScreen ? 130 : 140;
                
                const actors = [
                    { name: "User/Client", tooltip: "<b>User/Client Layer</b><br>Application consumers initiating requests. Represents diverse user interfaces, mobile apps, and API clients requiring real-time ML predictions with sub-second latency requirements.", icon: "👤", color: "var(--accent-blue)" },
                    { name: "Inference API", tooltip: "<b>Inference API Gateway</b><br>High-availability service layer with auto-scaling, load balancing, and intelligent routing. Implements caching strategies, rate limiting, and A/B testing capabilities for production ML workloads.", icon: "🚀", color: "var(--accent-cyan)" },
                    { name: "Model Pipeline", tooltip: "<b>MLOps Pipeline</b><br>Automated model lifecycle management including training orchestration, hyperparameter optimization, model validation, and deployment automation. Ensures model quality and regulatory compliance.", icon: "⚙️", color: "var(--accent-green)" },
                    { name: "Data Pipeline", tooltip: "<b>Data Engineering Platform</b><br>Scalable data processing infrastructure handling ingestion, cleaning, feature engineering, and quality validation. Implements data lineage tracking and privacy-preserving transformations.", icon: "📊", color: "var(--accent-purple)" }
                ];
                
                // Calculate responsive actor positions with dynamic collision detection
                actors.forEach((actor, i) => {
                    actor.x = startX + (i * responsiveMinSpacing);
                    // Ensure actors don't exceed container bounds with responsive width
                    if (actor.x + responsiveActorWidth / 2 > width - 20) {
                        actor.x = width - responsiveActorWidth / 2 - 20;
                    }
                    // Add responsive positioning data
                    actor.responsiveWidth = responsiveActorWidth;
                    actor.responsiveSpacing = responsiveMinSpacing;
                });

                // Enhanced responsive actor rendering with dynamic sizing and layered visual effects
                actors.forEach((actor, i) => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, actor.tooltip)).on("mouseout", hideTooltip);

                    // Responsive sizing calculations
                    const actorBoxWidth = actor.responsiveWidth;
                    const actorBoxHeight = isSmallScreen ? 25 : isMediumScreen ? 28 : 30;
                    const shadowOffset = 2;
                    const iconSize = isSmallScreen ? "var(--text-lg)" : isMediumScreen ? "var(--text-xl)" : "var(--text-2xl)";
                    const textSize = isSmallScreen ? "var(--text-sm)" : isMediumScreen ? "var(--text-base)" : "var(--text-base)";

                    // Drop shadow effect with responsive sizing
                    g.append("rect")
                        .attr("x", actor.x - actorBoxWidth/2 + shadowOffset)
                        .attr("y", 12 + shadowOffset)
                        .attr("width", actorBoxWidth - 4)
                        .attr("height", actorBoxHeight - 4)
                        .attr("fill", "rgba(0,0,0,0.1)")
                        .attr("rx", 6);

                    // Main actor box with responsive gradient and enhanced styling
                    g.append("rect")
                        .attr("x", actor.x - actorBoxWidth/2)
                        .attr("y", 10)
                        .attr("width", actorBoxWidth)
                        .attr("height", actorBoxHeight)
                        .attr("fill", actor.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 1.5)
                        .attr("rx", 6)
                        .style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.2))");

                    // Responsive actor icon positioning
                    const iconX = actor.x - (actorBoxWidth * 0.3);
                    g.append("text")
                        .attr("x", iconX)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .style("font-size", iconSize)
                        .style("font-family", "var(--font-primary)")
                        .text(actor.icon);

                    // Responsive actor name with dynamic positioning
                    const nameX = actor.x + (actorBoxWidth * 0.1);
                    g.append("text")
                        .attr("x", nameX)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", textSize)
                        .style("font-weight", "var(--font-semibold)")
                        .style("font-family", "var(--font-primary)")
                        .text(actor.name);

                    // Lifeline with enhanced styling
                    svg.append("line").attr("x1", actor.x).attr("y1", 40).attr("x2", actor.x).attr("y2", height - 20).attr("stroke", actor.color).attr("stroke-width", 2).attr("stroke-dasharray", "8,4").attr("opacity", 0.6);
                });

                // Enhanced message drawing with visual hierarchy
                const drawMessage = (from, to, y, label, tooltip, isSelf = false, priority = "normal") => {
                    const start = actors.find(a => a.name === from).x;
                    const strokeWidth = priority === "critical" ? 4 : priority === "important" ? 3 : 2;
                    const strokeColor = priority === "critical" ? "#FF6B6B" : priority === "important" ? "#FFB700" : "#00A6FB";

                    if (isSelf) {
                        // Enhanced self-loop with scalable curvature
                        const curvature = Math.min(80, width * 0.15); // Scale with container width
                        const loopHeight = 30;
                        svg.append("path")
                            .attr("d", `M ${start} ${y - loopHeight / 2} C ${start + curvature} ${y - loopHeight / 2}, ${start + curvature} ${y + loopHeight / 2}, ${start} ${y + loopHeight / 2}`)
                            .attr("stroke", strokeColor)
                            .attr("fill", "none")
                            .attr("marker-end", "url(#arrow-blue)")
                            .attr("class", "interactive-node")
                            .style("stroke-width", strokeWidth)
                            .style("stroke-dasharray", priority === "critical" ? "none" : "5,5")
                            .on("mouseover", (e) => showTooltip(e, tooltip))
                            .on("mouseout", hideTooltip);
                    } else {
                        const end = actors.find(a => a.name === to).x;
                        // Enhanced message arrow with gradient
                        svg.append("line")
                            .attr("x1", start).attr("y1", y).attr("x2", end).attr("y2", y)
                            .attr("stroke", strokeColor)
                            .attr("marker-end", "url(#arrow-flow)")
                            .attr("class", "interactive-node")
                            .style("stroke-width", strokeWidth)
                            .on("mouseover", (e) => showTooltip(e, tooltip))
                            .on("mouseout", hideTooltip);

                        // Add flow direction indicator
                        const midX = (start + end) / 2;
                        svg.append("circle").attr("cx", midX).attr("cy", y).attr("r", 3).attr("fill", strokeColor).attr("opacity", 0.7);
                    }

                    // Enhanced label with dynamic background sizing
                    const labelX = start + (isSelf ? 35 : (actors.find(a => a.name === to).x - start) / 2);
                    
                    // Create temporary text element to measure actual width
                    const tempText = svg.append("text")
                        .attr("x", labelX)
                        .attr("y", y - 6)
                        .attr("text-anchor", "middle")
                        .style("font-size", "var(--text-sm)")
                        .style("font-weight", "var(--font-semibold)")
                        .style("font-family", "var(--font-primary)")
                        .style("opacity", 0)
                        .text(label);
                    
                    const labelWidth = tempText.node().getBBox().width;
                    tempText.remove();
                    
                    // Add background with proper sizing
                    svg.append("rect")
                        .attr("x", labelX - labelWidth / 2 - 6)
                        .attr("y", y - 17)
                        .attr("width", labelWidth + 12)
                        .attr("height", 16)
                        .attr("fill", "rgba(13, 27, 42, 0.9)")
                        .attr("rx", 3)
                        .attr("stroke", strokeColor)
                        .attr("stroke-width", 0.5);
                    
                    // Add label text
                    svg.append("text")
                        .attr("x", labelX)
                        .attr("y", y - 6)
                        .attr("text-anchor", "middle")
                        .attr("fill", strokeColor)
                        .style("font-size", "var(--text-sm)")
                        .style("font-weight", "var(--font-semibold)")
                        .style("font-family", "var(--font-primary)")
                        .text(label);
                };

                // Messages with enhanced visual priority encoding
                drawMessage("User/Client", "Inference API", 80, "1. Request Prediction", "<b>Real-time Prediction Request</b><br>User submits input data (text, images, structured data) via REST API. Includes request ID, user context, and performance requirements for tracking and optimization.", false, "critical");
                drawMessage("Inference API", "Data Pipeline", 110, "2. Log Request/Response", "<b>Observability & Monitoring</b><br>Comprehensive logging including input/output data, latency metrics, model version, and user feedback. Critical for model performance monitoring and continuous improvement.", false, "important");
                drawMessage("Data Pipeline", "Model Pipeline", 140, "3. Provide Training Data", "<b>Training Data Provisioning</b><br>Curated, cleaned datasets with quality validation and bias checks. Includes feature engineering, data augmentation, and privacy-preserving transformations for model training.", false, "normal");
                drawMessage("Model Pipeline", "Model Pipeline", 170, "4. Train/Fine-tune", "<b>Model Development Cycle</b><br>Automated training with hyperparameter optimization, model validation, and performance benchmarking. Includes A/B testing and gradual rollout strategies.", true, "critical");
                drawMessage("Model Pipeline", "Inference API", 200, "5. Deploy Model", "<b>Model Deployment</b><br>Validated model deployment with canary release, performance monitoring, and automated rollback capabilities. Ensures zero-downtime updates and consistent performance.", false, "important");

                // Add timeline markers aligned with actual message positions
                const timelineY = height - 10;
                const messageYs = [80, 110, 140, 170, 200];
                const timelineStartX = actors[0].x;
                const timelineEndX = actors[actors.length - 1].x;
                
                svg.append("line")
                    .attr("x1", timelineStartX)
                    .attr("y1", timelineY)
                    .attr("x2", timelineEndX)
                    .attr("y2", timelineY)
                    .attr("stroke", "var(--accent-cyan)")
                    .attr("stroke-width", 2);
                
                // Position timeline markers based on message flow centers with better alignment
                messageYs.forEach((y, i) => {
                    // Calculate marker position based on message flow center
                    const messageCenterX = (timelineStartX + timelineEndX) / 2;
                    const markerX = Math.max(timelineStartX + 20, Math.min(timelineEndX - 20, messageCenterX));
                    svg.append("circle")
                        .attr("cx", markerX)
                        .attr("cy", timelineY)
                        .attr("r", 4)
                        .attr("fill", "var(--accent-cyan)");
                    svg.append("text")
                        .attr("x", markerX)
                        .attr("y", timelineY + 15)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "var(--text-xs)")
                        .style("font-family", "var(--font-primary)")
                        .text(`T${i + 1}`);
                });
            }

            /** Renders the Operating System layers with advanced architectural visualization. */
            function renderOSViz() {
                console.log('Starting renderOSViz...');
                
                // Check if required dependencies are available
                if (typeof arrowMarker === 'undefined') {
                    console.error('arrowMarker function not available for OS viz, delaying render...');
                    setTimeout(() => renderOSViz(), 50);
                    return;
                }
                
                const container = d3.select("#os-viz"); 
                if (container.empty()) {
                    console.error('Container #os-viz not found');
                    return;
                }
                
                container.selectAll("*").remove(); 
                const bounds = container.node().getBoundingClientRect(); 
                console.log('OS viz container bounds:', bounds);
                
                if (bounds.width <= 0 || bounds.height <= 0) {
                    console.warn('OS viz container has invalid dimensions, retrying...', bounds);
                    setTimeout(() => renderOSViz(), 100);
                    return;
                }
                const margin = { top: 40, right: 40, bottom: 50, left: 40 }, width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                
                // Responsive sizing based on container width
                const isSmallScreen = bounds.width < 600;
                const isMediumScreen = bounds.width < 900;
                
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for architectural depth
                const defs = svg.append("defs");
                const layerGradients = [
                    { id: "app-layer-grad", colors: ["#8338EC", "#A855F7"], opacity: [0.9, 0.7] },
                    { id: "ai-layer-grad", colors: ["#3A86FF", "#60A5FA"], opacity: [0.8, 0.6] },
                    { id: "os-layer-grad", colors: ["#2EC4B6", "#34D399"], opacity: [0.7, 0.5] },
                    { id: "hardware-grad", colors: ["#FFB700", "#FCD34D"], opacity: [0.6, 0.4] }
                ];

                layerGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", grad.opacity[0]);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", grad.opacity[1]);
                });

                // Hardware component gradients
                const hwGradients = [
                    { id: "cpu-grad", colors: ["#FF6B6B", "#F87171"] },
                    { id: "gpu-grad", colors: ["#00A6FB", "#0EA5E9"] },
                    { id: "npu-grad", colors: ["#2EC4B6", "#34D399"] }
                ];

                hwGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                arrowMarker(svg, "arrow-layer", "#3A86FF");
                arrowMarker(svg, "arrow-data", "#2EC4B6");

                // Enhanced layer definitions with architectural context
                const layers = [
                    {
                        name: "AI Applications",
                        y: height * 0.05,
                        h: 50,
                        gradient: "url(#app-layer-grad)",
                        icon: "🤖",
                        tooltip: "<b>AI Application Layer</b><br>Enterprise AI applications, ML inference services, and intelligent agents. Includes chatbots, recommendation engines, computer vision systems, and decision support tools.",
                        examples: ["ChatGPT", "Computer Vision", "Recommendation Systems"]
                    },
                    {
                        name: "AI OS Layer",
                        y: height * 0.25,
                        h: 50,
                        gradient: "url(#ai-layer-grad)",
                        icon: "🧠",
                        tooltip: "<b>AI Operating System Layer</b><br>Specialized OS components for AI workload optimization. Includes model serving frameworks, inference engines, tensor processing, and AI-specific resource management.",
                        examples: ["TensorRT", "ONNX Runtime", "Model Serving"]
                    },
                    {
                        name: "Traditional OS",
                        y: height * 0.45,
                        h: 50,
                        gradient: "url(#os-layer-grad)",
                        icon: "💻",
                        tooltip: "<b>Traditional Operating System</b><br>Core OS functions including process management, memory allocation, I/O operations, and system calls. Provides foundation for all upper-layer operations.",
                        examples: ["Linux Kernel", "Windows NT", "Process Management"]
                    },
                    {
                        name: "Hardware Layer",
                        y: height * 0.65,
                        h: 70,
                        gradient: "url(#hardware-grad)",
                        icon: "⚡",
                        tooltip: "<b>Hardware Infrastructure</b><br>Physical computing resources optimized for AI workloads. Includes specialized processors, high-bandwidth memory, and accelerated computing units.",
                        examples: ["CPU", "GPU", "NPU"]
                    }
                ];

                // Render enhanced layers with sophisticated styling
                layers.forEach((layer, i) => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, layer.tooltip)).on("mouseout", hideTooltip);

                    // Layer shadow for depth
                    g.append("rect").attr("x", 2).attr("y", layer.y + 2).attr("width", width).attr("height", layer.h).attr("fill", "rgba(0,0,0,0.1)").attr("rx", 8);

                    // Main layer rectangle with gradient
                    g.append("rect").attr("x", 0).attr("y", layer.y).attr("width", width).attr("height", layer.h).attr("fill", layer.gradient).attr("stroke", "white").attr("stroke-width", 2).attr("rx", 8).style("filter", "drop-shadow(0px 2px 6px rgba(0,0,0,0.2))");

                    // Layer icon
                    g.append("text").attr("x", 25).attr("y", layer.y + layer.h / 2 + 8).attr("text-anchor", "middle").style("font-size", "24px").style("font-family", "Inter, system-ui, sans-serif").text(layer.icon);

                    // Layer title with enhanced typography
                    g.append("text").attr("x", 60).attr("y", layer.y + layer.h / 2 - 5).attr("fill", "white").style("font-weight", "bold").style("font-size", "16px").style("font-family", "Inter, system-ui, sans-serif").text(layer.name);

                    // Layer examples
                    if (layer.examples) {
                        const exampleText = layer.examples.join(" • ");
                        g.append("text").attr("x", 60).attr("y", layer.y + layer.h / 2 + 15).attr("fill", "rgba(255,255,255,0.8)").style("font-size", "11px").style("font-family", "Inter, system-ui, sans-serif").text(exampleText);
                    }

                    // Layer performance indicator
                    const performanceWidth = (90 + i * 5) / 100 * (width - 80);
                    g.append("rect").attr("x", width - performanceWidth - 20).attr("y", layer.y + layer.h - 8).attr("width", performanceWidth).attr("height", 4).attr("fill", "rgba(255,255,255,0.6)").attr("rx", 2);
                });

                // Enhanced hardware components with responsive positioning and collision detection
                const hardwareCount = 3;
                const hardwareWidth = 90; // Hardware component width
                const minHardwareSpacing = Math.max(120, hardwareWidth + 30); // Dynamic minimum spacing
                const totalHardwareSpacing = (hardwareCount - 1) * minHardwareSpacing;
                const hardwareStartX = Math.max(60, (width - totalHardwareSpacing) / 2);
                
                const hardware = [
                    {
                        name: "CPU",
                        gradient: "url(#cpu-grad)",
                        performance: 85,
                        tooltip: "<b>Central Processing Unit</b><br>General-purpose processing for control flow, branching, and sequential operations. Optimized for low-latency single-threaded performance and complex instruction sets.",
                        specs: "Intel Xeon / AMD EPYC"
                    },
                    {
                        name: "GPU",
                        gradient: "url(#gpu-grad)",
                        performance: 95,
                        tooltip: "<b>Graphics Processing Unit</b><br>Massively parallel processing for matrix operations and neural network computations. Thousands of cores optimized for high-throughput parallel workloads.",
                        specs: "NVIDIA A100 / H100"
                    },
                    {
                        name: "NPU",
                        gradient: "url(#npu-grad)",
                        performance: 98,
                        tooltip: "<b>Neural Processing Unit</b><br>Purpose-built AI accelerators with specialized tensor processing units. Optimized for transformer architectures and edge AI inference.",
                        specs: "Google TPU / Intel VPU"
                    }
                ];
                
                // Calculate responsive hardware positions with collision detection
                hardware.forEach((hw, i) => {
                    hw.x = hardwareStartX + (i * minHardwareSpacing);
                    // Ensure hardware components don't exceed container bounds
                    if (hw.x + hardwareWidth / 2 > width - 20) {
                        hw.x = width - hardwareWidth / 2 - 20;
                    }
                });

                // Render enhanced hardware components
                hardware.forEach((hw, i) => {
                    const hwY = layers[3].y + 15;
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, hw.tooltip)).on("mouseout", hideTooltip);

                    // Hardware shadow
                    g.append("rect").attr("x", hw.x - 48).attr("y", hwY + 2).attr("width", 96).attr("height", 38).attr("fill", "rgba(0,0,0,0.15)").attr("rx", 6);

                    // Performance ring indicator with enhanced containment
                    const componentWidth = 90;
                    const componentHeight = 35;
                    const maxRingRadius = Math.min(componentWidth, componentHeight) / 2 - 8; // Enhanced containment margin
                    const ringRadius = Math.min(18, maxRingRadius); // Slightly smaller for better containment
                    const circumference = 2 * Math.PI * ringRadius;
                    const performanceOffset = circumference - (hw.performance / 100) * circumference;

                    // Background ring with enhanced containment
                    g.append("circle")
                        .attr("cx", hw.x)
                        .attr("cy", hwY + componentHeight / 2)
                        .attr("r", ringRadius)
                        .attr("fill", "none")
                        .attr("stroke", "rgba(255,255,255,0.2)")
                        .attr("stroke-width", 2);
                    
                    // Performance ring with gradient and containment
                    g.append("circle")
                        .attr("cx", hw.x)
                        .attr("cy", hwY + componentHeight / 2)
                        .attr("r", ringRadius)
                        .attr("fill", "none")
                        .attr("stroke", hw.gradient)
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", circumference)
                        .attr("stroke-dashoffset", performanceOffset)
                        .style("stroke-linecap", "round")
                        .style("filter", "drop-shadow(0px 1px 2px rgba(0,0,0,0.3))");

                    // Main responsive hardware component
                    g.append("rect")
                        .attr("x", hw.x - componentWidth/2)
                        .attr("y", hwY)
                        .attr("width", componentWidth)
                        .attr("height", componentHeight)
                        .attr("fill", hw.gradient)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2)
                        .attr("rx", 6)
                        .style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.3))");

                    // Responsive hardware name and specs with overflow protection
                    const nameFontSize = isSmallScreen ? "10px" : isMediumScreen ? "11px" : "12px";
                    const nameY = hwY + (componentHeight * 0.4);
                    
                    g.append("text")
                        .attr("x", hw.x)
                        .attr("y", nameY)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-weight", "bold")
                        .style("font-size", nameFontSize)
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(hw.name);
                    
                    // Responsive specs text with dynamic truncation
                    const maxSpecsLength = isSmallScreen ? 15 : isMediumScreen ? 18 : 20;
                    const specsText = hw.specs.length > maxSpecsLength ? 
                        hw.specs.substring(0, maxSpecsLength - 3) + "..." : hw.specs;
                    
                    const specsFontSize = isSmallScreen ? "8px" : isMediumScreen ? "9px" : "10px";
                    const specsY = hwY + (componentHeight * 0.75);
                    
                    g.append("text")
                        .attr("x", hw.x)
                        .attr("y", specsY)
                        .attr("text-anchor", "middle")
                        .attr("fill", "rgba(255,255,255,0.8)")
                        .style("font-size", specsFontSize)
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(specsText);

                    // Performance percentage
                    g.append("text").attr("x", hw.x).attr("y", hwY + 65).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "10px").style("font-weight", "600").style("font-family", "Inter, system-ui, sans-serif").text(`${hw.performance}% efficiency`);

                    // Sophisticated connection to AI OS Layer
                    const targetY = layers[1].y + layers[1].h;
                    const controlY = (hwY + targetY) / 2;

                    // Multiple parallel data paths for visual richness
                    for (let j = 0; j < 3; j++) {
                        const offset = (j - 1) * 4;
                        const opacity = 0.6 - j * 0.15;
                        const strokeWidth = 3 - j;

                        svg.append("path")
                            .attr("d", `M ${hw.x + offset} ${hwY} Q ${hw.x + offset} ${controlY} ${width / 2 + offset} ${targetY}`)
                            .attr("stroke", hw.gradient)
                            .attr("stroke-width", strokeWidth)
                            .attr("stroke-opacity", opacity)
                            .attr("fill", "none")
                            .attr("marker-end", j === 0 ? "url(#arrow-data)" : "none")
                            .attr("stroke-dasharray", j > 0 ? "5,5" : "none");
                    }
                });

                // Data flow indicators between layers
                const flowPaths = [
                    { from: 0, to: 1, label: "API Calls" },
                    { from: 1, to: 2, label: "System Calls" },
                    { from: 2, to: 3, label: "Hardware Instructions" }
                ];

                flowPaths.forEach((flow, i) => {
                    const fromLayer = layers[flow.from];
                    const toLayer = layers[flow.to];
                    const startY = fromLayer.y + fromLayer.h;
                    const endY = toLayer.y;
                    const midY = (startY + endY) / 2;

                    // Enhanced adaptive flow arrow positioning with collision detection
                    const flowArrowX = Math.max(width - 50, Math.min(width * 0.9, width - 30)); // Enhanced responsive positioning
                    const flowLabelX = Math.max(width - 120, Math.min(width * 0.8, width - 80)); // Enhanced responsive label positioning

                    // Flow arrow
                    svg.append("line")
                        .attr("x1", flowArrowX).attr("y1", startY + 5)
                        .attr("x2", flowArrowX).attr("y2", endY - 5)
                        .attr("stroke", "#3A86FF")
                        .attr("stroke-width", 2)
                        .attr("marker-end", "url(#arrow-layer)")
                        .attr("opacity", 0.7);

                    // Flow label
                    svg.append("text")
                        .attr("x", flowLabelX).attr("y", midY + 4)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-weight", "500")
                        .text(flow.label);
                });

                // Enhanced title and architecture explanation
                svg.append("text").attr("x", width / 2).attr("y", -15).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "700").style("font-size", "16px").style("font-family", "Inter, system-ui, sans-serif").text("AI-Optimized Computing Stack");
                svg.append("text").attr("x", width / 2).attr("y", height + 35).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Hierarchical architecture enabling efficient AI workload execution across specialized hardware");
            }

            /** Renders the ML vs Deep Learning comparison with advanced visual storytelling. */
            function renderMlDlViz() {
                console.log('Starting renderMlDlViz...');
                
                // Check if required dependencies are available
                if (typeof arrowMarker === 'undefined') {
                    console.error('arrowMarker function not available for ML/DL viz, delaying render...');
                    setTimeout(() => renderMlDlViz(), 50);
                    return;
                }
                
                const container = d3.select("#ml-dl-viz"); 
                if (container.empty()) {
                    console.error('Container #ml-dl-viz not found');
                    return;
                }
                
                container.selectAll("*").remove(); 
                const bounds = container.node().getBoundingClientRect(); 
                console.log('ML/DL viz container bounds:', bounds);
                
                if (bounds.width <= 0 || bounds.height <= 0) {
                    console.warn('ML/DL viz container has invalid dimensions, retrying...', bounds);
                    setTimeout(() => renderMlDlViz(), 100);
                    return;
                }
                
                // Global responsive design variables for this visualization
                const isSmallScreen = bounds.width < 600;
                const isMediumScreen = bounds.width < 900;
                
                const margin = { top: 60, right: 40, bottom: 60, left: 40 }, width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for paradigm differentiation
                const defs = svg.append("defs");

                // ML Paradigm gradient (traditional approach)
                const mlGradient = defs.append("linearGradient").attr("id", "ml-paradigm-grad").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                mlGradient.append("stop").attr("offset", "0%").attr("stop-color", "#FFB700").attr("stop-opacity", 0.1);
                mlGradient.append("stop").attr("offset", "100%").attr("stop-color", "#FCD34D").attr("stop-opacity", 0.05);

                // DL Paradigm gradient (modern approach)
                const dlGradient = defs.append("linearGradient").attr("id", "dl-paradigm-grad").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                dlGradient.append("stop").attr("offset", "0%").attr("stop-color", "#3A86FF").attr("stop-opacity", 0.1);
                dlGradient.append("stop").attr("offset", "100%").attr("stop-color", "#60A5FA").attr("stop-opacity", 0.05);

                // Component gradients
                const componentGradients = [
                    { id: "data-grad", colors: ["#8E8E93", "#A1A1AA"] },
                    { id: "feature-grad", colors: ["#FFB700", "#FCD34D"] },
                    { id: "model-grad", colors: ["#2EC4B6", "#34D399"] },
                    { id: "neural-grad", colors: ["#3A86FF", "#60A5FA"] },
                    { id: "output-grad", colors: ["#8338EC", "#A855F7"] }
                ];

                componentGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                arrowMarker(svg, "arrow-ml", "#FFB700");
                arrowMarker(svg, "arrow-dl", "#3A86FF");
                arrowMarker(svg, "arrow-flow", "#2EC4B6");

                // Paradigm background sections with flexible heights
                const mlY = height * 0.15;
                const dlY = height * 0.6;
                const baseSectionHeight = height * 0.35;
                const sectionHeight = Math.max(baseSectionHeight, 120); // Ensure minimum section height

                // ML paradigm background
                svg.append("rect").attr("x", 0).attr("y", mlY - 20).attr("width", width).attr("height", sectionHeight).attr("fill", "url(#ml-paradigm-grad)").attr("stroke", "#FFB700").attr("stroke-width", 2).attr("stroke-dasharray", "8,4").attr("rx", 12).attr("opacity", 0.6);

                // DL paradigm background  
                svg.append("rect").attr("x", 0).attr("y", dlY - 20).attr("width", width).attr("height", sectionHeight).attr("fill", "url(#dl-paradigm-grad)").attr("stroke", "#3A86FF").attr("stroke-width", 2).attr("stroke-dasharray", "8,4").attr("rx", 12).attr("opacity", 0.6);

                // Enhanced responsive workflow creation function with legend positioning and neural network containment
                const createAdvancedWorkflow = (paradigm, steps, y, isDeepLearning = false) => {
                    // Use global responsive design variables (isSmallScreen and isMediumScreen are defined in parent scope)
                    
                    const minStepSpacing = isSmallScreen ? 120 : isMediumScreen ? 140 : Math.max(160, width * 0.15);
                    const totalStepSpacing = (steps.length - 1) * minStepSpacing;
                    const availableWidth = isSmallScreen ? width * 0.8 : isMediumScreen ? width * 0.7 : Math.min(width * 0.65, width - 180);
                    const stepWidth = Math.max(minStepSpacing, availableWidth / steps.length);
                    const paradigmColor = isDeepLearning ? "#3A86FF" : "#FFB700";

                    steps.forEach((step, i) => {
                        const startX = 80; // Start position with margin
                        const x = startX + (i * stepWidth);
                        let boxWidth = 140;
                        let boxHeight = 60;

                        // Enhanced responsive neural network visualization with containment
                        if (isDeepLearning && i === 1) {
                            boxWidth = isSmallScreen ? Math.min(160, stepWidth - 30) : 
                                      isMediumScreen ? Math.min(180, stepWidth - 25) : 
                                      Math.min(200, stepWidth - 20);
                            boxHeight = isSmallScreen ? 70 : isMediumScreen ? 75 : Math.min(100, 80);
                        } else {
                            // Responsive sizing for other components
                            boxWidth = isSmallScreen ? 120 : isMediumScreen ? 130 : 140;
                            boxHeight = isSmallScreen ? 50 : isMediumScreen ? 55 : 60;
                        }

                        const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, step.tooltip)).on("mouseout", hideTooltip);

                        // Component shadow
                        g.append("rect").attr("x", x - boxWidth / 2 + 2).attr("y", y - boxHeight / 2 + 2).attr("width", boxWidth).attr("height", boxHeight).attr("fill", "rgba(0,0,0,0.1)").attr("rx", 8);

                        // Main component box
                        g.append("rect").attr("x", x - boxWidth / 2).attr("y", y - boxHeight / 2).attr("width", boxWidth).attr("height", boxHeight).attr("fill", step.gradient).attr("stroke", "white").attr("stroke-width", 2).attr("rx", 8).style("filter", "drop-shadow(0px 2px 6px rgba(0,0,0,0.2))");

                        // Component icon
                        g.append("text").attr("x", x - boxWidth / 2 + 20).attr("y", y - 8).attr("text-anchor", "middle").style("font-size", "20px").style("font-family", "Inter, system-ui, sans-serif").text(step.icon);

                        // Component title
                        g.append("text").attr("x", x).attr("y", y - 8).attr("text-anchor", "middle").attr("fill", "white").style("font-weight", "bold").style("font-size", "14px").style("font-family", "Inter, system-ui, sans-serif").text(step.name);

                        // Component description
                        g.append("text").attr("x", x).attr("y", y + 12).attr("text-anchor", "middle").attr("fill", "rgba(255,255,255,0.8)").style("font-size", "10px").style("font-family", "Inter, system-ui, sans-serif").text(step.description);

                        // Enhanced responsive neural network visualization with containment
                        if (isDeepLearning && i === 1) {
                            const nnX = x;
                            const nnY = y + (isSmallScreen ? 10 : 15);
                            const layers = isSmallScreen ? [3, 4, 4, 3, 2] : isMediumScreen ? [3, 5, 5, 3, 2] : [4, 6, 6, 4, 2];
                            const maxLayerSpacing = Math.min(25, (boxWidth - 50) / (layers.length - 1)); // Enhanced containment margin
                            const layerSpacing = maxLayerSpacing;
                            const startX = nnX - (layers.length - 1) * layerSpacing / 2;

                            const nodes = [];
                            layers.forEach((nodeCount, layerIdx) => {
                                const layerX = startX + layerIdx * layerSpacing;
                                const nodeSpacing = isSmallScreen ? 6 : isMediumScreen ? 7 : 8;
                                const maxNodeHeight = boxHeight - 20; // Ensure nodes fit within container
                                const startY = nnY - Math.min((nodeCount - 1) * nodeSpacing / 2, maxNodeHeight / 2);

                                for (let nodeIdx = 0; nodeIdx < nodeCount; nodeIdx++) {
                                    nodes.push({
                                        layer: layerIdx,
                                        x: layerX,
                                        y: startY + nodeIdx * nodeSpacing,
                                        activation: Math.random()
                                    });
                                }
                            });

                            // Neural connections with activation-based opacity
                            for (let i = 0; i < layers.length - 1; i++) {
                                const sourceNodes = nodes.filter(d => d.layer === i);
                                const targetNodes = nodes.filter(d => d.layer === i + 1);

                                sourceNodes.forEach(source => {
                                    targetNodes.forEach(target => {
                                        const weight = Math.random();
                                        svg.append('line')
                                            .attr('x1', source.x).attr('y1', source.y)
                                            .attr('x2', target.x).attr('y2', target.y)
                                            .attr('stroke', '#60A5FA')
                                            .attr('stroke-width', weight * 1.5)
                                            .attr('opacity', 0.3 + weight * 0.4);
                                    });
                                });
                            }

                            // Responsive neural nodes with activation visualization
                            const nodeRadius = isSmallScreen ? 2 : isMediumScreen ? 2.2 : 2.5;
                            nodes.forEach(node => {
                                svg.append('circle')
                                    .attr('cx', node.x).attr('cy', node.y)
                                    .attr('r', nodeRadius)
                                    .attr('fill', '#FFFFFF')
                                    .attr('stroke', '#3A86FF')
                                    .attr('stroke-width', 1)
                                    .attr('opacity', 0.7 + node.activation * 0.3);
                            });

                            // Responsive layer labels with containment
                            const layerLabels = ["Input", "Hidden", "Hidden", "Hidden", "Output"];
                            const labelFontSize = isSmallScreen ? "7px" : isMediumScreen ? "7.5px" : "8px";
                            const labelY = nnY + (isSmallScreen ? 25 : 35);
                            
                            layers.forEach((_, idx) => {
                                if (idx === 0 || idx === layers.length - 1) {
                                    svg.append("text")
                                        .attr("x", startX + idx * layerSpacing)
                                        .attr("y", labelY)
                                        .attr("text-anchor", "middle")
                                        .attr("fill", "rgba(255,255,255,0.8)")
                                        .style("font-size", labelFontSize)
                                        .text(layerLabels[idx]);
                                }
                            });
                        }

                        // Performance indicator
                        const performanceWidth = step.performance / 100 * (boxWidth - 20);
                        g.append("rect").attr("x", x - boxWidth / 2 + 10).attr("y", y + boxHeight / 2 - 8).attr("width", performanceWidth).attr("height", 3).attr("fill", "rgba(255,255,255,0.8)").attr("rx", 1.5);

                        // Connecting arrows between components
                        if (i < steps.length - 1) {
                            const nextX = startX + ((i + 1) * stepWidth);
                            const arrowY = y;

                            // Multiple flow lines for visual richness
                            for (let j = 0; j < 2; j++) {
                                const offsetY = (j - 0.5) * 6;
                                const opacity = 0.8 - j * 0.3;

                                svg.append("line")
                                    .attr("x1", x + boxWidth / 2 + 5).attr("y1", arrowY + offsetY)
                                    .attr("x2", nextX - boxWidth / 2 - 5).attr("y2", arrowY + offsetY)
                                    .attr("stroke", paradigmColor)
                                    .attr("stroke-width", 3 - j)
                                    .attr("opacity", opacity)
                                    .attr("marker-end", j === 0 ? `url(#arrow-${isDeepLearning ? 'dl' : 'ml'})` : "none");
                            }
                        }
                    });
                };

                // Enhanced step definitions with academic depth
                const mlSteps = [
                    {
                        name: "Raw Data",
                        description: "Structured datasets",
                        icon: "📊",
                        gradient: "url(#data-grad)",
                        performance: 70,
                        tooltip: "<b>Raw Data Input</b><br>Structured, preprocessed datasets requiring domain expertise for preparation. Often tabular data with explicit feature definitions and manual data cleaning processes."
                    },
                    {
                        name: "Feature Engineering",
                        description: "Manual extraction",
                        icon: "🔧",
                        gradient: "url(#feature-grad)",
                        performance: 60,
                        tooltip: "<b>Manual Feature Engineering</b><br>Expert-driven feature selection and transformation. Requires deep domain knowledge to identify relevant patterns, create feature combinations, and optimize representations."
                    },
                    {
                        name: "ML Model",
                        description: "Algorithm training",
                        icon: "⚙️",
                        gradient: "url(#model-grad)",
                        performance: 80,
                        tooltip: "<b>Traditional ML Algorithms</b><br>Classical algorithms like Random Forest, SVM, or Linear Regression. Interpretable models with explicit feature importance and well-understood mathematical foundations."
                    },
                    {
                        name: "Predictions",
                        description: "Model output",
                        icon: "🎯",
                        gradient: "url(#output-grad)",
                        performance: 85,
                        tooltip: "<b>Model Predictions</b><br>Interpretable outputs with clear feature attribution. Easier to explain and validate, making them suitable for regulated industries and critical decisions."
                    }
                ];

                const dlSteps = [
                    {
                        name: "Raw Data",
                        description: "Unstructured inputs",
                        icon: "🌊",
                        gradient: "url(#data-grad)",
                        performance: 95,
                        tooltip: "<b>Raw Unstructured Data</b><br>Images, text, audio, and video that can be processed directly. Minimal preprocessing required as neural networks learn representations automatically from raw inputs."
                    },
                    {
                        name: "Neural Networks",
                        description: "Automated learning",
                        icon: "🧠",
                        gradient: "url(#neural-grad)",
                        performance: 98,
                        tooltip: "<b>Deep Neural Networks</b><br>Multi-layered architectures that automatically learn hierarchical feature representations. Capable of discovering complex patterns and abstractions without manual feature engineering."
                    },
                    {
                        name: "Predictions",
                        description: "Deep insights",
                        icon: "✨",
                        gradient: "url(#output-grad)",
                        performance: 92,
                        tooltip: "<b>Deep Learning Predictions</b><br>High-accuracy outputs from learned representations. Excels at complex pattern recognition but may lack interpretability in decision-making processes."
                    }
                ];

                // Paradigm titles with enhanced styling
                svg.append("text").attr("x", 40).attr("y", mlY - 35).attr("fill", "#FFB700").style("font-weight", "700").style("font-size", "18px").style("font-family", "Inter, system-ui, sans-serif").text("Traditional Machine Learning");
                svg.append("text").attr("x", 40).attr("y", mlY - 15).attr("fill", "var(--text-secondary)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Expert-driven feature engineering with interpretable algorithms");

                svg.append("text").attr("x", 40).attr("y", dlY - 35).attr("fill", "#3A86FF").style("font-weight", "700").style("font-size", "18px").style("font-family", "Inter, system-ui, sans-serif").text("Deep Learning");
                svg.append("text").attr("x", 40).attr("y", dlY - 15).attr("fill", "var(--text-secondary)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Automated representation learning with neural architectures");

                // Create enhanced workflows
                createAdvancedWorkflow("ML", mlSteps, mlY + 40, false);
                createAdvancedWorkflow("DL", dlSteps, dlY + 40, true);

                // Enhanced responsive legend positioning with neural network containment
                const legendWidth = isSmallScreen ? 120 : isMediumScreen ? 130 : 140;
                const minMargin = isSmallScreen ? 20 : isMediumScreen ? 25 : 30;
                const maxMetricsX = width - legendWidth - minMargin;
                const minMetricsX = isSmallScreen ? width * 0.6 : isMediumScreen ? width * 0.65 : width * 0.7;
                const metricsX = Math.max(minMetricsX, Math.min(maxMetricsX, width * 0.75));
                const metricsY = height * 0.05;

                svg.append("text").attr("x", metricsX).attr("y", metricsY).attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "14px").style("font-family", "Inter, system-ui, sans-serif").text("Paradigm Comparison");

                const metrics = [
                    { label: "Data Requirements", ml: 70, dl: 95, unit: "" },
                    { label: "Interpretability", ml: 90, dl: 30, unit: "" },
                    { label: "Performance", ml: 75, dl: 95, unit: "" },
                    { label: "Development Time", ml: 60, dl: 85, unit: "" }
                ];

                metrics.forEach((metric, i) => {
                    const spacing = isSmallScreen ? 30 : isMediumScreen ? 32 : 35;
                    const y = metricsY + 25 + (i * spacing);
                    
                    // Responsive font sizes
                    const labelFontSize = isSmallScreen ? "10px" : isMediumScreen ? "10.5px" : "11px";
                    const valueFontSize = isSmallScreen ? "8px" : isMediumScreen ? "8.5px" : "9px";
                    const barHeight = isSmallScreen ? 6 : isMediumScreen ? 7 : 8;

                    // Responsive metric label
                    svg.append("text")
                        .attr("x", metricsX)
                        .attr("y", y)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", labelFontSize)
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(metric.label);

                    // Responsive ML bar
                    svg.append("rect")
                        .attr("x", metricsX)
                        .attr("y", y + 5)
                        .attr("width", metric.ml)
                        .attr("height", barHeight)
                        .attr("fill", "#FFB700")
                        .attr("rx", 4)
                        .attr("opacity", 0.8);
                    svg.append("text")
                        .attr("x", metricsX + metric.ml + 5)
                        .attr("y", y + 12)
                        .attr("fill", "#FFB700")
                        .style("font-size", valueFontSize)
                        .style("font-weight", "600")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text("ML");

                    // Responsive DL bar
                    svg.append("rect")
                        .attr("x", metricsX)
                        .attr("y", y + 18)
                        .attr("width", metric.dl)
                        .attr("height", barHeight)
                        .attr("fill", "#3A86FF")
                        .attr("rx", 4)
                        .attr("opacity", 0.8);
                    svg.append("text")
                        .attr("x", metricsX + metric.dl + 5)
                        .attr("y", y + 25)
                        .attr("fill", "#3A86FF")
                        .style("font-size", valueFontSize)
                        .style("font-weight", "600")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text("DL");
                });

                // Enhanced title and subtitle
                svg.append("text").attr("x", width / 2).attr("y", -25).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "700").style("font-size", "20px").style("font-family", "Inter, system-ui, sans-serif").text("Machine Learning Paradigms");
                svg.append("text").attr("x", width / 2).attr("y", height + 35).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Comparative analysis of traditional ML versus deep learning approaches");
            }

            /** Renders the Transformer self-attention visualization with epic storytelling animations. */
            function renderTransformerViz() {
                console.log('Starting renderTransformerViz...');
                
                // Check if required dependencies are available
                if (typeof arrowMarker === 'undefined') {
                    console.error('arrowMarker function not available for Transformer viz, delaying render...');
                    setTimeout(() => renderTransformerViz(), 50);
                    return;
                }
                
                const container = d3.select("#transformer-viz"); 
                if (container.empty()) {
                    console.error('Container #transformer-viz not found');
                    return;
                }
                
                container.selectAll("*").remove(); 
                const bounds = container.node().getBoundingClientRect(); 
                console.log('Transformer viz container bounds:', bounds);
                
                if (bounds.width <= 0 || bounds.height <= 0) {
                    console.warn('Transformer viz container has invalid dimensions, retrying...', bounds);
                    setTimeout(() => renderTransformerViz(), 100);
                    return;
                }
                const margin = { top: 40, right: 40, bottom: 60, left: 40 }, width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for attention heatmap
                const defs = svg.append("defs");
                const attentionGradient = defs.append("linearGradient").attr("id", "attention-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                attentionGradient.append("stop").attr("offset", "0%").attr("stop-color", "#FF6B6B").attr("stop-opacity", 0.1);
                attentionGradient.append("stop").attr("offset", "50%").attr("stop-color", "#FFB700").attr("stop-opacity", 0.6);
                attentionGradient.append("stop").attr("offset", "100%").attr("stop-color", "#2EC4B6").attr("stop-opacity", 0.9);

                // Create attention pattern background with pulsing animation
                const patternSize = 20;
                const pattern = defs.append("pattern").attr("id", "attention-pattern").attr("patternUnits", "userSpaceOnUse").attr("width", patternSize).attr("height", patternSize);
                pattern.append("circle").attr("cx", patternSize / 2).attr("cy", patternSize / 2).attr("r", 2).attr("fill", "var(--accent-cyan)").attr("opacity", 0.1);

                // Add storytelling glow filter for dramatic effect
                const glowFilter = defs.append("filter").attr("id", "attention-glow").attr("x", "-50%").attr("y", "-50%").attr("width", "200%").attr("height", "200%");
                glowFilter.append("feGaussianBlur").attr("stdDeviation", "4").attr("result", "coloredBlur");
                const feMerge = glowFilter.append("feMerge");
                feMerge.append("feMergeNode").attr("in", "coloredBlur");
                feMerge.append("feMergeNode").attr("in", "SourceGraphic");

                // Enhanced sentence data with semantic roles
                const sentence = [
                    { word: "The", pos: "DET", attention: 0.1, semantic: "determiner" },
                    { word: "cat", pos: "NOUN", attention: 0.8, semantic: "subject" },
                    { word: "sat", pos: "VERB", attention: 0.9, semantic: "predicate" },
                    { word: "on", pos: "PREP", attention: 0.7, semantic: "preposition" },
                    { word: "the", pos: "DET", attention: 0.1, semantic: "determiner" },
                    { word: "mat", pos: "NOUN", attention: 0.2, semantic: "object" }
                ];

                const minBoxWidth = 70;
                const maxBoxWidth = 90;
                const minSpacing = 20; // Increased minimum spacing for better separation
                const availableWidth = width * 0.65; // Further reduced available width to leave more space for legend and matrix
                const calculatedBoxWidth = Math.max(minBoxWidth, Math.min(maxBoxWidth, (availableWidth - (sentence.length - 1) * minSpacing) / sentence.length));
                const boxWidth = calculatedBoxWidth;
                const boxHeight = 50;
                const spacing = Math.max(minSpacing, (availableWidth - sentence.length * boxWidth) / (sentence.length - 1));
                const totalWidth = sentence.length * (boxWidth + spacing) - spacing;
                const startX = Math.max(40, (width - totalWidth) / 2); // Ensure minimum margin from left edge
                const y_input = height * 0.25, y_output = height * 0.75;

                // Input layer with enhanced styling and semantic color coding
                const semanticColors = {
                    "determiner": "#8E8E93",
                    "subject": "#3A86FF",
                    "predicate": "#FF6B6B",
                    "preposition": "#FFB700",
                    "object": "#2EC4B6"
                };

                const inputNodes = svg.selectAll(".input-node").data(sentence).enter().append("g")
                    .attr("class", "interactive-node")
                    .attr("transform", (d, i) => `translate(${startX + i * (boxWidth + spacing)}, ${y_input})`)
                    .on("mouseover", (e, d) => showTooltip(e, `<b>${d.word}</b><br>Part of Speech: ${d.pos}<br>Semantic Role: ${d.semantic}<br>Attention Weight: ${d.attention.toFixed(2)}`))
                    .on("mouseout", hideTooltip);

                // Enhanced input nodes with layered effects and storytelling animations
                inputNodes.each(function (d, i) {
                    const g = d3.select(this);

                    // Start with invisible elements for dramatic entrance
                    g.style("opacity", 0).style("transform", "translateY(-30px)");

                    // Background glow effect with pulsing animation
                    const glow = g.append("rect").attr("x", -2).attr("y", -2).attr("width", boxWidth + 4).attr("height", boxHeight + 4).attr("rx", 8).attr("fill", semanticColors[d.semantic]).attr("opacity", 0.2).style("filter", "url(#attention-glow)");

                    // Main token box with hover effects
                    const mainBox = g.append("rect").attr("width", boxWidth).attr("height", boxHeight).attr("rx", 6).attr("fill", "var(--primary-border)").attr("stroke", semanticColors[d.semantic]).attr("stroke-width", 2).style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.1))");

                    // Word text with enhanced typography
                    const wordText = g.append("text").attr("x", boxWidth / 2).attr("y", boxHeight / 2 - 5).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "bold").style("font-size", "14px").style("font-family", "Inter, system-ui, sans-serif").text(d.word);

                    // POS tag with color animation
                    const posText = g.append("text").attr("x", boxWidth / 2).attr("y", boxHeight / 2 + 12).attr("text-anchor", "middle").attr("fill", semanticColors[d.semantic]).style("font-size", "10px").style("font-weight", "500").style("font-family", "Inter, system-ui, sans-serif").text(d.pos);

                    // Staggered entrance animation - the story unfolds token by token
                    g.transition()
                        .delay(i * 300) // Staggered timing for narrative flow
                        .duration(800)
                        .ease(d3.easeElasticOut.amplitude(1).period(0.3))
                        .style("opacity", 1)
                        .style("transform", "translateY(0px)");

                    // Add attention pulse animation for high-attention words
                    if (d.attention > 0.6) {
                        function pulse() {
                            glow.transition()
                                .duration(1500)
                                .attr("opacity", 0.6)
                                .transition()
                                .duration(1500)
                                .attr("opacity", 0.2)
                                .on("end", pulse);
                        }
                        // Start pulsing after entrance animation
                        setTimeout(pulse, i * 300 + 800);
                    }

                    // Enhanced hover interactions with storytelling
                    g.on("mouseenter", function () {
                        mainBox.transition().duration(200).attr("stroke-width", 4).style("filter", "url(#attention-glow) drop-shadow(0px 4px 12px rgba(0,0,0,0.3))");
                        wordText.transition().duration(200).style("font-size", "16px");
                        posText.transition().duration(200).style("font-size", "12px");
                    }).on("mouseleave", function () {
                        mainBox.transition().duration(200).attr("stroke-width", 2).style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.1))");
                        wordText.transition().duration(200).style("font-size", "14px");
                        posText.transition().duration(200).style("font-size", "10px");
                    });
                });

                // Enhanced output node with attention focus
                const outputNode = svg.append("g")
                    .attr("class", "interactive-node")
                    .attr("transform", `translate(${width / 2 - boxWidth / 2}, ${y_output})`)
                    .on("mouseover", (e) => showTooltip(e, "<b>Output Token: 'sat'</b><br>Attention mechanism focuses on semantically relevant tokens<br>High attention to subject 'cat' and preposition 'on'"))
                    .on("mouseout", hideTooltip);

                // Output node with pulsing animation
                outputNode.append("circle").attr("cx", boxWidth / 2).attr("cy", boxHeight / 2).attr("r", boxWidth / 2 + 10).attr("fill", "var(--accent-blue)").attr("opacity", 0.2);
                outputNode.append("rect").attr("width", boxWidth).attr("height", boxHeight).attr("rx", 8).attr("fill", "var(--accent-blue)").attr("stroke", "white").attr("stroke-width", 3).style("filter", "drop-shadow(0px 4px 8px rgba(58, 134, 255, 0.4))");
                outputNode.append("text").attr("x", boxWidth / 2).attr("y", boxHeight / 2 + 5).attr("text-anchor", "middle").attr("fill", "white").style("font-weight", "bold").style("font-size", "16px").style("font-family", "Inter, system-ui, sans-serif").text("sat");

                // Epic attention flow visualization with storytelling animations
                inputNodes.each(function (d, i) {
                    const score = d.attention;
                    const startPos = { x: startX + i * (boxWidth + spacing) + boxWidth / 2, y: y_input + boxHeight };
                    const endPos = { x: width / 2, y: y_output };
                    const animationDelay = i * 300 + 2000; // Start after token entrance animations

                    // Create multiple animated attention paths that tell the story of neural focus
                    for (let j = 0; j < 3; j++) {
                        const offset = (j - 1) * 8;
                        const opacity = score * (j === 0 ? 0.9 : j === 1 ? 0.7 : 0.5); // Standardized opacity encoding
                        const strokeWidth = score * (6 - j);

                        const path = svg.append("path")
                            .attr("d", `M ${startPos.x + offset} ${startPos.y} Q ${(startPos.x + endPos.x) / 2 + offset} ${(startPos.y + endPos.y) / 2 + 60} ${endPos.x + offset} ${endPos.y}`)
                            .attr("stroke", j === 0 ? semanticColors[d.semantic] : "var(--accent-cyan)")
                            .attr("stroke-width", strokeWidth)
                            .attr("stroke-opacity", 0) // Start invisible for dramatic reveal
                            .attr("fill", "none")
                            .attr("class", "interactive-node")
                            .style("stroke-linecap", "round")
                            .style("filter", j === 0 && score > 0.7 ? "url(#attention-glow)" : "none")
                            .on("mouseover", (e) => showTooltip(e, `<b>Attention Flow</b><br>Token: ${d.word}<br>Weight: ${score.toFixed(3)}<br>Semantic relevance to predicate 'sat'`))
                            .on("mouseout", hideTooltip);

                        // Animated reveal of attention connections
                        path.transition()
                            .delay(animationDelay + j * 200)
                            .duration(1200)
                            .ease(d3.easeQuadOut)
                            .attr("stroke-opacity", opacity);

                        // Add flowing energy for high-attention connections
                        if (j === 0 && score > 0.6) {
                            function createEnergyPulse() {
                                const energyPath = svg.append("path")
                                    .attr("d", `M ${startPos.x + offset} ${startPos.y} Q ${(startPos.x + endPos.x) / 2 + offset} ${(startPos.y + endPos.y) / 2 + 60} ${endPos.x + offset} ${endPos.y}`)
                                    .attr("stroke", semanticColors[d.semantic])
                                    .attr("stroke-width", strokeWidth + 2)
                                    .attr("stroke-opacity", 0.8)
                                    .attr("fill", "none")
                                    .style("stroke-linecap", "round")
                                    .style("filter", "url(#attention-glow)")
                                    .attr("stroke-dasharray", "10,10")
                                    .attr("stroke-dashoffset", 20);

                                // Animate energy pulse flowing along path
                                energyPath.transition()
                                    .duration(2000)
                                    .ease(d3.easeLinear)
                                    .attr("stroke-dashoffset", -20)
                                    .on("end", function () {
                                        energyPath.remove();
                                        setTimeout(createEnergyPulse, 2000 + Math.random() * 3000);
                                    });
                            }

                            // Start energy pulses after path appears
                            setTimeout(createEnergyPulse, animationDelay + 1500);
                        }
                    }

                    // Enhanced attention weight indicators with dramatic scaling animation
                    const midX = (startPos.x + endPos.x) / 2;
                    const midY = (startPos.y + endPos.y) / 2 + 60;
                    const finalRadius = 4 + score * 8;

                    const indicator = svg.append("circle")
                        .attr("cx", midX).attr("cy", midY)
                        .attr("r", 0) // Start with zero radius
                        .attr("fill", semanticColors[d.semantic])
                        .attr("opacity", 0)
                        .attr("class", "interactive-node")
                        .style("filter", score > 0.7 ? "url(#attention-glow)" : "none")
                        .on("mouseover", (e) => showTooltip(e, `Attention Weight: ${(score * 100).toFixed(1)}%`))
                        .on("mouseout", hideTooltip);

                    // Dramatic growth animation for attention indicators
                    indicator.transition()
                        .delay(animationDelay + 800)
                        .duration(800)
                        .ease(d3.easeElasticOut.amplitude(1).period(0.4))
                        .attr("r", finalRadius)
                        .attr("opacity", 0.7);

                    // Add pulsing animation for high-attention indicators
                    if (score > 0.7) {
                        function pulseIndicator() {
                            indicator.transition()
                                .duration(2000)
                                .attr("r", finalRadius * 1.3)
                                .attr("opacity", 0.9)
                                .transition()
                                .duration(2000)
                                .attr("r", finalRadius)
                                .attr("opacity", 0.7)
                                .on("end", pulseIndicator);
                        }
                        setTimeout(pulseIndicator, animationDelay + 1600);
                    }

                    // Animated numeric attention scores with collision detection
                    const scoreTextY = midY + 25; // Increased offset to avoid collision with flow paths
                    const scoreText = svg.append("text")
                        .attr("x", midX).attr("y", scoreTextY)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .style("opacity", 0)
                        .text(score.toFixed(2));

                    // Fade in score text
                    scoreText.transition()
                        .delay(animationDelay + 1200)
                        .duration(600)
                        .style("opacity", 1);
                });

                // Epic Interactive Attention Matrix - The Grand Finale!
                setTimeout(() => {
                    renderInteractiveAttentionMatrix(svg, width, height, sentence);
                }, 4000);

                // Enhanced explanation with attention matrix preview
                svg.append("text").attr("x", width / 2).attr("y", height - 30).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "14px").style("font-family", "Inter, system-ui, sans-serif").text("Self-Attention Mechanism: Query-Key-Value Computation");
                svg.append("text").attr("x", width / 2).attr("y", height - 10).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Hover over tokens to explore attention patterns • Click matrix for layer selection");

                // Add attention matrix visualization legend with enhanced responsive positioning
                const legendWidth = 100;
                const minLegendMargin = 30;
                const maxLegendX = width - legendWidth - minLegendMargin;
                const minLegendX = width * 0.75; // Moved further right to eliminate main diagram overlap
                const legendX = Math.max(minLegendX, Math.min(maxLegendX, width * 0.80)); // Enhanced responsive positioning - moved to 80%
                const legendY = 20;
                svg.append("text").attr("x", legendX).attr("y", legendY).attr("fill", "var(--text-primary)").style("font-size", "12px").style("font-weight", "600").style("font-family", "Inter, system-ui, sans-serif").text("Attention Legend");

                const legendItems = [
                    { label: "High (> 0.7)", color: "#2EC4B6", width: 6 },
                    { label: "Medium (0.3-0.7)", color: "#FFB700", width: 4 },
                    { label: "Low (< 0.3)", color: "#8E8E93", width: 2 }
                ];

                legendItems.forEach((item, i) => {
                    const y = legendY + 20 + (i * 18);
                    svg.append("line").attr("x1", legendX).attr("y1", y).attr("x2", legendX + 20).attr("y2", y).attr("stroke", item.color).attr("stroke-width", item.width);
                    svg.append("text").attr("x", legendX + 25).attr("y", y + 4).attr("fill", "var(--text-secondary)").style("font-size", "10px").style("font-family", "Inter, system-ui, sans-serif").text(item.label);
                });
            }

            /** Epic Interactive Attention Matrix - A Jedi Master's Creation! */
            function renderInteractiveAttentionMatrix(parentSvg, parentWidth, parentHeight, sentence) {
                const matrixSize = 120;
                const minMatrixMargin = 40; // Increased margin for better separation
                const maxMatrixX = parentWidth - matrixSize - minMatrixMargin;
                const minMatrixX = parentWidth * 0.85; // Moved further right to eliminate main diagram overlap
                const matrixX = Math.max(minMatrixX, Math.min(maxMatrixX, parentWidth * 0.90)); // Enhanced responsive positioning - moved to 90%
                const matrixY = 20;
                const cellSize = matrixSize / sentence.length;

                // Create attention matrix data for multiple heads/layers
                const attentionLayers = [
                    {
                        name: "Head 1",
                        description: "Syntactic Relations",
                        matrix: [
                            [0.1, 0.05, 0.1, 0.15, 0.05, 0.55], // The
                            [0.05, 0.7, 0.15, 0.05, 0.03, 0.02], // cat
                            [0.1, 0.6, 0.2, 0.05, 0.03, 0.02],   // sat
                            [0.05, 0.1, 0.65, 0.15, 0.03, 0.02], // on
                            [0.1, 0.05, 0.1, 0.15, 0.05, 0.55],  // the
                            [0.05, 0.25, 0.1, 0.5, 0.08, 0.02]   // mat
                        ]
                    },
                    {
                        name: "Head 2",
                        description: "Semantic Relations",
                        matrix: [
                            [0.3, 0.2, 0.1, 0.1, 0.2, 0.1], // The
                            [0.15, 0.4, 0.25, 0.1, 0.05, 0.05], // cat
                            [0.1, 0.7, 0.1, 0.05, 0.03, 0.02],   // sat
                            [0.05, 0.2, 0.15, 0.3, 0.1, 0.2], // on
                            [0.25, 0.15, 0.1, 0.15, 0.25, 0.1],  // the
                            [0.1, 0.3, 0.1, 0.4, 0.08, 0.02]   // mat
                        ]
                    }
                ];

                let currentLayer = 0;

                // Container for the attention matrix
                const matrixContainer = parentSvg.append("g")
                    .attr("class", "attention-matrix")
                    .style("opacity", 0);

                // Background for the matrix
                matrixContainer.append("rect")
                    .attr("x", matrixX - 5)
                    .attr("y", matrixY - 5)
                    .attr("width", matrixSize + 10)
                    .attr("height", matrixSize + 35)
                    .attr("fill", "rgba(13, 27, 42, 0.95)")
                    .attr("stroke", "var(--accent-cyan)")
                    .attr("stroke-width", 1)
                    .attr("rx", 5);

                // Matrix title
                const titleText = matrixContainer.append("text")
                    .attr("x", matrixX + matrixSize / 2)
                    .attr("y", matrixY - 10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-cyan)")
                    .style("font-size", "10px")
                    .style("font-weight", "600")
                    .text("Attention Matrix");

                // Layer selector
                const layerSelector = matrixContainer.append("text")
                    .attr("x", matrixX + matrixSize / 2)
                    .attr("y", matrixY + matrixSize + 20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "8px")
                    .style("cursor", "pointer")
                    .text(`${attentionLayers[currentLayer].name} - ${attentionLayers[currentLayer].description}`)
                    .on("click", function () {
                        currentLayer = (currentLayer + 1) % attentionLayers.length;
                        updateMatrix();
                        layerSelector.text(`${attentionLayers[currentLayer].name} - ${attentionLayers[currentLayer].description}`);
                    });

                function updateMatrix() {
                    const currentMatrix = attentionLayers[currentLayer].matrix;

                    // Remove existing cells
                    matrixContainer.selectAll(".matrix-cell").remove();
                    matrixContainer.selectAll(".matrix-label").remove();

                    // Create matrix cells
                    sentence.forEach((tokenRow, i) => {
                        sentence.forEach((tokenCol, j) => {
                            const attention = currentMatrix[i][j];
                            const cellX = matrixX + j * cellSize;
                            const cellY = matrixY + i * cellSize;

                            const cell = matrixContainer.append("rect")
                                .attr("class", "matrix-cell")
                                .attr("x", cellX)
                                .attr("y", cellY)
                                .attr("width", cellSize)
                                .attr("height", cellSize)
                                .attr("fill", d3.interpolateBlues(attention))
                                .attr("stroke", "var(--primary-border)")
                                .attr("stroke-width", 0.5)
                                .attr("rx", 3) // Enhanced rounded corners for better visual appeal
                                .style("cursor", "pointer")
                                .style("opacity", 0)
                                .style("transition", "all 0.2s ease");

                            // Interactive hover effects with enhanced visual feedback and smooth transitions
                            cell.on("mouseover", function (e) {
                                // Dim all cells first with smooth transition
                                matrixContainer.selectAll(".matrix-cell")
                                    .transition()
                                    .duration(200)
                                    .style("opacity", 0.3)
                                    .attr("stroke", "var(--primary-border)")
                                    .attr("stroke-width", 0.5);

                                // Highlight current cell with enhanced styling and smooth scaling
                                d3.select(this)
                                    .transition()
                                    .duration(200)
                                    .style("opacity", 1)
                                    .attr("stroke", "var(--accent-cyan)")
                                    .attr("stroke-width", 3)
                                    .attr("filter", "url(#attention-glow)")
                                    .style("transform", "scale(1.1)");

                                // Highlight current row with accent color and smooth transition
                                matrixContainer.selectAll(".matrix-cell")
                                    .filter((d, idx) => Math.floor(idx / sentence.length) === i)
                                    .transition()
                                    .duration(200)
                                    .style("opacity", 0.8)
                                    .attr("stroke", "var(--accent-green)")
                                    .attr("stroke-width", 1.5);

                                // Highlight current column with accent color and smooth transition
                                matrixContainer.selectAll(".matrix-cell")
                                    .filter((d, idx) => idx % sentence.length === j)
                                    .transition()
                                    .duration(200)
                                    .style("opacity", 0.8)
                                    .attr("stroke", "var(--accent-orange)")
                                    .attr("stroke-width", 1.5);

                                // Show detailed tooltip with enhanced styling
                                showTooltip(e, `<b>Attention Weight</b><br>From: "${tokenRow.word}" (${i + 1})<br>To: "${tokenCol.word}" (${j + 1})<br>Weight: ${(attention * 100).toFixed(1)}%<br>Layer: ${attentionLayers[currentLayer].name}`);
                            })
                                .on("mouseout", function () {
                                    // Reset all cells with smooth transition
                                    matrixContainer.selectAll(".matrix-cell")
                                        .transition()
                                        .duration(200)
                                        .style("opacity", 1)
                                        .attr("stroke", "var(--primary-border)")
                                        .attr("stroke-width", 0.5)
                                        .attr("filter", "none")
                                        .style("transform", "scale(1)");
                                    hideTooltip();
                                });

                            // Animated appearance
                            cell.transition()
                                .delay((i + j) * 50)
                                .duration(300)
                                .style("opacity", 1);
                        });
                    });

                    // Add row and column labels
                    sentence.forEach((token, i) => {
                        // Row labels (queries)
                        matrixContainer.append("text")
                            .attr("class", "matrix-label")
                            .attr("x", matrixX - 3)
                            .attr("y", matrixY + i * cellSize + cellSize / 2 + 2)
                            .attr("text-anchor", "end")
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", "8px")
                            .text(token.word);

                        // Column labels (keys)
                        matrixContainer.append("text")
                            .attr("class", "matrix-label")
                            .attr("x", matrixX + i * cellSize + cellSize / 2)
                            .attr("y", matrixY - 3)
                            .attr("text-anchor", "middle")
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", "8px")
                            .text(token.word);
                    });
                }

                // Initial matrix render
                updateMatrix();

                // Dramatic entrance for the entire matrix
                matrixContainer.transition()
                    .duration(1000)
                    .ease(d3.easeBackOut.overshoot(1.2))
                    .style("opacity", 1);

                // Add pulsing border effect
                function pulseMatrix() {
                    matrixContainer.select("rect")
                        .transition()
                        .duration(2000)
                        .attr("stroke-width", 3)
                        .transition()
                        .duration(2000)
                        .attr("stroke-width", 1)
                        .on("end", pulseMatrix);
                }
                setTimeout(pulseMatrix, 1000);
            }

            /** Renders the Epic Agentic Frameworks with sophisticated storytelling visualizations. */
            function renderAgenticViz() {
                renderEcosystemViz();
                renderGanttChartViz();
            }

            /** LangChain: Interactive Chain of Thought Visualization */
            function renderLangChainEpicViz() {
                const container = d3.select("#langchain-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;

                const margin = { top: 20, right: 20, bottom: 20, left: 20 };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // LangChain components in a sequential flow with improved temporal alignment
                const chainSteps = [
                    { name: "Input", icon: "📝", x: width * 0.12, y: height * 0.25, color: "#8338EC" },
                    { name: "Prompt", icon: "🔤", x: width * 0.12, y: height * 0.75, color: "#3A86FF" },
                    { name: "LLM", icon: "🧠", x: width * 0.50, y: height * 0.50, color: "#2EC4B6" },
                    { name: "Parser", icon: "⚙️", x: width * 0.75, y: height * 0.25, color: "#FFB700" },
                    { name: "Tools", icon: "🔧", x: width * 0.75, y: height * 0.75, color: "#FF6B6B" }
                ];

                // Render chain components with staggered animations
                chainSteps.forEach((step, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node")
                        .style("opacity", 0);

                    g.append("circle")
                        .attr("cx", step.x)
                        .attr("cy", step.y)
                        .attr("r", 20)
                        .attr("fill", step.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);

                    g.append("text")
                        .attr("x", step.x)
                        .attr("y", step.y - 2)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .text(step.icon);

                    g.append("text")
                        .attr("x", step.x)
                        .attr("y", step.y + 35)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .text(step.name);

                    g.transition()
                        .delay(i * 400)
                        .duration(800)
                        .ease(d3.easeElasticOut.amplitude(1).period(0.3))
                        .style("opacity", 1);
                });
            }

            /** AutoGen: Multi-Agent Collaboration Visualization */
            function renderAutoGenEpicViz() {
                const container = d3.select("#autogen-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;

                const margin = { top: 20, right: 20, bottom: 20, left: 20 };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // AutoGen agents in conversation pattern with improved temporal alignment
                const agents = [
                    { name: "User", icon: "👤", x: width * 0.15, y: height * 0.25, color: "#8338EC" },
                    { name: "Assistant", icon: "🤖", x: width * 0.50, y: height * 0.15, color: "#2EC4B6" },
                    { name: "Executor", icon: "⚡", x: width * 0.85, y: height * 0.25, color: "#FFB700" },
                    { name: "Critic", icon: "🔍", x: width * 0.50, y: height * 0.65, color: "#FF6B6B" }
                ];

                // Render agents with role-based styling
                agents.forEach((agent, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node")
                        .style("opacity", 0);

                    const circle = g.append("circle")
                        .attr("cx", agent.x)
                        .attr("cy", agent.y)
                        .attr("r", 25)
                        .attr("fill", agent.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);

                    g.append("text")
                        .attr("x", agent.x)
                        .attr("y", agent.y - 2)
                        .attr("text-anchor", "middle")
                        .style("font-size", "16px")
                        .text(agent.icon);

                    g.append("text")
                        .attr("x", agent.x)
                        .attr("y", agent.y + 45)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .text(agent.name);

                    g.transition()
                        .delay(i * 500)
                        .duration(1000)
                        .ease(d3.easeElasticOut.amplitude(1).period(0.4))
                        .style("opacity", 1);

                    // Continuous pulse for active conversation
                    function pulse() {
                        circle.transition()
                            .duration(2000)
                            .attr("r", 30)
                            .transition()
                            .duration(2000)
                            .attr("r", 25)
                            .on("end", pulse);
                    }
                    setTimeout(pulse, i * 500 + 1000);
                });
            }

            /** LangGraph: State-Based Workflow Visualization */
            function renderLangGraphEpicViz() {
                const container = d3.select("#langgraph-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;

                const margin = { top: 20, right: 20, bottom: 20, left: 20 };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // LangGraph state machine nodes with improved temporal flow alignment
                const states = [
                    { name: "Start", icon: "🎯", x: width * 0.15, y: height * 0.50, color: "#8338EC" },
                    { name: "Analyze", icon: "🔍", x: width * 0.35, y: height * 0.25, color: "#3A86FF" },
                    { name: "Execute", icon: "⚡", x: width * 0.55, y: height * 0.25, color: "#2EC4B6" },
                    { name: "Validate", icon: "✅", x: width * 0.55, y: height * 0.75, color: "#FFB700" },
                    { name: "End", icon: "🏁", x: width * 0.85, y: height * 0.50, color: "#FF6B6B" }
                ];

                // Render state nodes with workflow styling
                states.forEach((state, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node")
                        .style("opacity", 0);

                    g.append("rect")
                        .attr("x", state.x - 20)
                        .attr("y", state.y - 15)
                        .attr("width", 40)
                        .attr("height", 30)
                        .attr("rx", 8)
                        .attr("fill", state.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);

                    g.append("text")
                        .attr("x", state.x)
                        .attr("y", state.y - 3)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .text(state.icon);

                    g.append("text")
                        .attr("x", state.x)
                        .attr("y", state.y + 35)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", "9px")
                        .style("font-weight", "600")
                        .text(state.name);

                    g.transition()
                        .delay(i * 400)
                        .duration(800)
                        .ease(d3.easeBackOut.overshoot(1.7))
                        .style("opacity", 1);
                });
            }

            /** Epic Dynamic Model Comparison Table - Jedi Master's Data Analysis! */
            function renderDynamicModelComparison(containerId) {
                const container = d3.select(containerId);
                container.selectAll("*").remove();

                // Model data with comprehensive metrics
                const models = [
                    { name: "GPT-4", provider: "OpenAI", type: "Proprietary", params: "1.76T", cost: "$$$", performance: 95, speed: 60, context: "128k", capabilities: ["Text", "Code", "Vision"] },
                    { name: "Claude-3.5", provider: "Anthropic", type: "Proprietary", params: "200B", cost: "$$", performance: 93, speed: 75, context: "200k", capabilities: ["Text", "Code", "Vision"] },
                    { name: "Llama 3.1", provider: "Meta", type: "Open Source", params: "405B", cost: "$", performance: 88, speed: 85, context: "128k", capabilities: ["Text", "Code"] },
                    { name: "Gemini Pro", provider: "Google", type: "Proprietary", params: "540B", cost: "$$", performance: 92, speed: 70, context: "2M", capabilities: ["Text", "Code", "Vision", "Audio"] },
                    { name: "Mixtral 8x7B", provider: "Mistral", type: "Open Source", params: "56B", cost: "$", performance: 82, speed: 90, context: "32k", capabilities: ["Text", "Code"] },
                    { name: "Command R+", provider: "Cohere", type: "Proprietary", params: "104B", cost: "$$", performance: 85, speed: 80, context: "128k", capabilities: ["Text", "RAG"] }
                ];

                let filteredModels = [...models];
                let sortConfig = { key: null, direction: 'asc' };

                // Create container structure
                const tableContainer = container.append("div")
                    .style("background", "var(--bg-color)")
                    .style("border-radius", "8px")
                    .style("border", "1px solid var(--primary-border)")
                    .style("overflow", "hidden");

                // Create filters section
                const filtersContainer = tableContainer.append("div")
                    .style("padding", "16px")
                    .style("background", "var(--secondary-bg)")
                    .style("border-bottom", "1px solid var(--primary-border)")
                    .style("display", "flex")
                    .style("gap", "16px")
                    .style("align-items", "center")
                    .style("flex-wrap", "wrap");

                filtersContainer.append("span")
                    .style("color", "var(--text-primary)")
                    .style("font-weight", "600")
                    .style("font-size", "14px")
                    .text("🔍 Filter Models:");

                // Type filter
                const typeFilter = filtersContainer.append("select")
                    .style("background", "var(--bg-color)")
                    .style("color", "var(--text-primary)")
                    .style("border", "1px solid var(--primary-border)")
                    .style("border-radius", "4px")
                    .style("padding", "4px 8px")
                    .style("font-size", "12px")
                    .on("change", function () {
                        applyFilters();
                    });

                typeFilter.append("option").attr("value", "").text("All Types");
                typeFilter.append("option").attr("value", "Open Source").text("Open Source");
                typeFilter.append("option").attr("value", "Proprietary").text("Proprietary");

                // Performance filter
                const perfFilter = filtersContainer.append("select")
                    .style("background", "var(--bg-color)")
                    .style("color", "var(--text-primary)")
                    .style("border", "1px solid var(--primary-border)")
                    .style("border-radius", "4px")
                    .style("padding", "4px 8px")
                    .style("font-size", "12px")
                    .on("change", function () {
                        applyFilters();
                    });

                perfFilter.append("option").attr("value", "").text("All Performance");
                perfFilter.append("option").attr("value", "90+").text("High (90+)");
                perfFilter.append("option").attr("value", "80-89").text("Medium (80-89)");
                perfFilter.append("option").attr("value", "80-").text("Budget (<80)");

                // Search box
                const searchBox = filtersContainer.append("input")
                    .attr("type", "text")
                    .attr("placeholder", "🔎 Search models...")
                    .style("background", "var(--bg-color)")
                    .style("color", "var(--text-primary)")
                    .style("border", "1px solid var(--primary-border)")
                    .style("border-radius", "4px")
                    .style("padding", "4px 8px")
                    .style("font-size", "12px")
                    .style("min-width", "150px")
                    .on("input", function () {
                        applyFilters();
                    });

                // Table container
                const tableDiv = tableContainer.append("div")
                    .style("overflow-x", "auto");

                function applyFilters() {
                    const typeValue = typeFilter.node().value;
                    const perfValue = perfFilter.node().value;
                    const searchValue = searchBox.node().value.toLowerCase();

                    filteredModels = models.filter(model => {
                        let passesType = !typeValue || model.type === typeValue;
                        let passesPerf = !perfValue ||
                            (perfValue === "90+" && model.performance >= 90) ||
                            (perfValue === "80-89" && model.performance >= 80 && model.performance < 90) ||
                            (perfValue === "80-" && model.performance < 80);
                        let passesSearch = !searchValue ||
                            model.name.toLowerCase().includes(searchValue) ||
                            model.provider.toLowerCase().includes(searchValue);

                        return passesType && passesPerf && passesSearch;
                    });

                    renderTable();
                }

                function sortBy(key) {
                    if (sortConfig.key === key) {
                        sortConfig.direction = sortConfig.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortConfig.key = key;
                        sortConfig.direction = 'asc';
                    }

                    filteredModels.sort((a, b) => {
                        let aVal = a[key];
                        let bVal = b[key];

                        if (typeof aVal === 'string') {
                            aVal = aVal.toLowerCase();
                            bVal = bVal.toLowerCase();
                        }

                        if (aVal < bVal) return sortConfig.direction === 'asc' ? -1 : 1;
                        if (aVal > bVal) return sortConfig.direction === 'asc' ? 1 : -1;
                        return 0;
                    });

                    renderTable();
                }

                function renderTable() {
                    tableDiv.selectAll("*").remove();

                    const table = tableDiv.append("table")
                        .style("width", "100%")
                        .style("border-collapse", "collapse")
                        .style("font-size", "12px");

                    // Header
                    const headers = [
                        { key: 'name', label: '🤖 Model', width: '15%' },
                        { key: 'provider', label: '🏢 Provider', width: '12%' },
                        { key: 'type', label: '📋 Type', width: '12%' },
                        { key: 'params', label: '⚙️ Parameters', width: '12%' },
                        { key: 'performance', label: '📊 Performance', width: '12%' },
                        { key: 'speed', label: '⚡ Speed', width: '10%' },
                        { key: 'cost', label: '💰 Cost', width: '8%' },
                        { key: 'context', label: '📄 Context', width: '10%' },
                        { key: 'capabilities', label: '🎯 Capabilities', width: '19%' }
                    ];

                    const headerRow = table.append("thead").append("tr")
                        .style("background", "var(--secondary-bg)")
                        .style("border-bottom", "2px solid var(--accent-cyan)");

                    headers.forEach(header => {
                        const th = headerRow.append("th")
                            .style("padding", "12px 8px")
                            .style("text-align", "left")
                            .style("font-weight", "600")
                            .style("color", "var(--text-primary)")
                            .style("cursor", "pointer")
                            .style("user-select", "none")
                            .style("width", header.width)
                            .style("position", "relative")
                            .text(header.label)
                            .on("click", () => sortBy(header.key))
                            .on("mouseover", function () {
                                d3.select(this).style("background", "var(--primary-border)");
                            })
                            .on("mouseout", function () {
                                d3.select(this).style("background", "var(--secondary-bg)");
                            });

                        if (sortConfig.key === header.key) {
                            th.append("span")
                                .style("position", "absolute")
                                .style("right", "8px")
                                .style("color", "var(--accent-cyan)")
                                .text(sortConfig.direction === 'asc' ? '↑' : '↓');
                        }
                    });

                    // Body
                    const tbody = table.append("tbody");

                    filteredModels.forEach((model, i) => {
                        const row = tbody.append("tr")
                            .style("border-bottom", "1px solid var(--primary-border)")
                            .style("transition", "all 0.2s ease")
                            .on("mouseover", function () {
                                d3.select(this).style("background", "var(--secondary-bg)");
                            })
                            .on("mouseout", function () {
                                d3.select(this).style("background", "transparent");
                            });

                        // Model name with ranking badge
                        const nameCell = row.append("td").style("padding", "10px 8px");
                        nameCell.append("span")
                            .style("display", "inline-block")
                            .style("background", "var(--accent-cyan)")
                            .style("color", "white")
                            .style("border-radius", "50%")
                            .style("width", "20px")
                            .style("height", "20px")
                            .style("text-align", "center")
                            .style("line-height", "20px")
                            .style("font-size", "10px")
                            .style("font-weight", "600")
                            .style("margin-right", "8px")
                            .text(i + 1);
                        nameCell.append("span")
                            .style("color", "var(--text-primary)")
                            .style("font-weight", "600")
                            .text(model.name);

                        // Provider
                        row.append("td")
                            .style("padding", "10px 8px")
                            .style("color", "var(--text-secondary)")
                            .text(model.provider);

                        // Type with badge
                        const typeCell = row.append("td").style("padding", "10px 8px");
                        typeCell.append("span")
                            .style("background", model.type === "Open Source" ? "var(--accent-green)" : "var(--accent-purple)")
                            .style("color", "white")
                            .style("padding", "2px 8px")
                            .style("border-radius", "12px")
                            .style("font-size", "10px")
                            .style("font-weight", "600")
                            .text(model.type);

                        // Parameters
                        row.append("td")
                            .style("padding", "10px 8px")
                            .style("color", "var(--text-secondary)")
                            .style("font-family", "monospace")
                            .text(model.params);

                        // Performance with bar
                        const perfCell = row.append("td").style("padding", "10px 8px");
                        const perfBar = perfCell.append("div")
                            .style("position", "relative")
                            .style("background", "var(--primary-border)")
                            .style("height", "16px")
                            .style("border-radius", "8px")
                            .style("overflow", "hidden");

                        perfBar.append("div")
                            .style("background", `linear-gradient(90deg, ${model.performance >= 90 ? '#2EC4B6' : model.performance >= 80 ? '#FFB700' : '#FF6B6B'}, ${model.performance >= 90 ? '#34D399' : model.performance >= 80 ? '#FCD34D' : '#F87171'})`)
                            .style("height", "100%")
                            .style("width", "0%")
                            .style("transition", "width 1s ease")
                            .style("border-radius", "8px");

                        perfCell.append("span")
                            .style("position", "absolute")
                            .style("right", "4px")
                            .style("top", "50%")
                            .style("transform", "translateY(-50%)")
                            .style("color", "var(--text-primary)")
                            .style("font-size", "10px")
                            .style("font-weight", "600")
                            .text(model.performance);

                        // Animate performance bar
                        setTimeout(() => {
                            perfBar.select("div").style("width", `${model.performance}%`);
                        }, i * 100);

                        // Speed
                        row.append("td")
                            .style("padding", "10px 8px")
                            .style("color", "var(--text-secondary)")
                            .text(model.speed);

                        // Cost
                        row.append("td")
                            .style("padding", "10px 8px")
                            .style("color", model.cost === "$$$" ? "var(--accent-red)" : model.cost === "$$" ? "var(--accent-orange)" : "var(--accent-green)")
                            .style("font-weight", "600")
                            .text(model.cost);

                        // Context
                        row.append("td")
                            .style("padding", "10px 8px")
                            .style("color", "var(--text-secondary)")
                            .style("font-family", "monospace")
                            .text(model.context);

                        // Capabilities with badges
                        const capCell = row.append("td").style("padding", "10px 8px");
                        model.capabilities.forEach(cap => {
                            capCell.append("span")
                                .style("background", "var(--secondary-bg)")
                                .style("color", "var(--text-primary)")
                                .style("padding", "2px 6px")
                                .style("border-radius", "8px")
                                .style("font-size", "9px")
                                .style("margin-right", "4px")
                                .style("margin-bottom", "2px")
                                .style("display", "inline-block")
                                .text(cap);
                        });
                    });

                    // Results counter
                    if (filteredModels.length !== models.length) {
                        tableContainer.select(".results-counter").remove();
                        tableContainer.append("div")
                            .attr("class", "results-counter")
                            .style("padding", "8px 16px")
                            .style("background", "var(--secondary-bg)")
                            .style("border-top", "1px solid var(--primary-border)")
                            .style("color", "var(--text-secondary)")
                            .style("font-size", "12px")
                            .text(`Showing ${filteredModels.length} of ${models.length} models`);
                    }
                }

                // Initial render
                renderTable();
            }

            /** Renders the MLOps/LLMOps continuous loop diagram. */
            function renderMlopsViz() {
                const container = d3.select("#mlops-viz"); container.selectAll("*").remove(); const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 20, right: 20, bottom: 20, left: 20 }, width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
                const radius = Math.min(width, height) / 4.5; const centerX = width / 2; const centerY = height / 2;
                const stages = [{ label: "Data Mgmt", tooltip: "Collect, version, and validate datasets for training and evaluation." }, { label: "Model Training", tooltip: "Automate training runs, track experiments, and version models." }, { label: "Deployment", tooltip: "Package and deploy models to production endpoints with CI/CD." }, { label: "Monitoring", tooltip: "Track model performance, drift, and data quality in real-time." }];
                const angleStep = (2 * Math.PI) / stages.length;
                const points = stages.map((d, i) => ({ x: centerX + radius * Math.cos(i * angleStep - Math.PI / 2), y: centerY + radius * Math.sin(i * angleStep - Math.PI / 2), ...d }));
                svg.append("path").attr("d", d3.line().x(d => d.x).y(d => d.y).curve(d3.curveCatmullRomClosed)([...points, points[0]])).attr("stroke", "var(--accent-green)").attr("stroke-width", 4).attr("fill", "none").attr("stroke-dasharray", "8,4");
                points.forEach((p, i) => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, p.tooltip)).on("mouseout", hideTooltip);
                    g.append("circle").attr("cx", p.x).attr("cy", p.y).attr("r", 10).attr("fill", "var(--accent-green)");
                    g.append("text").attr("x", p.x).attr("y", p.y).attr("text-anchor", "middle").attr("dy", ".3em").attr("fill", "var(--bg-color)").style("font-size", "12px").text(i + 1);
                    svg.append("text").attr("x", centerX + (radius + 65) * Math.cos(i * angleStep - Math.PI / 2)).attr("y", centerY + (radius + 85) * Math.sin(i * angleStep - Math.PI / 2) + 5).attr("text-anchor", "middle").attr("class", "text-primary").style("font-size", "14px").text(p.label);
                });
                svg.append("text").attr("x", centerX).attr("y", centerY).attr("text-anchor", "right").attr("class", "text-secondary").style("font-size", "14px").text("Continuous Loop").call(wrap, 90);
            }

            /** Renders the RAG workflow diagram. */
            /** Renders the RAG Pipeline with competition-level visual sophistication. */
            function renderRagViz() {
                const container = d3.select("#rag-viz"); container.selectAll("*").remove(); const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 50, right: 40, bottom: 60, left: 40 }, width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions
                const defs = svg.append("defs");
                const componentGradients = [
                    { id: "query-grad", colors: ["#8338EC", "#A855F7"] },
                    { id: "vector-grad", colors: ["#2EC4B6", "#34D399"] },
                    { id: "retrieval-grad", colors: ["#3A86FF", "#60A5FA"] },
                    { id: "augment-grad", colors: ["#FFB700", "#FCD34D"] },
                    { id: "llm-grad", colors: ["#FF6B6B", "#F87171"] },
                    { id: "response-grad", colors: ["#00A6FB", "#0EA5E9"] }
                ];

                componentGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                arrowMarker(svg, "arrow-rag", "#2EC4B6");
                arrowMarker(svg, "arrow-flow", "#3A86FF");

                // Responsive component positioning with collision detection
                const minSpacing = 20; // Minimum spacing between components
                const componentWidths = [110, 120, 120, 130, 130, 120];
                const componentHeights = [60, 70, 70, 70, 80, 65];
                
                // Calculate responsive positions based on available width
                const availableWidth = width - (margin.left + margin.right);
                const totalComponentWidth = componentWidths.reduce((sum, w) => sum + w, 0);
                const totalSpacing = (componentWidths.length - 1) * minSpacing;
                const scaleFactor = Math.min(1, (availableWidth - totalSpacing) / totalComponentWidth);
                
                // Enhanced responsive positioning with improved alignment and consistent spacing
                const positions = [];
                const basePositions = [
                    { x: width * 0.08, y: height * 0.25 },
                    { x: width * 0.25, y: height * 0.20 },
                    { x: width * 0.25, y: height * 0.50 },
                    { x: width * 0.50, y: height * 0.35 },
                    { x: width * 0.75, y: height * 0.50 },
                    { x: width * 0.92, y: height * 0.75 }
                ];
                
                // Apply collision detection and minimum spacing constraints
                basePositions.forEach((pos, index) => {
                    let adjustedX = pos.x;
                    let adjustedY = pos.y;
                    
                    // Ensure minimum spacing from previous components
                    if (index > 0) {
                        const prevPos = positions[index - 1];
                        const minXDistance = (componentWidths[index] + componentWidths[index - 1]) / 2 + minSpacing;
                        const minYDistance = (componentHeights[index] + componentHeights[index - 1]) / 2 + minSpacing;
                        
                        // Check for horizontal collision
                        if (Math.abs(adjustedX - prevPos.x) < minXDistance) {
                            adjustedX = prevPos.x + minXDistance;
                        }
                        
                        // Check for vertical collision
                        if (Math.abs(adjustedY - prevPos.y) < minYDistance) {
                            adjustedY = prevPos.y + minYDistance;
                        }
                    }
                    
                    // Ensure components stay within bounds
                    adjustedX = Math.max(componentWidths[index] / 2 + 10, Math.min(adjustedX, width - componentWidths[index] / 2 - 10));
                    adjustedY = Math.max(componentHeights[index] / 2 + 10, Math.min(adjustedY, height - componentHeights[index] / 2 - 10));
                    
                    positions.push({ x: adjustedX, y: adjustedY });
                });

                // Enhanced RAG components with responsive performance metrics
                const components = [
                    { name: "User Query", shortName: "Query", x: positions[0].x, y: positions[0].y, icon: "🤔", gradient: "url(#query-grad)", performance: 100, tooltip: "<b>User Query Input</b><br>Natural language question that initiates the RAG pipeline. Includes query preprocessing, entity extraction, and semantic analysis for optimal retrieval.", width: componentWidths[0] * scaleFactor, height: componentHeights[0] * scaleFactor },
                    { name: "Vector Database", shortName: "Vector DB", x: positions[1].x, y: positions[1].y, icon: "🗄️", gradient: "url(#vector-grad)", performance: 95, tooltip: "<b>Vector Database</b><br>High-dimensional embedding storage using ANN search. Implements HNSW, IVF algorithms for sub-linear retrieval with cosine similarity metrics.", width: componentWidths[1] * scaleFactor, height: componentHeights[1] * scaleFactor },
                    { name: "Semantic Retrieval", shortName: "Retrieval", x: positions[2].x, y: positions[2].y, icon: "🔍", gradient: "url(#retrieval-grad)", performance: 92, tooltip: "<b>Semantic Retrieval</b><br>Hybrid search combining dense and sparse vectors. Implements reranking, query expansion, and contextual filtering with relevance scoring.", width: componentWidths[2] * scaleFactor, height: componentHeights[2] * scaleFactor },
                    { name: "Context Augmentation", shortName: "Augment", x: positions[3].x, y: positions[3].y, icon: "🔗", gradient: "url(#augment-grad)", performance: 88, tooltip: "<b>Context Augmentation</b><br>Intelligent prompt construction with context integration, token optimization, and relevance weighting for coherent generation.", width: componentWidths[3] * scaleFactor, height: componentHeights[3] * scaleFactor },
                    { name: "Large Language Model", shortName: "LLM", x: positions[4].x, y: positions[4].y, icon: "🧠", gradient: "url(#llm-grad)", performance: 97, tooltip: "<b>Large Language Model</b><br>Foundation model that generates responses using augmented context. Applies reasoning and factual grounding with controlled sampling.", width: componentWidths[4] * scaleFactor, height: componentHeights[4] * scaleFactor },
                    { name: "Final Response", shortName: "Response", x: positions[5].x, y: positions[5].y, icon: "💬", gradient: "url(#response-grad)", performance: 94, tooltip: "<b>Response Generation</b><br>Contextually grounded answer with source attribution and confidence scoring. Includes hallucination detection and quality assurance.", width: componentWidths[5] * scaleFactor, height: componentHeights[5] * scaleFactor }
                ];

                // Render enhanced components
                components.forEach(comp => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, comp.tooltip)).on("mouseout", hideTooltip);

                    // Component shadow
                    g.append("rect").attr("x", comp.x - comp.width / 2 + 3).attr("y", comp.y - comp.height / 2 + 3).attr("width", comp.width).attr("height", comp.height).attr("fill", "rgba(0,0,0,0.15)").attr("rx", 10);

                    // Performance ring with enhanced containment and overlap detection
                    const componentWidth = comp.width;
                    const componentHeight = comp.height;
                    const maxRingRadius = Math.min(componentWidth, componentHeight) / 2 - 12; // Enhanced containment margin
                    const ringRadius = Math.min(16, maxRingRadius); // Smaller for better containment
                    
                    // Ensure ring doesn't overlap with adjacent components
                    const minDistanceToEdge = 8;
                    const effectiveRingRadius = Math.min(ringRadius, 
                        Math.min(componentWidth / 2 - minDistanceToEdge, componentHeight / 2 - minDistanceToEdge)
                    );
                    const circumference = 2 * Math.PI * effectiveRingRadius;
                    const performanceOffset = circumference - (comp.performance / 100) * circumference;
                    
                    // Background ring with enhanced containment
                    g.append("circle")
                        .attr("cx", comp.x)
                        .attr("cy", comp.y)
                        .attr("r", effectiveRingRadius)
                        .attr("fill", "none")
                        .attr("stroke", "rgba(46, 196, 182, 0.2)")
                        .attr("stroke-width", 3);
                    
                    // Performance ring with gradient and containment
                    g.append("circle")
                        .attr("cx", comp.x)
                        .attr("cy", comp.y)
                        .attr("r", effectiveRingRadius)
                        .attr("fill", "none")
                        .attr("stroke", "#2EC4B6")
                        .attr("stroke-width", 3)
                        .attr("stroke-dasharray", circumference)
                        .attr("stroke-dashoffset", performanceOffset)
                        .style("stroke-linecap", "round");

                    // Main component
                    g.append("rect").attr("x", comp.x - comp.width / 2).attr("y", comp.y - comp.height / 2).attr("width", comp.width).attr("height", comp.height).attr("fill", comp.gradient).attr("stroke", "white").attr("stroke-width", 2.5).attr("rx", 10).style("filter", "drop-shadow(0px 3px 8px rgba(0,0,0,0.3))");

                    // Icon and text
                    g.append("text").attr("x", comp.x - comp.width / 2 + 20).attr("y", comp.y - 12).attr("text-anchor", "middle").style("font-size", "24px").text(comp.icon);
                    g.append("text").attr("x", comp.x).attr("y", comp.y - 8).attr("text-anchor", "middle").attr("fill", "white").style("font-weight", "bold").style("font-size", "14px").text(comp.shortName);
                    g.append("text").attr("x", comp.x).attr("y", comp.y + 10).attr("text-anchor", "middle").attr("fill", "rgba(255,255,255,0.9)").style("font-size", "10px").text(comp.name);
                    g.append("text").attr("x", comp.x).attr("y", comp.y + comp.height / 2 + 25).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "10px").style("font-weight", "600").text(`${comp.performance}% efficiency`);
                });

                // Enhanced data flow connections with adaptive routing
                const connections = [{ from: 0, to: 1, label: "Query Embedding", latency: "5ms" }, { from: 1, to: 2, label: "Vector Search", latency: "15ms" }, { from: 2, to: 3, label: "Context Ranking", latency: "8ms" }, { from: 3, to: 4, label: "Augmented Prompt", latency: "200ms" }, { from: 4, to: 5, label: "Generated Text", latency: "50ms" }];

                connections.forEach(conn => {
                    const source = components[conn.from]; const target = components[conn.to];
                    const dx = target.x - source.x; const dy = target.y - source.y; const distance = Math.sqrt(dx * dx + dy * dy);
                    const unitX = dx / distance; const unitY = dy / distance;
                    const startX = source.x + unitX * (source.width / 2 + 5); const startY = source.y + unitY * (source.height / 2 + 5);
                    const endX = target.x - unitX * (target.width / 2 + 5); const endY = target.y - unitY * (target.height / 2 + 5);
                    const midX = (startX + endX) / 2; const midY = (startY + endY) / 2;
                    
                    // Adaptive control offset based on available space
                    const adaptiveControlOffset = Math.min(30, Math.max(15, distance * 0.15));
                    const controlX = midX + (target.y > source.y ? adaptiveControlOffset : -adaptiveControlOffset);
                    const controlY = midY + (target.x > source.x ? -adaptiveControlOffset : adaptiveControlOffset);

                    for (let j = 0; j < 3; j++) {
                        const pathOffset = (j - 1) * 3; 
                        const strokeWidth = 4 - j; 
                        const opacity = j === 0 ? 0.9 : j === 1 ? 0.7 : 0.5; // Standardized opacity encoding
                        svg.append("path").attr("d", `M ${startX + pathOffset} ${startY} Q ${controlX + pathOffset} ${controlY} ${endX + pathOffset} ${endY}`).attr("stroke", j === 0 ? "#2EC4B6" : "#3A86FF").attr("stroke-width", strokeWidth).attr("stroke-opacity", opacity).attr("fill", "none").attr("marker-end", j === 0 ? "url(#arrow-rag)" : "none").attr("stroke-dasharray", j > 0 ? "6,6" : "none");
                    }

                    // Smart label positioning with dynamic width calculation
                    const labelX = (startX + endX) / 2; const labelY = (startY + endY) / 2 - 15;
                    const labelWidth = Math.max(conn.label.length * 7, 60); // Minimum width for readability
                    const labelHeight = 16;
                    
                    // Ensure label doesn't overlap with components
                    const labelLeft = Math.max(10, labelX - labelWidth / 2 - 5);
                    const labelRight = Math.min(width - 10, labelX + labelWidth / 2 + 5);
                    const adjustedLabelX = (labelLeft + labelRight) / 2;
                    
                    svg.append("rect")
                        .attr("x", adjustedLabelX - labelWidth / 2)
                        .attr("y", labelY - 10)
                        .attr("width", labelWidth)
                        .attr("height", labelHeight)
                        .attr("fill", "rgba(13, 27, 42, 0.9)")
                        .attr("rx", 8)
                        .attr("stroke", "#2EC4B6")
                        .attr("stroke-width", 1);
                    svg.append("text")
                        .attr("x", adjustedLabelX)
                        .attr("y", labelY)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#2EC4B6")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(conn.label);
                    svg.append("text")
                        .attr("x", adjustedLabelX)
                        .attr("y", labelY + 20)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "8px")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(conn.latency);
                });

                // Smart metrics panel positioning with collision detection
                const metricsPanelWidth = 180;
                const metricsPanelHeight = 120;
                const rightmostComponent = Math.max(...components.map(c => c.x + c.width / 2));
                const metricsX = Math.max(rightmostComponent + 20, width - metricsPanelWidth - 10);
                const metricsY = 20;
                
                // Ensure metrics panel doesn't exceed bounds
                const adjustedMetricsX = Math.min(metricsX, width - metricsPanelWidth - 10);
                
                svg.append("text")
                    .attr("x", adjustedMetricsX)
                    .attr("y", metricsY)
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "600")
                    .style("font-size", "14px")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("RAG Performance");
                    
                const metrics = [
                    { label: "Retrieval Accuracy", value: "94.2%", color: "#2EC4B6" },
                    { label: "Context Relevance", value: "91.8%", color: "#3A86FF" },
                    { label: "Response Quality", value: "96.5%", color: "#8338EC" },
                    { label: "End-to-End Latency", value: "278ms", color: "#FFB700" }
                ];
                
                metrics.forEach((metric, i) => {
                    const y = metricsY + 20 + (i * 20);
                    svg.append("circle")
                        .attr("cx", adjustedMetricsX)
                        .attr("cy", y)
                        .attr("r", 4)
                        .attr("fill", metric.color);
                    svg.append("text")
                        .attr("x", adjustedMetricsX + 12)
                        .attr("y", y + 3)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(`${metric.label}: ${metric.value}`);
                });

                svg.append("text").attr("x", width / 2).attr("y", -25).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "700").style("font-size", "18px").text("Retrieval-Augmented Generation Pipeline");
                svg.append("text").attr("x", width / 2).attr("y", height + 35).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").text("Hybrid retrieval with semantic search, context optimization, and grounded response generation");

                const ragCode = document.getElementById('rag-code');
                if (ragCode) ragCode.innerHTML = `<pre><code><span class="token comment"># Advanced RAG Implementation</span>\n<span class="token keyword">async def</span> <span class="token function">enhanced_rag_pipeline</span>(<span class="token parameter">query: str, vector_db: VectorDB, llm: LLM</span>):\n    <span class="token comment"># 1. Query preprocessing and embedding</span>\n    query_embedding = <span class="token keyword">await</span> embed_query(query)\n    \n    <span class="token comment"># 2. Hybrid retrieval (dense + sparse)</span>\n    dense_results = vector_db.<span class="token function">similarity_search</span>(query_embedding, k=<span class="token number">10</span>)\n    sparse_results = vector_db.<span class="token function">keyword_search</span>(query, k=<span class="token number">5</span>)\n    \n    <span class="token comment"># 3. Reranking and context optimization</span>\n    contexts = <span class="token function">rerank_contexts</span>(dense_results + sparse_results, query)\n    optimized_context = <span class="token function">optimize_context_window</span>(contexts, max_tokens=<span class="token number">4000</span>)\n    \n    <span class="token comment"># 4. Augmented generation with safety checks</span>\n    augmented_prompt = <span class="token function">construct_prompt</span>(query, optimized_context)\n    response = <span class="token keyword">await</span> llm.<span class="token function">generate</span>(augmented_prompt, temperature=<span class="token number">0.1</span>)\n    \n    <span class="token comment"># 5. Response validation and source attribution</span>\n    <span class="token keyword">return</span> <span class="token function">validate_and_attribute</span>(response, contexts)</code></pre>`;
            }

            /** Renders the Vector Database comparison with advanced 3D similarity space visualization. */
            function renderVectorDbViz() {
                const container = d3.select("#vector-db-viz"); container.selectAll("*").remove(); const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 50, right: 40, bottom: 60, left: 40 };
                const width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for semantic clustering
                const defs = svg.append("defs");
                const clusterGradients = [
                    { id: "retriever-cluster", colors: ["#FFB700", "#FCD34D"] },
                    { id: "working-cluster", colors: ["#3A86FF", "#60A5FA"] },
                    { id: "toy-cluster", colors: ["#8338EC", "#A855F7"] },
                    { id: "query-gradient", colors: ["#FF6B6B", "#F87171"] }
                ];

                clusterGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                arrowMarker(svg, "arrow-similarity", "#FF6B6B");

                // Enhanced responsive split view with collision detection and adaptive sizing
                const minSectionWidth = 180; // Reduced minimum width for better mobile support
                const availableWidth = width - 40; // Account for margins
                const dividerSpacing = 20; // Space between sections
                
                // Calculate optimal section widths with collision detection
                let leftWidth = Math.max(minSectionWidth, availableWidth * 0.45);
                let rightWidth = Math.max(minSectionWidth, availableWidth * 0.45);
                
                // Ensure sections don't overlap and fit within available space
                const totalRequiredWidth = leftWidth + rightWidth + dividerSpacing;
                if (totalRequiredWidth > availableWidth) {
                    const scaleFactor = (availableWidth - dividerSpacing) / (leftWidth + rightWidth);
                    leftWidth *= scaleFactor;
                    rightWidth *= scaleFactor;
                }
                
                const dividerX = leftWidth + dividerSpacing / 2;

                // Traditional Database Section
                svg.append("rect").attr("x", 0).attr("y", 0).attr("width", leftWidth).attr("height", height).attr("fill", "rgba(142, 142, 147, 0.05)").attr("stroke", "#8E8E93").attr("stroke-width", 2).attr("stroke-dasharray", "8,4").attr("rx", 12);
                svg.append("text").attr("x", leftWidth / 2).attr("y", 25).attr("text-anchor", "middle").attr("fill", "#8E8E93").style("font-weight", "700").style("font-size", "16px").text("Traditional Database");
                svg.append("text").attr("x", leftWidth / 2).attr("y", 45).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").text("Exact keyword matching only");

                // Traditional database entries
                const traditionalData = [
                    { id: "101", name: "Fido", breed: "Golden Retriever", match: true },
                    { id: "102", name: "Lucy", breed: "Poodle", match: false },
                    { id: "103", name: "Max", breed: "German Shepherd", match: false },
                    { id: "104", name: "Bella", breed: "Labrador", match: false },
                    { id: "105", name: "Charlie", breed: "Golden Retriever", match: true }
                ];

                // Dynamic row layout with overflow protection
                const rowHeight = 35;
                const rowSpacing = 10;
                const startY = 70;
                const maxRows = Math.floor((height - startY - 30) / (rowHeight + rowSpacing));
                const visibleData = traditionalData.slice(0, maxRows);
                
                visibleData.forEach((dog, i) => {
                    const y = startY + (i * (rowHeight + rowSpacing));
                    const rowColor = dog.match ? "rgba(46, 196, 182, 0.2)" : "rgba(142, 142, 147, 0.1)";
                    svg.append("rect")
                        .attr("x", 10)
                        .attr("y", y)
                        .attr("width", leftWidth - 20)
                        .attr("height", rowHeight)
                        .attr("fill", rowColor)
                        .attr("stroke", dog.match ? "#2EC4B6" : "#8E8E93")
                        .attr("stroke-width", 1)
                        .attr("rx", 4);
                    svg.append("text")
                        .attr("x", 20)
                        .attr("y", y + 15)
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", "11px")
                        .style("font-weight", "600")
                        .text(dog.id);
                    svg.append("text")
                        .attr("x", 20)
                        .attr("y", y + 28)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(dog.name);
                    svg.append("text")
                        .attr("x", leftWidth / 2 - 10)
                        .attr("y", y + 22)
                        .attr("fill", dog.match ? "#2EC4B6" : "var(--text-secondary)")
                        .style("font-size", "11px")
                        .style("font-weight", dog.match ? "700" : "normal")
                        .text(dog.breed);
                    if (dog.match) {
                        svg.append("circle")
                            .attr("cx", leftWidth - 30)
                            .attr("cy", y + 17)
                            .attr("r", 6)
                            .attr("fill", "#2EC4B6");
                        svg.append("text")
                            .attr("x", leftWidth - 30)
                            .attr("y", y + 21)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", "10px")
                            .text("✓");
                    }
                });

                svg.append("text").attr("x", leftWidth / 2).attr("y", height - 15).attr("text-anchor", "middle").attr("fill", "#8E8E93").style("font-size", "12px").style("font-weight", "600").text("Query: 'Golden Retriever' → 2 exact matches");

                // Divider line
                svg.append("line").attr("x1", dividerX).attr("y1", 0).attr("x2", dividerX).attr("y2", height).attr("stroke", "var(--secondary-border)").attr("stroke-width", 2).attr("stroke-dasharray", "6,6");

                // Vector Database Section
                const vectorX = dividerX + 30; const vectorWidth = rightWidth - 30;
                svg.append("rect").attr("x", vectorX).attr("y", 0).attr("width", vectorWidth).attr("height", height).attr("fill", "rgba(46, 196, 182, 0.02)").attr("stroke", "#2EC4B6").attr("stroke-width", 2).attr("stroke-dasharray", "8,4").attr("rx", 12);
                svg.append("text").attr("x", vectorX + vectorWidth / 2).attr("y", 25).attr("text-anchor", "middle").attr("fill", "#2EC4B6").style("font-weight", "700").style("font-size", "16px").text("Vector Database");
                svg.append("text").attr("x", vectorX + vectorWidth / 2).attr("y", 45).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").text("Semantic similarity search");

                // Enhanced vector space with adaptive ring scaling
                const centerX = vectorX + vectorWidth / 2; 
                const centerY = height / 2 + 20; 
                const spaceRadius = Math.min(vectorWidth * 0.4, (height - 100) * 0.3); // Adaptive scaling
                const queryPoint = { x: centerX, y: centerY, cluster: "query", similarity: 1.0, label: "Golden Retriever Query" };

                // Semantic similarity points with smart label positioning and collision detection
                const vectorPoints = [
                    { x: centerX - 15, y: centerY - 20, cluster: "retriever", similarity: 0.95, label: "Labrador", tooltip: "<b>Labrador</b><br>Similarity: 95%<br>Cluster: Retrievers" },
                    { x: centerX + 18, y: centerY - 25, cluster: "retriever", similarity: 0.92, label: "Goldendoodle", tooltip: "<b>Goldendoodle</b><br>Similarity: 92%<br>Cross-breed match" },
                    { x: centerX - 60, y: centerY - 45, cluster: "working", similarity: 0.72, label: "German Shepherd", tooltip: "<b>German Shepherd</b><br>Similarity: 72%<br>Working Dogs" },
                    { x: centerX + 55, y: centerY + 40, cluster: "working", similarity: 0.58, label: "Border Collie", tooltip: "<b>Border Collie</b><br>Similarity: 58%<br>Herding breed" },
                    { x: centerX - 45, y: centerY + 60, cluster: "toy", similarity: 0.35, label: "Poodle", tooltip: "<b>Poodle</b><br>Similarity: 35%<br>Different characteristics" }
                ];
                
                // Smart label positioning function with collision detection
                function getSmartLabelPosition(point, labelText) {
                    const labelWidth = labelText.length * 6; // Approximate text width
                    const labelHeight = 12;
                    const margin = 5;
                    
                    // Calculate potential positions (top, bottom, left, right)
                    const positions = [
                        { x: point.x, y: point.y - 15, anchor: "middle" }, // Top
                        { x: point.x, y: point.y + 20, anchor: "middle" }, // Bottom
                        { x: point.x - labelWidth / 2 - 8, y: point.y, anchor: "end" }, // Left
                        { x: point.x + labelWidth / 2 + 8, y: point.y, anchor: "start" } // Right
                    ];
                    
                    // Find position that doesn't exceed section boundaries
                    for (const pos of positions) {
                        const withinBounds = pos.x >= vectorX + margin && 
                                           pos.x <= vectorX + vectorWidth - margin &&
                                           pos.y >= margin && 
                                           pos.y <= height - margin;
                        if (withinBounds) {
                            return pos;
                        }
                    }
                    
                    // Fallback to top position with boundary adjustment
                    return {
                        x: Math.max(vectorX + margin, Math.min(vectorX + vectorWidth - margin, point.x)),
                        y: Math.max(margin, point.y - 15),
                        anchor: "middle"
                    };
                }

                // Adaptive similarity rings with responsive scaling
                [0.4, 0.7, 1.0].forEach((r, i) => {
                    const ringColor = i === 0 ? "#2EC4B6" : i === 1 ? "#3A86FF" : "#8E8E93";
                    const ringRadius = spaceRadius * r;
                    svg.append("circle")
                        .attr("cx", centerX)
                        .attr("cy", centerY)
                        .attr("r", ringRadius)
                        .attr("fill", "none")
                        .attr("stroke", ringColor)
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "6,6")
                        .attr("opacity", 0.3);
                });

                // Render vector points with enhanced smart label positioning
                vectorPoints.forEach(point => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, point.tooltip)).on("mouseout", hideTooltip);
                    g.append("circle").attr("cx", point.x).attr("cy", point.y).attr("r", 8 + point.similarity * 6).attr("fill", `url(#${point.cluster}-cluster)`).attr("opacity", 0.3);
                    g.append("circle").attr("cx", point.x).attr("cy", point.y).attr("r", 4 + point.similarity * 3).attr("fill", `url(#${point.cluster}-cluster)`).attr("stroke", "white").attr("stroke-width", 1.5);
                    
                    // Use smart label positioning function for collision detection
                    const labelPos = getSmartLabelPosition(point, point.label);
                    const similarityPos = getSmartLabelPosition(point, `${(point.similarity * 100).toFixed(0)}%`);
                    
                    g.append("text")
                        .attr("x", labelPos.x)
                        .attr("y", labelPos.y)
                        .attr("text-anchor", labelPos.anchor)
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", "9px")
                        .style("font-weight", "600")
                        .text(point.label);
                    g.append("text")
                        .attr("x", similarityPos.x)
                        .attr("y", similarityPos.y + 12)
                        .attr("text-anchor", similarityPos.anchor)
                        .attr("fill", `url(#${point.cluster}-cluster)`)
                        .style("font-size", "8px")
                        .text(`${(point.similarity * 100).toFixed(0)}%`);
                        
                    if (point.similarity > 0.8) {
                        svg.append("line")
                            .attr("x1", queryPoint.x)
                            .attr("y1", queryPoint.y)
                            .attr("x2", point.x)
                            .attr("y2", point.y)
                            .attr("stroke", "#FF6B6B")
                            .attr("stroke-width", 2)
                            .attr("stroke-dasharray", "3,3")
                            .attr("opacity", point.similarity)
                            .attr("marker-end", "url(#arrow-similarity)");
                    }
                });

                // Enhanced query point with flexible label positioning
                const queryG = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, "<b>Query Vector</b><br>Golden Retriever embedding<br>768-dimensional representation")).on("mouseout", hideTooltip);
                queryG.append("circle").attr("cx", queryPoint.x).attr("cy", queryPoint.y).attr("r", 15).attr("fill", "url(#query-gradient)").attr("opacity", 0.4);
                queryG.append("circle").attr("cx", queryPoint.x).attr("cy", queryPoint.y).attr("r", 8).attr("fill", "url(#query-gradient)").attr("stroke", "white").attr("stroke-width", 3);
                
                // Flexible query label positioning based on available space
                const queryLabelY = Math.max(25, queryPoint.y - 25);
                queryG.append("text")
                    .attr("x", queryPoint.x)
                    .attr("y", queryLabelY)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#FF6B6B")
                    .style("font-weight", "700")
                    .style("font-size", "12px")
                    .text("Query");

                // Performance metrics
                const metricsY = 60;
                svg.append("text").attr("x", leftWidth / 2).attr("y", metricsY).attr("text-anchor", "middle").attr("fill", "#8E8E93").style("font-size", "11px").style("font-weight", "600").text("Results: 2 • 0.1ms");
                svg.append("text").attr("x", vectorX + vectorWidth / 2).attr("y", metricsY).attr("text-anchor", "middle").attr("fill", "#2EC4B6").style("font-size", "11px").style("font-weight", "600").text("Results: 10+ • 2.3ms");

                svg.append("text").attr("x", width / 2).attr("y", -25).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "700").style("font-size", "18px").text("Traditional vs Vector Database");
                svg.append("text").attr("x", width / 2).attr("y", height + 35).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").text("Exact keyword matching vs semantic similarity search in high-dimensional space");
            }

            /** Renders the Multimodal Foundation Models with advanced embedding space visualization. */
            function renderMultimodalViz() {
                const container = d3.select("#multimodal-viz"); container.selectAll("*").remove(); const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 50, right: 40, bottom: 60, left: 40 };
                const width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for modality-specific encoders
                const defs = svg.append("defs");
                const modalityGradients = [
                    { id: "text-encoder-grad", colors: ["#3A86FF", "#60A5FA"] },
                    { id: "vision-encoder-grad", colors: ["#8338EC", "#A855F7"] },
                    { id: "audio-encoder-grad", colors: ["#2EC4B6", "#34D399"] },
                    { id: "shared-space-grad", colors: ["#FF6B6B", "#F87171"] }
                ];

                modalityGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                arrowMarker(svg, "arrow-multi", "#FF6B6B");
                arrowMarker(svg, "arrow-attention", "#8338EC");

                // Central shared embedding space with adaptive layer scaling
                const centerX = width / 2; 
                const centerY = height / 2 + 10; 
                const baseRadius = Math.min(width, height) / 5;
                const radius = Math.max(60, baseRadius); // Minimum radius for readability

                // Enhanced multi-layer embedding space with adaptive scaling and collision detection
                const maxLayers = 3;
                const layerSpacing = Math.max(8, radius * 0.08); // Adaptive layer spacing based on container size
                
                for (let i = 0; i < maxLayers; i++) {
                    const layerRadius = radius + (i * layerSpacing);
                    const opacity = 0.8 - (i * 0.25);
                    
                    // Ensure layers don't exceed container boundaries
                    const maxAllowedRadius = Math.min(
                        Math.min(centerX, width - centerX),
                        Math.min(centerY, height - centerY)
                    ) - 10; // 10px margin from edges
                    
                    if (layerRadius <= maxAllowedRadius) {
                        svg.append("circle")
                            .attr("cx", centerX)
                            .attr("cy", centerY)
                            .attr("r", layerRadius)
                            .attr("fill", "url(#shared-space-grad)")
                            .attr("opacity", opacity * 0.3)
                            .attr("stroke", "#FF6B6B")
                            .attr("stroke-width", Math.max(1, 2 - i))
                            .attr("stroke-dasharray", i > 0 ? "6,6" : "none");
                    }
                }

                svg.append("text").attr("x", centerX).attr("y", centerY - radius - 25).attr("text-anchor", "middle").attr("fill", "#FF6B6B").style("font-weight", "700").style("font-size", "16px").text("Shared Embedding Space");
                svg.append("text").attr("x", centerX).attr("y", centerY - radius - 8).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").text("768-dimensional joint representation");

                // Enhanced modality encoders with responsive positioning and collision detection
                const minMargin = 60; // Reduced minimum margin for better mobile support
                const encoderWidth = 130;
                const encoderHeight = 70;
                const minSpacing = 20; // Minimum spacing between encoders
                
                // Base positions for modalities
                const basePositions = [
                    { x: width * 0.15, y: height * 0.25 }, // Text
                    { x: width * 0.15, y: height * 0.75 }, // Vision
                    { x: width * 0.85, y: height * 0.5 }   // Audio
                ];
                
                // Apply collision detection and minimum spacing constraints
                const adjustedPositions = [];
                basePositions.forEach((pos, index) => {
                    let adjustedX = Math.max(minMargin, Math.min(width - minMargin - encoderWidth, pos.x));
                    let adjustedY = Math.max(minMargin, Math.min(height - minMargin - encoderHeight, pos.y));
                    
                    // Check for collisions with previous encoders
                    for (let i = 0; i < index; i++) {
                        const prevPos = adjustedPositions[i];
                        const distance = Math.sqrt(Math.pow(adjustedX - prevPos.x, 2) + Math.pow(adjustedY - prevPos.y, 2));
                        const minDistance = encoderWidth + minSpacing;
                        
                        if (distance < minDistance) {
                            // Adjust position to avoid collision
                            const angle = Math.atan2(adjustedY - prevPos.y, adjustedX - prevPos.x);
                            adjustedX = prevPos.x + Math.cos(angle) * minDistance;
                            adjustedY = prevPos.y + Math.sin(angle) * minDistance;
                            
                            // Ensure adjusted position is within bounds
                            adjustedX = Math.max(minMargin, Math.min(width - minMargin - encoderWidth, adjustedX));
                            adjustedY = Math.max(minMargin, Math.min(height - minMargin - encoderHeight, adjustedY));
                        }
                    }
                    
                    adjustedPositions.push({ x: adjustedX, y: adjustedY });
                });
                
                const modalities = [
                    { 
                        type: "text", 
                        name: "Text Encoder", 
                        content: '"Golden retriever playing"', 
                        icon: "📝", 
                        x: adjustedPositions[0].x, 
                        y: adjustedPositions[0].y, 
                        gradient: "url(#text-encoder-grad)", 
                        target: { x: centerX - 35, y: centerY - 25 }, 
                        tooltip: "<b>Text Encoder (Transformer)</b><br>BERT/RoBERTa with 12 layers, 768 hidden dimensions. Self-attention for contextual embeddings.", 
                        architecture: "Transformer", 
                        params: "110M" 
                    },
                    { 
                        type: "vision", 
                        name: "Vision Encoder", 
                        content: '🖼️', 
                        icon: "👁️", 
                        x: adjustedPositions[1].x, 
                        y: adjustedPositions[1].y, 
                        gradient: "url(#vision-encoder-grad)", 
                        target: { x: centerX - 20, y: centerY + 30 }, 
                        tooltip: "<b>Vision Encoder (CNN + ViT)</b><br>Hybrid architecture with ConvNet + Vision Transformer. 224x224 image processing.", 
                        architecture: "CNN + ViT", 
                        params: "86M" 
                    },
                    { 
                        type: "audio", 
                        name: "Audio Encoder", 
                        content: '🔊 "woof"', 
                        icon: "🎵", 
                        x: adjustedPositions[2].x, 
                        y: adjustedPositions[2].y, 
                        gradient: "url(#audio-encoder-grad)", 
                        target: { x: centerX + 40, y: centerY - 15 }, 
                        tooltip: "<b>Audio Encoder (Wav2Vec2)</b><br>Self-supervised speech learning with conv + transformer. 16kHz waveform processing.", 
                        architecture: "Wav2Vec2", 
                        params: "95M" 
                    }
                ];

                // Render modality encoders with responsive layout
                modalities.forEach(modality => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, modality.tooltip)).on("mouseout", hideTooltip);

                    // Encoder container with shadow
                    g.append("rect")
                        .attr("x", modality.x - encoderWidth / 2 + 3)
                        .attr("y", modality.y - encoderHeight / 2 + 3)
                        .attr("width", encoderWidth)
                        .attr("height", encoderHeight)
                        .attr("fill", "rgba(0,0,0,0.15)")
                        .attr("rx", 10);
                    g.append("rect")
                        .attr("x", modality.x - encoderWidth / 2)
                        .attr("y", modality.y - encoderHeight / 2)
                        .attr("width", encoderWidth)
                        .attr("height", encoderHeight)
                        .attr("fill", modality.gradient)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2.5)
                        .attr("rx", 10)
                        .style("filter", "drop-shadow(0px 3px 8px rgba(0,0,0,0.3))");

                    // Content
                    g.append("text")
                        .attr("x", modality.x - encoderWidth / 2 + 18)
                        .attr("y", modality.y - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "20px")
                        .text(modality.icon);
                    g.append("text")
                        .attr("x", modality.x)
                        .attr("y", modality.y - 10)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-weight", "bold")
                        .style("font-size", "12px")
                        .text(modality.name);
                    g.append("text")
                        .attr("x", modality.x)
                        .attr("y", modality.y + 8)
                        .attr("text-anchor", "middle")
                        .attr("fill", "rgba(255,255,255,0.9)")
                        .style("font-size", "10px")
                        .text(modality.architecture);
                    g.append("text")
                        .attr("x", modality.x)
                        .attr("y", modality.y + 22)
                        .attr("text-anchor", "middle")
                        .attr("fill", "rgba(255,255,255,0.8)")
                        .style("font-size", "9px")
                        .text(`${modality.params} params`);

                    // Adaptive connection to shared space with collision avoidance
                    const startX = modality.x;
                    const startY = modality.y + encoderHeight / 2;
                    const endX = modality.target.x;
                    const endY = modality.target.y;
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    
                    // Calculate adaptive control point to avoid collisions
                    const controlOffset = Math.min(30, Math.max(15, Math.abs(endX - startX) * 0.2));
                    const controlX = midX + (endY > startY ? controlOffset : -controlOffset);
                    const controlY = midY + (endX > startX ? -controlOffset : controlOffset);
                    
                    const connectionPath = `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`;
                    
                    for (let j = 0; j < 2; j++) {
                        const strokeWidth = 3 - j; 
                        const opacity = 0.8 - j * 0.3;
                        svg.append("path")
                            .attr("d", connectionPath)
                            .attr("stroke", j === 0 ? "#FF6B6B" : modality.gradient)
                            .attr("stroke-width", strokeWidth)
                            .attr("stroke-opacity", opacity)
                            .attr("fill", "none")
                            .attr("marker-end", j === 0 ? "url(#arrow-multi)" : "none")
                            .attr("stroke-dasharray", j > 0 ? "5,5" : "none");
                    }

                    // Target point in shared space
                    const targetG = svg.append("g")
                        .attr("class", "interactive-node")
                        .on("mouseover", (e) => showTooltip(e, `<b>${modality.type} embedding</b><br>768-dim vector in shared space`))
                        .on("mouseout", hideTooltip);
                    targetG.append("circle")
                        .attr("cx", modality.target.x)
                        .attr("cy", modality.target.y)
                        .attr("r", 7)
                        .attr("fill", modality.gradient)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);
                });

                // Cross-modal attention
                const attentionConnections = [{ from: 0, to: 1, weight: 0.85 }, { from: 1, to: 2, weight: 0.72 }];
                attentionConnections.forEach(conn => {
                    const source = modalities[conn.from].target; const target = modalities[conn.to].target;
                    svg.append("line").attr("x1", source.x).attr("y1", source.y).attr("x2", target.x).attr("y2", target.y).attr("stroke", "#8338EC").attr("stroke-width", conn.weight * 3).attr("opacity", 0.6).attr("stroke-dasharray", "4,4").attr("marker-end", "url(#arrow-attention)");
                });

                // Performance metrics
                const metricsX = width - 140; const metricsY = 30;
                svg.append("text").attr("x", metricsX).attr("y", metricsY).attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "14px").text("Performance");
                const metrics = [{ label: "Cross-Modal Retrieval", value: "94.3%", color: "#FF6B6B" }, { label: "Image-Text Alignment", value: "91.7%", color: "#8338EC" }, { label: "Total Parameters", value: "291M", color: "#2EC4B6" }];
                metrics.forEach((metric, i) => {
                    const y = metricsY + 20 + (i * 18);
                    svg.append("circle").attr("cx", metricsX).attr("cy", y).attr("r", 4).attr("fill", metric.color);
                    svg.append("text").attr("x", metricsX + 12).attr("y", y + 3).attr("fill", "var(--text-secondary)").style("font-size", "10px").style("font-family", "Inter, system-ui, sans-serif").text(`${metric.label}: ${metric.value}`);
                });

                svg.append("text").attr("x", centerX).attr("y", -25).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "700").style("font-size", "18px").text("Multimodal Foundation Models");
                svg.append("text").attr("x", centerX).attr("y", height + 35).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").text("Cross-modal understanding through joint embedding spaces and attention mechanisms");
            }

            /** Renders the Unified AI Ecosystem architecture with advanced network visualization. */
            function renderEcosystemViz() {
                const container = d3.select("#ecosystem-viz"); container.selectAll("*").remove(); const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 40, right: 40, bottom: 40, left: 40 };
                const width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient and pattern definitions
                const defs = svg.append("defs");

                // Edge layer gradient
                const edgeGradient = defs.append("radialGradient").attr("id", "edge-gradient").attr("cx", "50%").attr("cy", "50%").attr("r", "50%");
                edgeGradient.append("stop").attr("offset", "0%").attr("stop-color", "#00A6FB").attr("stop-opacity", 0.1);
                edgeGradient.append("stop").attr("offset", "100%").attr("stop-color", "#3A86FF").attr("stop-opacity", 0.05);

                // Cloud layer gradient
                const cloudGradient = defs.append("radialGradient").attr("id", "cloud-gradient").attr("cx", "50%").attr("cy", "50%").attr("r", "50%");
                cloudGradient.append("stop").attr("offset", "0%").attr("stop-color", "#8338EC").attr("stop-opacity", 0.1);
                cloudGradient.append("stop").attr("offset", "100%").attr("stop-color", "#6D2BCA").attr("stop-opacity", 0.05);

                // Platform gradient
                const platformGradient = defs.append("linearGradient").attr("id", "platform-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                platformGradient.append("stop").attr("offset", "0%").attr("stop-color", "#3A86FF").attr("stop-opacity", 0.9);
                platformGradient.append("stop").attr("offset", "100%").attr("stop-color", "#8338EC").attr("stop-opacity", 0.7);

                // Network pattern for background
                const networkPattern = defs.append("pattern").attr("id", "network-pattern").attr("patternUnits", "userSpaceOnUse").attr("width", 40).attr("height", 40);
                networkPattern.append("circle").attr("cx", 20).attr("cy", 20).attr("r", 1).attr("fill", "var(--accent-cyan)").attr("opacity", 0.1);
                networkPattern.append("line").attr("x1", 0).attr("y1", 20).attr("x2", 40).attr("y2", 20).attr("stroke", "var(--accent-cyan)").attr("stroke-width", 0.5).attr("opacity", 0.05);
                networkPattern.append("line").attr("x1", 20).attr("y1", 0).attr("x2", 20).attr("y2", 40).attr("stroke", "var(--accent-cyan)").attr("stroke-width", 0.5).attr("opacity", 0.05);

                arrowMarker(svg, "arrow-purple", "#8338EC");
                arrowMarker(svg, "arrow-feedback", "#00A6FB");
                arrowMarker(svg, "arrow-data", "#2EC4B6");

                // Enhanced layered architecture background
                svg.append("rect").attr("x", 0).attr("y", 0).attr("width", width).attr("height", height * 0.45).attr("fill", "url(#edge-gradient)").attr("stroke", "#00A6FB").attr("stroke-width", 2).attr("stroke-dasharray", "10,5").attr("rx", 15);
                svg.append("rect").attr("x", 0).attr("y", height * 0.55).attr("width", width).attr("height", height * 0.45).attr("fill", "url(#cloud-gradient)").attr("stroke", "#8338EC").attr("stroke-width", 2).attr("stroke-dasharray", "10,5").attr("rx", 15);

                // Enhanced layer labels with sophisticated typography
                svg.append("text").attr("x", 40).attr("y", 35).attr("fill", "#00A6FB").style("font-weight", "700").style("font-size", "16px").style("font-family", "Inter, system-ui, sans-serif").text("Edge Computing Layer");
                svg.append("text").attr("x", 40).attr("y", 55).attr("fill", "var(--text-secondary)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Local inference, privacy-first processing, real-time responses");

                svg.append("text").attr("x", 40).attr("y", height - 35).attr("fill", "#8338EC").style("font-weight", "700").style("font-size", "16px").style("font-family", "Inter, system-ui, sans-serif").text("Enterprise Cloud Layer");
                svg.append("text").attr("x", 40).attr("y", height - 15).attr("fill", "var(--text-secondary)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Scalable training, model management, data orchestration");

                // Central AI Platform with enhanced styling
                const platform = { x: width / 2, y: height / 2, w: width * 0.35, h: 80 };

                // Platform shadow
                svg.append("ellipse").attr("cx", platform.x + 3).attr("cy", platform.y + 3).attr("rx", platform.w / 2 + 5).attr("ry", platform.h / 2 + 5).attr("fill", "rgba(0,0,0,0.2)");

                // Main platform with gradient
                svg.append("rect").attr("x", platform.x - platform.w / 2).attr("y", platform.y - platform.h / 2).attr("width", platform.w).attr("height", platform.h).attr("fill", "url(#platform-gradient)").attr("stroke", "white").attr("stroke-width", 3).attr("rx", 15).attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, "<b>Central AI Orchestration Platform</b><br>Unified model lifecycle management, federated learning coordination, privacy-preserving analytics, and intelligent workload distribution across edge-cloud continuum.")).on("mouseout", hideTooltip).style("filter", "drop-shadow(0px 4px 12px rgba(0,0,0,0.3))");

                // Platform icon and enhanced text
                svg.append("text").attr("x", platform.x - 60).attr("y", platform.y + 8).attr("text-anchor", "middle").style("font-size", "24px").text("🧠");
                svg.append("text").attr("x", platform.x + 20).attr("y", platform.y - 5).attr("text-anchor", "middle").attr("fill", "white").style("font-weight", "bold").style("font-size", "14px").style("font-family", "Inter, system-ui, sans-serif").text("AI Orchestration");
                svg.append("text").attr("x", platform.x + 20).attr("y", platform.y + 12).attr("text-anchor", "middle").attr("fill", "rgba(255,255,255,0.8)").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Platform");

                // Enhanced edge devices with performance indicators
                const devices = [
                    { name: "ThinkPad", icon: "💻", x: width * 0.2, y: height * 0.25, tooltip: "<b>ThinkPad Edge AI</b><br>Local inference for productivity applications, privacy-preserving document analysis, real-time collaboration enhancement. Latency: <5ms", performance: 85, type: "laptop" },
                    { name: "Workstation", icon: "🖥️", x: width * 0.5, y: height * 0.15, tooltip: "<b>AI Workstation</b><br>High-performance edge computing for CAD/engineering, local model fine-tuning, hybrid cloud-edge workflows. GPU acceleration enabled.", performance: 95, type: "workstation" },
                    { name: "Mobile", icon: "📱", x: width * 0.8, y: height * 0.25, tooltip: "<b>Mobile Edge AI</b><br>Context-aware assistance, sensor fusion, federated learning participation. Battery-optimized inference with NPU acceleration.", performance: 70, type: "mobile" },
                ];

                devices.forEach(d => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, d.tooltip)).on("mouseout", hideTooltip);

                    // Device performance ring
                    const performanceRadius = 35;
                    const circumference = 2 * Math.PI * performanceRadius;
                    const performanceOffset = circumference - (d.performance / 100) * circumference;

                    g.append("circle").attr("cx", d.x).attr("cy", d.y).attr("r", performanceRadius).attr("fill", "none").attr("stroke", "rgba(0,166,251,0.2)").attr("stroke-width", 4);
                    g.append("circle").attr("cx", d.x).attr("cy", d.y).attr("r", performanceRadius).attr("fill", "none").attr("stroke", "#00A6FB").attr("stroke-width", 4).attr("stroke-dasharray", circumference).attr("stroke-dashoffset", performanceOffset).style("stroke-linecap", "round");

                    // Device background and icon
                    g.append("circle").attr("cx", d.x).attr("cy", d.y).attr("r", 25).attr("fill", "var(--primary-border)").attr("stroke", "#00A6FB").attr("stroke-width", 2);
                    g.append("text").attr("x", d.x).attr("y", d.y + 5).attr("text-anchor", "middle").style("font-size", "20px").text(d.icon);

                    // Device label and performance
                    g.append("text").attr("x", d.x).attr("y", d.y + 55).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text(d.name);
                    g.append("text").attr("x", d.x).attr("y", d.y + 70).attr("text-anchor", "middle").attr("fill", "#00A6FB").style("font-size", "10px").style("font-family", "Inter, system-ui, sans-serif").text(`${d.performance}% efficiency`);

                    // Sophisticated connection to platform with data flow indicators
                    const pathToCenter = svg.append("path").attr("d", `M ${d.x} ${d.y + 40} Q ${(d.x + platform.x) / 2} ${d.y + 80} ${platform.x} ${platform.y - platform.h / 2}`).attr("stroke", "#00A6FB").attr("stroke-width", 3).attr("fill", "none").attr("marker-end", "url(#arrow-feedback)").attr("opacity", 0.8);

                    // Animated data flow dots
                    for (let i = 0; i < 3; i++) {
                        g.append("circle").attr("r", 3).attr("fill", "#2EC4B6").attr("opacity", 0.8).append("animateMotion").attr("dur", "3s").attr("repeatCount", "indefinite").attr("begin", `${i * 1}s`).append("mpath").attr("href", `#${pathToCenter.node().id || 'path'}`);
                    }
                });

                // Enhanced cloud services with service mesh visualization
                const services = [
                    { name: "Foundation\nModels", tooltip: "<b>Large Foundation Models</b><br>GPT-4, Claude, Gemini for complex reasoning. Distributed inference across multiple GPUs with intelligent load balancing and cost optimization.", x: width * 0.2, y: height * 0.8, tier: "compute" },
                    { name: "Vector\nSearch", tooltip: "<b>Enterprise Vector Search</b><br>Semantic search across multi-modal enterprise data. Supports hybrid retrieval, real-time indexing, and privacy-preserving similarity computation.", x: width * 0.5, y: height * 0.85, tier: "data" },
                    { name: "MLOps\nPipeline", tooltip: "<b>Automated MLOps</b><br>End-to-end model lifecycle management with continuous training, validation, deployment, and monitoring. Supports A/B testing and gradual rollouts.", x: width * 0.8, y: height * 0.8, tier: "ops" }
                ];

                const tierColors = { "compute": "#8338EC", "data": "#2EC4B6", "ops": "#FFB700" };

                services.forEach(s => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, s.tooltip)).on("mouseout", hideTooltip);

                    // Service container with tier-based styling
                    g.append("rect").attr("x", s.x - 65).attr("y", s.y - 30).attr("width", 130).attr("height", 60).attr("fill", "var(--primary-border)").attr("stroke", tierColors[s.tier]).attr("stroke-width", 3).attr("rx", 10).style("filter", "drop-shadow(0px 2px 6px rgba(0,0,0,0.2))");

                    // Service tier indicator
                    g.append("circle").attr("cx", s.x - 50).attr("cy", s.y - 15).attr("r", 6).attr("fill", tierColors[s.tier]);

                    // Service text
                    const lines = s.name.split('\n');
                    lines.forEach((line, i) => {
                        g.append("text").attr("x", s.x).attr("y", s.y + (i * 14) - 5).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text(line);
                    });

                    // Connection to platform with enhanced styling
                    svg.append("path").attr("d", `M ${platform.x} ${platform.y + platform.h / 2} Q ${(platform.x + s.x) / 2} ${platform.y + 60} ${s.x} ${s.y - 30}`).attr("stroke", tierColors[s.tier]).attr("stroke-width", 3).attr("fill", "none").attr("marker-end", "url(#arrow-purple)").attr("opacity", 0.7);
                });

                // Advanced bidirectional flow for model updates with data annotations
                svg.append("path").attr("d", `M ${platform.x - platform.w / 2} ${platform.y - 10} Q ${width * 0.15} ${platform.y - 40} ${devices[0].x - 30} ${devices[0].y + 20}`).attr("stroke", "#2EC4B6").attr("stroke-width", 3).attr("fill", "none").attr("marker-end", "url(#arrow-data)").attr("stroke-dasharray", "8,4").attr("class", "interactive-node").on("mouseover", e => showTooltip(e, "<b>Intelligent Model Distribution</b><br>Automated deployment of optimized models to edge devices based on capability, usage patterns, and performance requirements. Includes differential updates and federated learning coordination.")).on("mouseout", hideTooltip);

                // Model update annotation with enhanced styling
                svg.append("rect").attr("x", width * 0.15).attr("y", platform.y - 60).attr("width", 120).attr("height", 25).attr("fill", "rgba(46, 196, 182, 0.1)").attr("stroke", "#2EC4B6").attr("rx", 5);
                svg.append("text").attr("x", width * 0.21).attr("y", platform.y - 45).attr("text-anchor", "middle").attr("fill", "#2EC4B6").style("font-size", "11px").style("font-weight", "600").style("font-family", "Inter, system-ui, sans-serif").text("Model Updates");

                // Add ecosystem metrics dashboard
                const metricsY = height - 80;
                svg.append("text").attr("x", width - 20).attr("y", metricsY).attr("text-anchor", "end").attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "12px").style("font-family", "Inter, system-ui, sans-serif").text("Ecosystem Metrics");

                const metrics = [
                    { label: "Edge Efficiency", value: "87%", color: "#00A6FB" },
                    { label: "Cloud Utilization", value: "92%", color: "#8338EC" },
                    { label: "Model Sync", value: "99.8%", color: "#2EC4B6" }
                ];

                metrics.forEach((metric, i) => {
                    const y = metricsY + 15 + (i * 15);
                    svg.append("circle").attr("cx", width - 80).attr("cy", y).attr("r", 4).attr("fill", metric.color);
                    svg.append("text").attr("x", width - 70).attr("y", y + 4).attr("fill", "var(--text-secondary)").style("font-size", "10px").style("font-family", "Inter, system-ui, sans-serif").text(`${metric.label}: ${metric.value}`);
                });
            }

            /** Renders the 90-Day AI Implementation Gantt Chart with advanced project visualization. */
            function renderGanttChartViz() {
                const container = d3.select("#gantt-chart-viz"); container.selectAll("*").remove(); const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 60, right: 50, bottom: 50, left: 180 }, width = bounds.width - margin.left - margin.right, height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for project phases
                const defs = svg.append("defs");
                const phaseGradients = [
                    { id: "discovery-grad", colors: ["#3A86FF", "#60A5FA"] },
                    { id: "prototyping-grad", colors: ["#2EC4B6", "#34D399"] },
                    { id: "deployment-grad", colors: ["#8338EC", "#A855F7"] },
                    { id: "critical-path-grad", colors: ["#FF6B6B", "#F87171"] }
                ];

                phaseGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                });

                arrowMarker(svg, "arrow-dependency", "#FFB700");
                arrowMarker(svg, "arrow-milestone", "#FF6B6B");

                // Enhanced task definitions with priority, resources, and dependencies
                const tasks = [
                    { task: "Stakeholder Interviews", start: 1, end: 15, phase: "Discovery", priority: "High", resources: ["PM", "Architect"], progress: 100, dependencies: [], critical: false, details: "Meet with product, engineering, and business leads to define key problems and success metrics for on-device AI. Includes requirements gathering and ROI analysis." },
                    { task: "Architecture Review", start: 5, end: 20, phase: "Discovery", priority: "Critical", resources: ["Architect", "DevOps"], progress: 100, dependencies: [0], critical: true, details: "Analyze current software/hardware stacks to identify integration points and potential bottlenecks. Security and compliance assessment included." },
                    { task: "Define Pilot Scope", start: 15, end: 30, phase: "Discovery", priority: "High", resources: ["PM", "Architect", "ML Engineer"], progress: 85, dependencies: [0, 1], critical: true, details: "Finalize a specific, high-impact use case for the initial 90-day pilot program. Technical feasibility and business impact assessment." },
                    { task: "Setup MLOps Backbone", start: 31, end: 45, phase: "Prototyping", priority: "Critical", resources: ["DevOps", "ML Engineer"], progress: 70, dependencies: [2], critical: true, details: "Deploy CI/CD pipelines for automated model training, versioning, and deployment. Includes monitoring and logging infrastructure." },
                    { task: "On-Device Model PoC", start: 35, end: 55, phase: "Prototyping", priority: "Critical", resources: ["ML Engineer", "Data Scientist"], progress: 60, dependencies: [3], critical: true, details: "Develop and quantize a small, efficient model for the chosen pilot use case. Includes optimization for edge deployment and performance benchmarking." },
                    { task: "Enterprise API Dev", start: 40, end: 60, phase: "Prototyping", priority: "Medium", resources: ["Backend Dev", "DevOps"], progress: 45, dependencies: [3], critical: false, details: "Build the cloud-side API endpoints needed to support the on-device model. Includes authentication, rate limiting, and data logging capabilities." },
                    { task: "Pilot User Group Setup", start: 61, end: 70, phase: "Deployment", priority: "High", resources: ["PM", "QA"], progress: 20, dependencies: [4, 5], critical: false, details: "Identify and onboard a small group of internal users to test the pilot feature. Includes user training and feedback collection setup." },
                    { task: "Deploy & Monitor", start: 70, end: 85, phase: "Deployment", priority: "Critical", resources: ["DevOps", "ML Engineer", "SRE"], progress: 0, dependencies: [6], critical: true, details: "Deploy the pilot to the user group and monitor performance, accuracy, and resource usage. Real-time monitoring and alerting systems." },
                    { task: "Leadership Demo", start: 85, end: 90, phase: "Deployment", priority: "High", resources: ["PM", "Architect"], progress: 0, dependencies: [7], critical: false, details: "Present pilot results, key learnings, and a roadmap for expansion to executive stakeholders. Includes ROI analysis and scaling recommendations." }
                ];

                const xScale = d3.scaleLinear().domain([0, 90]).range([0, width]);
                const yScale = d3.scaleBand().domain(tasks.map(d => d.task)).range([0, height]).padding(0.15);

                // Enhanced project phases with sophisticated styling
                const phases = [
                    { name: "Discovery Phase", start: 0, end: 30, color: "#3A86FF", gradient: "url(#discovery-grad)", description: "Requirements & Architecture" },
                    { name: "Prototyping Phase", start: 30, end: 60, color: "#2EC4B6", gradient: "url(#prototyping-grad)", description: "Development & Testing" },
                    { name: "Deployment Phase", start: 60, end: 90, color: "#8338EC", gradient: "url(#deployment-grad)", description: "Launch & Validation" }
                ];

                // Render phase backgrounds with adaptive scaling
                phases.forEach((phase, i) => {
                    const phaseG = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, `<b>${phase.name}</b><br>${phase.description}<br>Duration: ${phase.end - phase.start} days`)).on("mouseout", hideTooltip);

                    // Enhanced adaptive phase background with boundary protection
                    const phaseWidth = xScale(phase.end) - xScale(phase.start);
                    const minPhaseWidth = 50; // Minimum width for readability
                    const maxPhaseHeight = height + 40; // Reduced to prevent overflow
                    
                    // Ensure phase background doesn't become too narrow
                    const adjustedPhaseWidth = Math.max(minPhaseWidth, phaseWidth);
                    const adjustedPhaseX = phaseWidth < minPhaseWidth ? xScale(phase.start) - (minPhaseWidth - phaseWidth) / 2 : xScale(phase.start);
                    
                    // Ensure phase background stays within container boundaries
                    const finalPhaseHeight = Math.min(maxPhaseHeight, height + 40);
                    const finalPhaseY = -20; // Reduced top margin
                    
                    phaseG.append("rect")
                        .attr("x", adjustedPhaseX)
                        .attr("y", finalPhaseY)
                        .attr("width", adjustedPhaseWidth)
                        .attr("height", finalPhaseHeight)
                        .attr("fill", phase.gradient)
                        .attr("opacity", 0.1)
                        .attr("stroke", phase.color)
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "8,4")
                        .attr("rx", 8);

                    // Enhanced adaptive phase labels with smart positioning
                    const labelX = adjustedPhaseX + adjustedPhaseWidth / 2;
                    const labelFontSize = Math.min(14, Math.max(10, adjustedPhaseWidth / 8)); // Responsive font size
                    const labelY = finalPhaseY - 10; // Position relative to phase background
                    
                    // Ensure labels don't extend beyond container boundaries
                    const adjustedLabelY = Math.max(-35, labelY);
                    
                    phaseG.append("text")
                        .attr("x", labelX)
                        .attr("y", adjustedLabelY)
                        .attr("text-anchor", "middle")
                        .attr("fill", phase.color)
                        .style("font-weight", "700")
                        .style("font-size", `${labelFontSize}px`)
                        .text(phase.name);
                    phaseG.append("text")
                        .attr("x", labelX)
                        .attr("y", adjustedLabelY + 15)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", `${Math.max(9, labelFontSize - 2)}px`)
                        .text(phase.description);
                });

                // Enhanced grid with week markers
                svg.selectAll(".week-line").data(d3.range(0, 91, 7)).enter().append("line").attr("class", "week-line").attr("x1", d => xScale(d)).attr("y1", -15).attr("x2", d => xScale(d)).attr("y2", height + 10).attr("stroke", "var(--secondary-border)").attr("stroke-width", d => d % 14 === 0 ? 2 : 1).attr("stroke-dasharray", d => d % 14 === 0 ? "none" : "3,3").attr("opacity", 0.3);

                // Enhanced responsive task labels with text truncation and tooltip fallback
                const maxLabelWidth = 160; // Maximum width for task labels
                const labelMargin = 10; // Margin from left edge
                
                // Render task labels with responsive positioning and truncation
                tasks.forEach((task, i) => {
                    const taskY = yScale(task.task);
                    const taskHeight = yScale.bandwidth();
                    
                    // Calculate available space for label
                    const availableWidth = Math.max(100, maxLabelWidth);
                    const labelX = -labelMargin;
                    const labelY = taskY + taskHeight / 2;
                    
                    // Truncate text if too long
                    const truncatedText = task.task.length > 20 ? task.task.substring(0, 17) + "..." : task.task;
                    
                    // Create label group with tooltip
                    const labelG = svg.append("g")
                        .attr("class", "interactive-node")
                        .on("mouseover", (e) => showTooltip(e, `<b>${task.task}</b><br>Phase: ${task.phase}<br>Priority: ${task.priority}<br>Progress: ${task.progress}%<br><br>${task.details}`))
                        .on("mouseout", hideTooltip);
                    
                    labelG.append("text")
                        .attr("x", labelX)
                        .attr("y", labelY)
                        .attr("text-anchor", "end")
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", "11px")
                        .style("font-weight", "600")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(truncatedText);
                });

                // Render enhanced task bars
                tasks.forEach((task, i) => {
                    const taskY = yScale(task.task);
                    const taskHeight = yScale.bandwidth();
                    const taskWidth = xScale(task.end) - xScale(task.start);
                    const taskG = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, `<b>${task.task}</b><br><b>Phase:</b> ${task.phase}<br><b>Priority:</b> ${task.priority}<br><b>Progress:</b> ${task.progress}%<br><b>Resources:</b> ${task.resources.join(", ")}<br><b>Duration:</b> ${task.end - task.start} days<br><br>${task.details}`)).on("mouseout", hideTooltip);

                    // Task shadow
                    taskG.append("rect").attr("x", xScale(task.start) + 2).attr("y", taskY + 2).attr("width", taskWidth).attr("height", taskHeight).attr("fill", "rgba(0,0,0,0.15)").attr("rx", 4);

                    // Main task bar with phase-specific styling
                    const phaseColor = phases.find(p => p.name.includes(task.phase))?.gradient || "url(#discovery-grad)";
                    taskG.append("rect").attr("x", xScale(task.start)).attr("y", taskY).attr("width", taskWidth).attr("height", taskHeight).attr("fill", phaseColor).attr("stroke", task.critical ? "#FF6B6B" : "white").attr("stroke-width", task.critical ? 3 : 1.5).attr("rx", 4).style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.2))");

                    // Progress indicator
                    const progressWidth = (task.progress / 100) * taskWidth;
                    taskG.append("rect").attr("x", xScale(task.start)).attr("y", taskY).attr("width", progressWidth).attr("height", taskHeight).attr("fill", "rgba(255,255,255,0.4)").attr("rx", 4);

                    // Priority indicator
                    const priorityColors = { "Critical": "#FF6B6B", "High": "#FFB700", "Medium": "#2EC4B6" };
                    taskG.append("circle").attr("cx", xScale(task.start) + 8).attr("cy", taskY + taskHeight / 2).attr("r", 4).attr("fill", priorityColors[task.priority]).attr("stroke", "white").attr("stroke-width", 1);

                    // Responsive task labels with overflow protection
                    const labelX = xScale(task.start) + 20;
                    const labelY = taskY + taskHeight / 2 - 5;
                    const infoY = taskY + taskHeight / 2 + 8;
                    const availableWidth = taskWidth - 40; // Account for padding
                    
                    // Calculate responsive font size based on available space
                    const baseFontSize = 11;
                    const infoFontSize = 9;
                    const responsiveFontSize = Math.min(baseFontSize, Math.max(8, availableWidth / 8));
                    const responsiveInfoSize = Math.min(infoFontSize, Math.max(7, availableWidth / 10));
                    
                    // Truncate task name if too long
                    const maxChars = Math.floor(availableWidth / (responsiveFontSize * 0.6));
                    const displayTaskName = task.task.length > maxChars ? 
                        task.task.substring(0, maxChars - 3) + "..." : task.task;
                    
                    taskG.append("text")
                        .attr("x", labelX)
                        .attr("y", labelY)
                        .attr("fill", "white")
                        .style("font-weight", "600")
                        .style("font-size", `${responsiveFontSize}px`)
                        .text(displayTaskName);

                    // Resource and progress info with responsive sizing
                    const infoText = `${task.progress}% • ${task.resources.length} resources`;
                    const maxInfoChars = Math.floor(availableWidth / (responsiveInfoSize * 0.5));
                    const displayInfoText = infoText.length > maxInfoChars ? 
                        `${task.progress}% • ${task.resources.length}` : infoText;
                    
                    taskG.append("text")
                        .attr("x", labelX)
                        .attr("y", infoY)
                        .attr("fill", "rgba(255,255,255,0.8)")
                        .style("font-size", `${responsiveInfoSize}px`)
                        .text(displayInfoText);

                    // Critical path indicator
                    if (task.critical) {
                        taskG.append("rect").attr("x", xScale(task.start) - 2).attr("y", taskY - 2).attr("width", taskWidth + 4).attr("height", taskHeight + 4).attr("fill", "none").attr("stroke", "#FF6B6B").attr("stroke-width", 2).attr("stroke-dasharray", "4,4").attr("rx", 6);
                    }
                });

                // Dependency arrows
                tasks.forEach((task, i) => {
                    task.dependencies.forEach(depIndex => {
                        const depTask = tasks[depIndex];
                        const startX = xScale(depTask.end);
                        const startY = yScale(depTask.task) + yScale.bandwidth() / 2;
                        const endX = xScale(task.start);
                        const endY = yScale(task.task) + yScale.bandwidth() / 2;

                        // Curved dependency arrow
                        const midX = (startX + endX) / 2;
                        const midY = Math.min(startY, endY) - 20;

                        svg.append("path").attr("d", `M ${startX} ${startY} Q ${midX} ${midY} ${endX} ${endY}`).attr("stroke", "#FFB700").attr("stroke-width", 2).attr("fill", "none").attr("marker-end", "url(#arrow-dependency)").attr("opacity", 0.7);
                    });
                });

                // Milestone markers
                const milestones = [
                    { day: 30, label: "Architecture Complete", type: "phase" },
                    { day: 60, label: "PoC Ready", type: "phase" },
                    { day: 90, label: "Pilot Delivered", type: "project" }
                ];

                milestones.forEach(milestone => {
                    const milestoneG = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, `<b>Milestone: ${milestone.label}</b><br>Day ${milestone.day}<br>Type: ${milestone.type}`)).on("mouseout", hideTooltip);

                    // Milestone line
                    milestoneG.append("line").attr("x1", xScale(milestone.day)).attr("y1", -15).attr("x2", xScale(milestone.day)).attr("y2", height + 10).attr("stroke", "#FF6B6B").attr("stroke-width", 3).attr("marker-end", "url(#arrow-milestone)");

                    // Milestone diamond
                    const diamondSize = 8;
                    milestoneG.append("path").attr("d", `M ${xScale(milestone.day)} ${-15 - diamondSize} L ${xScale(milestone.day) + diamondSize} ${-15} L ${xScale(milestone.day)} ${-15 + diamondSize} L ${xScale(milestone.day) - diamondSize} ${-15} Z`).attr("fill", "#FF6B6B").attr("stroke", "white").attr("stroke-width", 2);

                    // Responsive milestone label positioning
                    const milestoneLabelY = height + 25;
                    const milestoneLabelFontSize = Math.min(10, Math.max(8, width / 80)); // Responsive font size
                    
                    milestoneG.append("text")
                        .attr("x", xScale(milestone.day))
                        .attr("y", milestoneLabelY)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#FF6B6B")
                        .style("font-weight", "600")
                        .style("font-size", `${milestoneLabelFontSize}px`)
                        .text(milestone.label);
                });

                // Enhanced timeline axis
                const xAxis = d3.axisTop(xScale).ticks(13).tickFormat(d => d === 0 ? "Start" : d === 90 ? "End" : `Week ${Math.ceil(d / 7)}`);
                const axisG = svg.append("g").attr("transform", "translate(0, -15)").call(xAxis);
                axisG.selectAll("text").attr("fill", "var(--text-primary)").style("font-weight", "500");
                axisG.selectAll("path, line").attr("stroke", "var(--text-primary)").attr("stroke-width", 2);

                // Task labels on the left
                svg.selectAll(".task-label").data(tasks).enter().append("text").attr("x", -10).attr("y", d => yScale(d.task) + yScale.bandwidth() / 2 + 4).attr("text-anchor", "end").attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "12px").text(d => d.task);

                // Project summary dashboard
                const summaryY = height + 40;
                const totalTasks = tasks.length;
                const completedTasks = tasks.filter(t => t.progress === 100).length;
                const criticalTasks = tasks.filter(t => t.critical).length;
                const avgProgress = Math.round(tasks.reduce((acc, t) => acc + t.progress, 0) / totalTasks);

                svg.append("text").attr("x", 0).attr("y", summaryY).attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "14px").text("Project Summary");

                const summaryMetrics = [
                    { label: "Overall Progress", value: `${avgProgress}%`, color: "#2EC4B6" },
                    { label: "Completed Tasks", value: `${completedTasks}/${totalTasks}`, color: "#3A86FF" },
                    { label: "Critical Path Items", value: `${criticalTasks}`, color: "#FF6B6B" },
                    { label: "Current Phase", value: "Prototyping", color: "#8338EC" }
                ];

                summaryMetrics.forEach((metric, i) => {
                    const x = i * (width / 4);
                    svg.append("circle").attr("cx", x).attr("cy", summaryY + 20).attr("r", 4).attr("fill", metric.color);
                    svg.append("text").attr("x", x + 12).attr("y", summaryY + 24).attr("fill", "var(--text-secondary)").style("font-size", "11px").text(`${metric.label}: ${metric.value}`);
                });

                // Enhanced title
                svg.append("text").attr("x", width / 2).attr("y", -50).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "700").style("font-size", "18px").text("90-Day AI Implementation Roadmap");
            }

            /** Renders the Interactive Architecture Playground with drag-and-drop functionality. */
            function renderArchitecturePlaygroundViz() {
                const container = d3.select("#architecture-playground-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;

                // Responsive layout calculation
                const isSmallScreen = bounds.width < 700;
                const isMediumScreen = bounds.width < 1000;
                const margin = {
                    top: isSmallScreen ? 15 : 20,
                    right: isSmallScreen ? 10 : 20,
                    bottom: isSmallScreen ? 15 : 20,
                    left: isSmallScreen ? 10 : 20
                };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;

                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Responsive component palette sizing
                const paletteWidth = isSmallScreen ? 140 : isMediumScreen ? 160 : 180;
                const canvasWidth = width - paletteWidth;

                // Create component palette
                const palette = svg.append("g").attr("class", "component-palette");
                palette.append("rect")
                    .attr("x", 0).attr("y", 0)
                    .attr("width", paletteWidth).attr("height", height)
                    .attr("fill", "rgba(27, 38, 59, 0.8)")
                    .attr("stroke", "var(--primary-border)")
                    .attr("stroke-width", 1)
                    .attr("rx", 8);

                palette.append("text")
                    .attr("x", paletteWidth / 2).attr("y", isSmallScreen ? 20 : 25)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "600")
                    .style("font-size", isSmallScreen ? "12px" : "14px")
                    .text("Components");

                // Responsive draggable components with dynamic spacing
                const componentSpacing = isSmallScreen ? 35 : 50;
                const startY = isSmallScreen ? 35 : 50;
                const startX = isSmallScreen ? 15 : 20;
                const components = [
                    { id: "data-source", name: "Data Source", icon: "📊", color: "var(--accent-blue)", category: "Input", x: startX, y: startY },
                    { id: "preprocessing", name: "Preprocessing", icon: "🔧", color: "var(--accent-cyan)", category: "Processing", x: startX, y: startY + componentSpacing },
                    { id: "model", name: "AI Model", icon: "🧠", color: "var(--accent-green)", category: "Core", x: startX, y: startY + componentSpacing * 2 },
                    { id: "rag", name: "RAG System", icon: "🔍", color: "var(--accent-purple)", category: "Enhancement", x: startX, y: startY + componentSpacing * 3 },
                    { id: "api", name: "API Gateway", icon: "🌐", color: "var(--accent-blue)", category: "Interface", x: startX, y: startY + componentSpacing * 4 },
                    { id: "monitoring", name: "Monitoring", icon: "📈", color: "var(--accent-green)", category: "Observability", x: startX, y: startY + componentSpacing * 5 },
                    { id: "database", name: "Database", icon: "💾", color: "var(--accent-cyan)", category: "Storage", x: startX, y: startY + componentSpacing * 6 },
                    { id: "cache", name: "Cache", icon: "⚡", color: "var(--accent-purple)", category: "Performance", x: startX, y: startY + componentSpacing * 7 }
                ];

                // Create component palette items
                const paletteItems = palette.selectAll(".palette-item")
                    .data(components)
                    .enter().append("g")
                    .attr("class", "palette-item")
                    .attr("transform", d => `translate(${d.x}, ${d.y})`)
                    .style("cursor", "grab");

                paletteItems.append("rect")
                    .attr("width", 140).attr("height", 35)
                    .attr("rx", 6)
                    .attr("fill", d => d.color)
                    .attr("opacity", 0.8)
                    .attr("stroke", "white")
                    .attr("stroke-width", 1);

                paletteItems.append("text")
                    .attr("x", isSmallScreen ? 15 : 20).attr("y", 15)
                    .attr("fill", "white")
                    .style("font-size", isSmallScreen ? "14px" : "16px")
                    .text(d => d.icon);

                paletteItems.append("text")
                    .attr("x", isSmallScreen ? 32 : 40).attr("y", 15)
                    .attr("fill", "white")
                    .style("font-size", isSmallScreen ? "10px" : "11px")
                    .style("font-weight", "500")
                    .text(d => isSmallScreen ? d.name.substring(0, 8) + (d.name.length > 8 ? "..." : "") : d.name);

                paletteItems.append("text")
                    .attr("x", isSmallScreen ? 32 : 40).attr("y", 25)
                    .attr("fill", "rgba(255,255,255,0.7)")
                    .style("font-size", isSmallScreen ? "8px" : "9px")
                    .text(d => d.category);

                // Create canvas area
                const canvas = svg.append("g").attr("class", "architecture-canvas");
                canvas.append("rect")
                    .attr("x", paletteWidth + 10).attr("y", 0)
                    .attr("width", canvasWidth - 20).attr("height", height)
                    .attr("fill", "rgba(13, 27, 42, 0.3)")
                    .attr("stroke", "var(--primary-border)")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "5,5")
                    .attr("rx", 8);

                canvas.append("text")
                    .attr("x", paletteWidth + 10 + (canvasWidth - 20) / 2).attr("y", isSmallScreen ? 20 : 25)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", isSmallScreen ? "12px" : "14px")
                    .text(isSmallScreen ? "Drag components to build" : "Drag components here to build your architecture");

                // Responsive architecture canvas area
                const canvasX = paletteWidth + (isSmallScreen ? 15 : 20);
                const canvasY = isSmallScreen ? 30 : 40;
                const canvasW = canvasWidth - (isSmallScreen ? 30 : 40);
                const canvasH = height - (isSmallScreen ? 45 : 60);

                // Store placed components
                let placedComponents = [];
                let connections = [];

                // Drag behavior for palette items
                const drag = d3.drag()
                    .on("start", function (event, d) {
                        d3.select(this).style("cursor", "grabbing");
                    })
                    .on("drag", function (event, d) {
                        d3.select(this).attr("transform", `translate(${event.x}, ${event.y})`);
                    })
                    .on("end", function (event, d) {
                        d3.select(this).style("cursor", "grab");

                        // Check if dropped in canvas area
                        if (event.x >= canvasX && event.x <= canvasX + canvasW &&
                            event.y >= canvasY && event.y <= canvasY + canvasH) {

                            // Create new component instance
                            const newComponent = {
                                id: d.id + "_" + Date.now(),
                                name: d.name,
                                icon: d.icon,
                                color: d.color,
                                category: d.category,
                                x: event.x - canvasX,
                                y: event.y - canvasY
                            };

                            placedComponents.push(newComponent);
                            renderPlacedComponents();
                            updateMetrics();

                            // Reset palette item position
                            d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`);
                        } else {
                            // Reset palette item position
                            d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`);
                        }
                    });

                paletteItems.call(drag);

                // Render placed components
                function renderPlacedComponents() {
                    const placed = canvas.selectAll(".placed-component")
                        .data(placedComponents, d => d.id);

                    const placedEnter = placed.enter().append("g")
                        .attr("class", "placed-component")
                        .style("cursor", "move");

                    placedEnter.append("rect")
                        .attr("width", 120).attr("height", 50)
                        .attr("rx", 8)
                        .attr("fill", d => d.color)
                        .attr("opacity", 0.9)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);

                    placedEnter.append("text")
                        .attr("x", 15).attr("y", 20)
                        .attr("fill", "white")
                        .style("font-size", "18px")
                        .text(d => d.icon);

                    placedEnter.append("text")
                        .attr("x", 35).attr("y", 18)
                        .attr("fill", "white")
                        .style("font-size", "11px")
                        .style("font-weight", "600")
                        .text(d => d.name);

                    placedEnter.append("text")
                        .attr("x", 35).attr("y", 30)
                        .attr("fill", "rgba(255,255,255,0.8)")
                        .style("font-size", "9px")
                        .text(d => d.category);

                    // Make placed components draggable
                    const componentDrag = d3.drag()
                        .on("drag", function (event, d) {
                            d.x = Math.max(0, Math.min(canvasW - 120, event.x));
                            d.y = Math.max(0, Math.min(canvasH - 50, event.y));
                            d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`);
                            updateMetrics();
                        });

                    placedEnter.merge(placed)
                        .attr("transform", d => `translate(${d.x}, ${d.y})`)
                        .call(componentDrag);

                    placed.exit().remove();
                }

                // Update performance metrics
                function updateMetrics() {
                    const metrics = {
                        components: placedComponents.length,
                        complexity: calculateComplexity(),
                        performance: calculatePerformance(),
                        cost: calculateCost()
                    };

                    document.getElementById("performance-metrics").innerHTML = `
                    <div>Components: ${metrics.components}</div>
                    <div>Complexity: ${metrics.complexity}/10</div>
                    <div>Performance: ${metrics.performance}/10</div>
                    <div>Cost: $${metrics.cost}/month</div>
                `;

                    const score = Math.round((metrics.performance * 0.4 + (10 - metrics.complexity) * 0.3 + (10 - metrics.cost / 100) * 0.3) * 10);
                    document.getElementById("architecture-score").innerHTML = `
                    <div style="font-size: 24px; font-weight: bold; color: var(--accent-green);">${score}/100</div>
                    <div>Overall Score</div>
                `;

                    const recommendations = generateRecommendations(metrics);
                    document.getElementById("architecture-recommendations").innerHTML = recommendations;
                }

                function calculateComplexity() {
                    return Math.min(10, placedComponents.length * 1.5);
                }

                function calculatePerformance() {
                    const baseScore = 8;
                    const componentPenalty = placedComponents.length * 0.2;
                    return Math.max(1, baseScore - componentPenalty);
                }

                function calculateCost() {
                    return placedComponents.length * 50 + Math.random() * 200;
                }

                function generateRecommendations(metrics) {
                    let recommendations = [];

                    if (metrics.components < 3) {
                        recommendations.push("• Add more components for a complete system");
                    }
                    if (metrics.complexity > 7) {
                        recommendations.push("• Consider simplifying the architecture");
                    }
                    if (metrics.performance < 6) {
                        recommendations.push("• Add caching or optimization layers");
                    }
                    if (metrics.cost > 500) {
                        recommendations.push("• Consider cost optimization strategies");
                    }

                    return recommendations.length > 0 ? recommendations.join("<br>") : "• Architecture looks good!";
                }

                // Button event listeners
                document.getElementById("reset-architecture").addEventListener("click", function () {
                    placedComponents = [];
                    connections = [];
                    renderPlacedComponents();
                    updateMetrics();
                });

                document.getElementById("validate-architecture").addEventListener("click", function () {
                    const validation = validateArchitecture();
                    alert(`Architecture Validation:\n\n${validation.message}\n\nScore: ${validation.score}/100`);
                });

                document.getElementById("export-architecture").addEventListener("click", function () {
                    const exportData = {
                        components: placedComponents,
                        connections: connections,
                        timestamp: new Date().toISOString()
                    };
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = "architecture-design.json";
                    a.click();
                    URL.revokeObjectURL(url);
                });

                function validateArchitecture() {
                    let score = 0;
                    let message = "";

                    if (placedComponents.length >= 3) {
                        score += 30;
                        message += "✓ Minimum components present\n";
                    } else {
                        message += "✗ Need at least 3 components\n";
                    }

                    const hasModel = placedComponents.some(c => c.id.includes("model"));
                    if (hasModel) {
                        score += 25;
                        message += "✓ AI Model component present\n";
                    } else {
                        message += "✗ AI Model component required\n";
                    }

                    const hasAPI = placedComponents.some(c => c.id.includes("api"));
                    if (hasAPI) {
                        score += 20;
                        message += "✓ API Gateway present\n";
                    } else {
                        message += "✗ API Gateway recommended\n";
                    }

                    const hasMonitoring = placedComponents.some(c => c.id.includes("monitoring"));
                    if (hasMonitoring) {
                        score += 15;
                        message += "✓ Monitoring component present\n";
                    } else {
                        message += "✗ Monitoring recommended\n";
                    }

                    const complexity = calculateComplexity();
                    if (complexity <= 6) {
                        score += 10;
                        message += "✓ Good complexity level\n";
                    } else {
                        message += "✗ Architecture too complex\n";
                    }

                    return { score, message };
                }

                // Initial metrics update
                updateMetrics();
            }

            /** Renders the Animated Code Examples & Live Demos with interactive execution. */
            function renderAnimatedCodeExamplesViz() {
                const container = d3.select("#execution-flow-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;

                // Responsive margin calculation for code examples
                const isSmallScreen = bounds.width < 600;
                const isMediumScreen = bounds.width < 900;
                const margin = {
                    top: isSmallScreen ? 15 : 20,
                    right: isSmallScreen ? 10 : 20,
                    bottom: isSmallScreen ? 15 : 20,
                    left: isSmallScreen ? 10 : 20
                };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;

                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Define code examples
                const codeExamples = {
                    "ai-engineering-best-practices": {
                        title: "AI Engineering Best Practices Demo",
                        code: `# AI Engineering Best Practices - Interactive Documentation Viewer
import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime
import json

class AIEngineeringBestPractices:
    def __init__(self):
        self.practices = {
            "Code Quality": {
                "Type Hints": "Always use type hints for better code maintainability",
                "Docstrings": "Document all functions and classes with clear docstrings",
                "Error Handling": "Implement comprehensive error handling and logging",
                "Testing": "Write unit tests for all critical functions"
            },
            "Model Management": {
                "Versioning": "Use MLflow or similar for model versioning",
                "Reproducibility": "Pin dependencies and use deterministic seeds",
                "Monitoring": "Implement model performance monitoring",
                "Rollback": "Maintain ability to rollback to previous model versions"
            },
            "Data Pipeline": {
                "Validation": "Validate data quality at each pipeline stage",
                "Lineage": "Track data lineage and transformations",
                "Backup": "Implement automated data backup strategies",
                "Privacy": "Ensure GDPR/privacy compliance in data handling"
            },
            "Infrastructure": {
                "Scalability": "Design for horizontal scaling from the start",
                "Security": "Implement proper authentication and authorization",
                "Monitoring": "Set up comprehensive system monitoring",
                "CI/CD": "Automate testing and deployment pipelines"
            }
        }
    
    def render_practice_viewer(self):
        st.title("AI Engineering Best Practices")
        
        # Practice category selector
        category = st.selectbox("Select Practice Category", list(self.practices.keys()))
        
        # Display practices for selected category
        st.subheader(f"{category} Best Practices")
        
        for practice, description in self.practices[category].items():
            with st.expander(f"📋 {practice}"):
                st.write(description)
                
                # Interactive code example
                if practice == "Type Hints":
                    st.code('''
def process_data(data: List[Dict[str, Any]]) -> pd.DataFrame:
    """Process input data with type safety.
    
    Args:
        data: List of dictionaries containing raw data
        
    Returns:
        Processed DataFrame with validated data
    """
    return pd.DataFrame(data)
                    ''', language='python')
                
                elif practice == "Model Versioning":
                    st.code('''
import mlflow

# Log model with versioning
with mlflow.start_run():
    mlflow.log_params({"learning_rate": 0.01, "epochs": 100})
    mlflow.log_metric("accuracy", 0.95)
    mlflow.sklearn.log_model(model, "model")
                    ''', language='python')

# Initialize and run the app
if __name__ == "__main__":
    app = AIEngineeringBestPractices()
    app.render_practice_viewer()`,
                        explanation: "This interactive documentation viewer demonstrates AI engineering best practices with live code examples. It showcases proper code structure, type hints, documentation, and interactive Streamlit components for educational purposes.",
                        steps: [
                            "Initialize AI Engineering Best Practices class with categorized practices",
                            "Create interactive category selector using Streamlit",
                            "Display expandable practice sections with descriptions",
                            "Show live code examples for each practice category"
                        ]
                    },
                    "rag-implementation": {
                        title: "RAG Implementation with LangChain",
                        code: `from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Chroma
from langchain.chains import RetrievalQA
from langchain.llms import OpenAI

# Initialize embeddings and vector store
embeddings = OpenAIEmbeddings()
vectorstore = Chroma.from_documents(
    documents, embeddings, persist_directory="./chroma_db"
)

# Create RAG chain
qa_chain = RetrievalQA.from_chain_type(
    llm=OpenAI(temperature=0),
    chain_type="stuff",
    retriever=vectorstore.as_retriever()
)

# Query the system
result = qa_chain.run("What is machine learning?")
print(result)`,
                        explanation: "This RAG implementation uses LangChain to create a retrieval-augmented generation system. It combines document embeddings with a vector database for efficient similarity search, then uses an LLM to generate contextual responses based on retrieved documents.",
                        steps: [
                            "Initialize OpenAI embeddings for document vectorization",
                            "Create Chroma vector store from documents",
                            "Set up RetrievalQA chain with OpenAI LLM",
                            "Execute query with automatic retrieval and generation"
                        ]
                    },
                    "agent-workflow": {
                        title: "Multi-Agent Workflow with AutoGen",
                        code: `from autogen import ConversableAgent, GroupChat, GroupChatManager

# Create specialized agents
researcher = ConversableAgent(
    name="researcher",
    system_message="You are a research specialist...",
    llm_config={"model": "gpt-4"}
)

analyst = ConversableAgent(
    name="analyst", 
    system_message="You analyze research findings...",
    llm_config={"model": "gpt-4"}
)

# Create group chat
group_chat = GroupChat(
    agents=[researcher, analyst],
    messages=[],
    max_round=10
)

manager = GroupChatManager(groupchat=group_chat)
result = researcher.initiate_chat(manager, message="Research AI trends")`,
                        explanation: "This multi-agent workflow demonstrates how AutoGen enables collaborative AI agents. Each agent has specialized roles and capabilities, working together through a group chat manager to accomplish complex tasks.",
                        steps: [
                            "Define specialized agents with unique system messages",
                            "Create group chat with defined agents",
                            "Initialize group chat manager for coordination",
                            "Start collaborative conversation between agents"
                        ]
                    },
                    "model-serving": {
                        title: "Model Serving with FastAPI",
                        code: `from fastapi import FastAPI
from pydantic import BaseModel
import torch
from transformers import pipeline

app = FastAPI()
model = pipeline("text-generation", model="gpt-2")

class QueryRequest(BaseModel):
    prompt: str
    max_length: int = 100

@app.post("/generate")
async def generate_text(request: QueryRequest):
    result = model(
        request.prompt,
        max_length=request.max_length,
        do_sample=True,
        temperature=0.7
    )
    return {"generated_text": result[0]["generated_text"]}

@app.get("/health")
async def health_check():
    return {"status": "healthy", "model": "gpt-2"}`,
                        explanation: "This FastAPI implementation shows how to serve AI models in production. It includes proper request validation, model loading, and health check endpoints for monitoring and reliability.",
                        steps: [
                            "Initialize FastAPI application and load model",
                            "Define Pydantic models for request validation",
                            "Create POST endpoint for text generation",
                            "Add health check endpoint for monitoring"
                        ]
                    },
                    "model-deployment-patterns": {
                        title: "Model Deployment Patterns Demo",
                        code: `# Model Deployment Patterns - Interactive Deployment Pattern Selector
import streamlit as st
import yaml
import json
from typing import Dict, List, Any
import docker
import kubernetes

class ModelDeploymentPatterns:
    def __init__(self):
        self.patterns = {
            "Single Model Serving": {
                "description": "Deploy a single model instance with load balancing",
                "use_case": "Simple inference workloads with consistent traffic",
                "docker_compose": """
version: '3.8'
services:
  model-server:
    image: tensorflow/serving:latest
    ports:
      - "8500:8500"
      - "8501:8501"
    volumes:
      - ./models:/models
    environment:
      - MODEL_NAME=my_model
    command: tensorflow_model_server --port=8500 --rest_api_port=8501 --model_name=my_model --model_base_path=/models
                """,
                "kubernetes": """
apiVersion: apps/v1
kind: Deployment
metadata:
  name: model-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: model-server
  template:
    metadata:
      labels:
        app: model-server
    spec:
      containers:
      - name: model-server
        image: tensorflow/serving:latest
        ports:
        - containerPort: 8500
        - containerPort: 8501
        volumeMounts:
        - name: model-storage
          mountPath: /models
      volumes:
      - name: model-storage
        persistentVolumeClaim:
          claimName: model-pvc
                """
            },
            "A/B Testing": {
                "description": "Deploy multiple model versions for A/B testing",
                "use_case": "Model comparison and gradual rollout",
                "docker_compose": """
version: '3.8'
services:
  model-a:
    image: my-model:v1.0
    ports:
      - "8500:8500"
    environment:
      - MODEL_VERSION=v1.0
  
  model-b:
    image: my-model:v2.0
    ports:
      - "8501:8500"
    environment:
      - MODEL_VERSION=v2.0
  
  load-balancer:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
                """,
                "kubernetes": """
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: model-rollout
spec:
  replicas: 5
  strategy:
    canary:
      steps:
      - setWeight: 20
      - pause: {duration: 10m}
      - setWeight: 40
      - pause: {duration: 10m}
      - setWeight: 60
      - pause: {duration: 10m}
      - setWeight: 80
      - pause: {duration: 10m}
  selector:
    matchLabels:
      app: model-server
  template:
    metadata:
      labels:
        app: model-server
    spec:
      containers:
      - name: model-server
        image: my-model:v2.0
        ports:
        - containerPort: 8500
                """
            },
            "Multi-Model Pipeline": {
                "description": "Deploy multiple models in a processing pipeline",
                "use_case": "Complex ML workflows with multiple model stages",
                "docker_compose": """
version: '3.8'
services:
  preprocessor:
    image: preprocessor:latest
    ports:
      - "8001:8000"
  
  model-1:
    image: model-1:latest
    ports:
      - "8002:8000"
    depends_on:
      - preprocessor
  
  model-2:
    image: model-2:latest
    ports:
      - "8003:8000"
    depends_on:
      - model-1
  
  orchestrator:
    image: orchestrator:latest
    ports:
      - "8000:8000"
    depends_on:
      - preprocessor
      - model-1
      - model-2
                """,
                "kubernetes": """
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  name: ml-pipeline
spec:
  entrypoint: ml-pipeline
  templates:
  - name: ml-pipeline
    dag:
      tasks:
      - name: preprocess
        template: preprocessor
      - name: model-1
        template: model-1
        dependencies: [preprocess]
      - name: model-2
        template: model-2
        dependencies: [model-1]
      - name: postprocess
        template: postprocessor
        dependencies: [model-2]
                """
            }
        }
    
    def render_deployment_selector(self):
        st.title("Model Deployment Patterns")
        st.markdown("Interactive deployment pattern selector with Docker/Kubernetes visualization")
        
        # Pattern selector
        pattern = st.selectbox("Select Deployment Pattern", list(self.patterns.keys()))
        
        # Display pattern details
        pattern_data = self.patterns[pattern]
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("📋 Pattern Details")
            st.write(f"**Description:** {pattern_data['description']}")
            st.write(f"**Use Case:** {pattern_data['use_case']}")
            
            # Architecture diagram
            st.subheader("🏗️ Architecture")
            if pattern == "Single Model Serving":
                st.graphviz_chart("""
                digraph {
                    Client -> LoadBalancer
                    LoadBalancer -> Model1
                    LoadBalancer -> Model2
                    LoadBalancer -> Model3
                }
                """)
            elif pattern == "A/B Testing":
                st.graphviz_chart("""
                digraph {
                    Client -> Router
                    Router -> ModelA [label="80%"]
                    Router -> ModelB [label="20%"]
                }
                """)
            elif pattern == "Multi-Model Pipeline":
                st.graphviz_chart("""
                digraph {
                    Input -> Preprocessor
                    Preprocessor -> Model1
                    Model1 -> Model2
                    Model2 -> Output
                }
                """)
        
        with col2:
            st.subheader("🐳 Docker Compose")
            st.code(pattern_data['docker_compose'], language='yaml')
            
            st.subheader("☸️ Kubernetes")
            st.code(pattern_data['kubernetes'], language='yaml')
        
        # Interactive deployment simulation
        if st.button("🚀 Simulate Deployment"):
            self.simulate_deployment(pattern)
    
    def simulate_deployment(self, pattern: str):
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        steps = [
            "Building Docker images...",
            "Pushing to container registry...",
            "Creating Kubernetes resources...",
            "Starting pods...",
            "Health checks...",
            "Deployment complete!"
        ]
        
        for i, step in enumerate(steps):
            status_text.text(step)
            progress_bar.progress((i + 1) / len(steps))
            time.sleep(1)
        
        st.success(f"✅ {pattern} deployment completed successfully!")

# Initialize and run the app
if __name__ == "__main__":
    app = ModelDeploymentPatterns()
    app.render_deployment_selector()`,
                        explanation: "This interactive deployment pattern selector demonstrates different model deployment strategies with Docker and Kubernetes configurations. It includes visual architecture diagrams and deployment simulation capabilities.",
                        steps: [
                            "Define deployment patterns with Docker Compose and Kubernetes configurations",
                            "Create interactive pattern selector with detailed descriptions",
                            "Display architecture diagrams using Graphviz",
                            "Simulate deployment process with progress tracking"
                        ]
                    },
                    "performance-optimization": {
                        title: "Performance Optimization Techniques Demo",
                        code: `# Performance Optimization Techniques - Performance Profiling Dashboard
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
import time
import psutil
import torch
import cProfile
import pstats
from io import StringIO

class PerformanceOptimizationDemo:
    def __init__(self):
        self.optimization_techniques = {
            "CUDA Kernel Optimization": {
                "description": "Optimize GPU kernel operations for maximum throughput",
                "techniques": [
                    "Memory coalescing for better bandwidth utilization",
                    "Shared memory usage to reduce global memory access",
                    "Occupancy optimization for better GPU utilization",
                    "Kernel fusion to reduce memory transfers"
                ],
                "code_example": """
# CUDA Kernel Optimization Example
import torch
import torch.nn as nn

class OptimizedConv2d(nn.Module):
    def __init__(self, in_channels, out_channels, kernel_size):
        super().__init__()
        self.conv = nn.Conv2d(in_channels, out_channels, kernel_size)
        # Enable cuDNN benchmarking for optimal algorithm selection
        torch.backends.cudnn.benchmark = True
        
    def forward(self, x):
        # Use mixed precision for better performance
        with torch.cuda.amp.autocast():
            return self.conv(x)

# Memory optimization
def optimize_memory_usage():
    # Clear cache
    torch.cuda.empty_cache()
    
    # Use gradient checkpointing
    model = torch.utils.checkpoint.checkpoint(model, input_tensor)
    
    # Optimize data loading
    dataloader = torch.utils.data.DataLoader(
        dataset, batch_size=32, num_workers=4, 
        pin_memory=True, persistent_workers=True
    )
                """
            },
            "Model Quantization": {
                "description": "Reduce model size and inference time through quantization",
                "techniques": [
                    "INT8 quantization for 4x speedup",
                    "Dynamic quantization for runtime optimization",
                    "Static quantization for deployment",
                    "Quantization-aware training for minimal accuracy loss"
                ],
                "code_example": """
# Model Quantization Example
import torch.quantization as quantization

# Dynamic quantization
model = torch.quantization.quantize_dynamic(
    model, {nn.Linear, nn.Conv2d}, dtype=torch.qint8
)

# Static quantization
model.eval()
model.qconfig = quantization.get_default_qconfig('fbgemm')
model_prepared = quantization.prepare(model)
# Calibrate with representative data
model_prepared(calibration_data)
model_quantized = quantization.convert(model_prepared)

# Quantization-aware training
model.qconfig = quantization.get_default_qat_qconfig('fbgemm')
model_prepared = quantization.prepare_qat(model)
# Train with quantization simulation
model_quantized = quantization.convert(model_prepared)
                """
            },
            "Batch Processing Optimization": {
                "description": "Optimize batch processing for better throughput",
                "techniques": [
                    "Dynamic batching for variable input sizes",
                    "Sequence packing for transformer models",
                    "Gradient accumulation for large effective batch sizes",
                    "Pipeline parallelism for model sharding"
                ],
                "code_example": """
# Batch Processing Optimization
import torch
from torch.utils.data import DataLoader

class DynamicBatching:
    def __init__(self, max_batch_size=32):
        self.max_batch_size = max_batch_size
        
    def create_batches(self, sequences):
        # Sort by length for efficient packing
        sequences.sort(key=len, reverse=True)
        batches = []
        
        for seq in sequences:
            if not batches or len(batches[-1]) >= self.max_batch_size:
                batches.append([seq])
            else:
                batches[-1].append(seq)
                
        return batches

# Gradient accumulation
def train_with_accumulation(model, dataloader, optimizer, accumulation_steps=4):
    model.train()
    optimizer.zero_grad()
    
    for i, batch in enumerate(dataloader):
        loss = model(batch)
        loss = loss / accumulation_steps
        loss.backward()
        
        if (i + 1) % accumulation_steps == 0:
            optimizer.step()
            optimizer.zero_grad()
                """
            },
            "Memory Optimization": {
                "description": "Optimize memory usage for large models and datasets",
                "techniques": [
                    "Gradient checkpointing to trade compute for memory",
                    "Model sharding across multiple GPUs",
                    "Offloading to CPU for large models",
                    "Memory-efficient attention mechanisms"
                ],
                "code_example": """
# Memory Optimization Techniques
import torch
import torch.distributed as dist
from torch.distributed.fsdp import FullyShardedDataParallel as FSDP

# Gradient checkpointing
def checkpointed_forward(model, x):
    return torch.utils.checkpoint.checkpoint(model, x)

# Model sharding with FSDP
def setup_fsdp_model(model):
    model = FSDP(model, mixed_precision=True)
    return model

# CPU offloading for large models
def offload_to_cpu(model):
    for param in model.parameters():
        param.data = param.data.cpu()
    return model

# Memory-efficient attention
class MemoryEfficientAttention(nn.Module):
    def forward(self, query, key, value):
        # Use flash attention or similar memory-efficient implementation
        return torch.nn.functional.scaled_dot_product_attention(
            query, key, value, is_causal=True
        )
                """
            }
        }
    
    def render_profiling_dashboard(self):
        st.title("Performance Optimization Techniques")
        st.markdown("Performance profiling dashboard with CUDA kernel optimization simulator")
        
        # Technique selector
        technique = st.selectbox("Select Optimization Technique", 
                               list(self.optimization_techniques.keys()))
        
        technique_data = self.optimization_techniques[technique]
        
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.subheader("📊 Performance Metrics")
            
            # Simulate performance metrics
            if st.button("🚀 Run Performance Test"):
                self.run_performance_test(technique)
            
            # Display optimization techniques
            st.subheader("🔧 Optimization Techniques")
            for i, tech in enumerate(technique_data["techniques"]):
                st.write(f"{i+1}. {tech}")
        
        with col2:
            st.subheader("💻 Code Example")
            st.code(technique_data["code_example"], language="python")
            
            st.subheader("📈 Performance Comparison")
            self.render_performance_chart(technique)
    
    def run_performance_test(self, technique):
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        steps = [
            "Initializing performance profiler...",
            "Running baseline benchmark...",
            "Applying optimization techniques...",
            "Measuring performance improvements...",
            "Generating optimization report...",
            "Performance test completed!"
        ]
        
        for i, step in enumerate(steps):
            status_text.text(step)
            progress_bar.progress((i + 1) / len(steps))
            time.sleep(0.5)
        
        st.success(f"✅ {technique} optimization test completed!")
    
    def render_performance_chart(self, technique):
        # Generate sample performance data
        techniques = ["Baseline", "Optimized"]
        performance_metrics = {
            "CUDA Kernel Optimization": {"latency": [100, 25], "throughput": [100, 400]},
            "Model Quantization": {"latency": [100, 20], "throughput": [100, 500]},
            "Batch Processing Optimization": {"latency": [100, 40], "throughput": [100, 250]},
            "Memory Optimization": {"latency": [100, 60], "throughput": [100, 167]}
        }
        
        metrics = performance_metrics[technique]
        
        fig = go.Figure()
        
        fig.add_trace(go.Bar(
            name="Latency (ms)",
            x=techniques,
            y=metrics["latency"],
            marker_color=["#FF6B6B", "#2EC4B6"]
        ))
        
        fig.add_trace(go.Bar(
            name="Throughput (req/s)",
            x=techniques,
            y=metrics["throughput"],
            marker_color=["#FFB700", "#8338EC"]
        ))
        
        fig.update_layout(
            title="Performance Comparison",
            xaxis_title="Configuration",
            yaxis_title="Performance",
            barmode="group"
        )
        
        st.plotly_chart(fig, use_container_width=True)

# Initialize and run the app
if __name__ == "__main__":
    app = PerformanceOptimizationDemo()
    app.render_profiling_dashboard()`,
                        explanation: "This performance profiling dashboard demonstrates CUDA kernel optimization and other performance techniques with interactive benchmarking and visualization capabilities.",
                        steps: [
                            "Initialize performance optimization techniques with code examples",
                            "Create interactive technique selector with detailed descriptions",
                            "Implement performance testing simulation with progress tracking",
                            "Display performance comparison charts with optimization metrics"
                        ]
                    },
                    "monitoring-observability": {
                        title: "Monitoring and Observability Demo",
                        code: `# Monitoring and Observability - Interactive Monitoring Dashboard
import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
import time
from datetime import datetime, timedelta
import json

class MonitoringObservabilityDemo:
    def __init__(self):
        self.monitoring_metrics = {
            "System Metrics": {
                "CPU Usage": {"current": 45, "threshold": 80, "unit": "%"},
                "Memory Usage": {"current": 62, "threshold": 85, "unit": "%"},
                "GPU Utilization": {"current": 78, "threshold": 90, "unit": "%"},
                "Disk I/O": {"current": 23, "threshold": 70, "unit": "MB/s"},
                "Network Traffic": {"current": 156, "threshold": 500, "unit": "Mbps"}
            },
            "Model Metrics": {
                "Inference Latency": {"current": 45, "threshold": 100, "unit": "ms"},
                "Throughput": {"current": 1200, "threshold": 800, "unit": "req/s"},
                "Error Rate": {"current": 0.2, "threshold": 1.0, "unit": "%"},
                "Model Accuracy": {"current": 94.5, "threshold": 90.0, "unit": "%"},
                "Memory Usage": {"current": 2.3, "threshold": 4.0, "unit": "GB"}
            },
            "Business Metrics": {
                "Active Users": {"current": 15420, "threshold": 20000, "unit": "users"},
                "API Calls": {"current": 45000, "threshold": 100000, "unit": "calls/hour"},
                "Revenue Impact": {"current": 98.5, "threshold": 95.0, "unit": "%"},
                "User Satisfaction": {"current": 4.2, "threshold": 4.0, "unit": "/5"},
                "Uptime": {"current": 99.9, "threshold": 99.5, "unit": "%"}
            }
        }
        
        self.alert_rules = {
            "Critical": [
                "Model accuracy drops below 90%",
                "Error rate exceeds 5%",
                "System uptime below 99%",
                "GPU utilization above 95%"
            ],
            "Warning": [
                "CPU usage above 80%",
                "Memory usage above 85%",
                "Inference latency above 100ms",
                "API response time above 500ms"
            ],
            "Info": [
                "New model version deployed",
                "Scheduled maintenance window",
                "Performance optimization completed",
                "New feature released"
            ]
        }
    
    def render_monitoring_dashboard(self):
        st.title("Monitoring and Observability Dashboard")
        st.markdown("Interactive monitoring dashboard with real-time metrics visualization")
        
        # Dashboard tabs
        tab1, tab2, tab3, tab4 = st.tabs(["📊 Metrics", "🚨 Alerts", "📈 Trends", "🔧 Configuration"])
        
        with tab1:
            self.render_metrics_tab()
        
        with tab2:
            self.render_alerts_tab()
        
        with tab3:
            self.render_trends_tab()
        
        with tab4:
            self.render_configuration_tab()
    
    def render_metrics_tab(self):
        st.subheader("Real-time System Metrics")
        
        # Create columns for different metric categories
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.subheader("🖥️ System Metrics")
            for metric, data in self.monitoring_metrics["System Metrics"].items():
                self.render_metric_card(metric, data)
        
        with col2:
            st.subheader("🤖 Model Metrics")
            for metric, data in self.monitoring_metrics["Model Metrics"].items():
                self.render_metric_card(metric, data)
        
        with col3:
            st.subheader("💼 Business Metrics")
            for metric, data in self.monitoring_metrics["Business Metrics"].items():
                self.render_metric_card(metric, data)
    
    def render_metric_card(self, metric_name, data):
        current = data["current"]
        threshold = data["threshold"]
        unit = data["unit"]
        
        # Determine status color
        if current > threshold:
            color = "🔴"  # Critical
        elif current > threshold * 0.8:
            color = "🟡"  # Warning
        else:
            color = "🟢"  # Healthy
        
        # Create metric card
        st.metric(
            label=f"{color} {metric_name}",
            value=f"{current} {unit}",
            delta=f"Threshold: {threshold} {unit}"
        )
    
    def render_alerts_tab(self):
        st.subheader("Alert Management")
        
        # Alert severity selector
        severity = st.selectbox("Filter by Severity", ["All", "Critical", "Warning", "Info"])
        
        # Display alerts
        if severity == "All":
            for sev, alerts in self.alert_rules.items():
                st.subheader(f"🚨 {sev} Alerts")
                for alert in alerts:
                    st.write(f"• {alert}")
        else:
            st.subheader(f"🚨 {severity} Alerts")
            for alert in self.alert_rules[severity]:
                st.write(f"• {alert}")
        
        # Alert simulation
        if st.button("🔔 Simulate New Alert"):
            self.simulate_alert()
    
    def simulate_alert(self):
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        steps = [
            "Monitoring system checks...",
            "Detecting anomaly...",
            "Evaluating alert rules...",
            "Sending notification...",
            "Alert processed!"
        ]
        
        for i, step in enumerate(steps):
            status_text.text(step)
            progress_bar.progress((i + 1) / len(steps))
            time.sleep(0.5)
        
        st.success("🚨 New alert generated: Model accuracy dropped to 89.2%")
    
    def render_trends_tab(self):
        st.subheader("Performance Trends")
        
        # Generate sample trend data
        dates = pd.date_range(start=datetime.now() - timedelta(days=7), 
                            end=datetime.now(), freq='H')
        
        # Create sample metrics data
        cpu_data = np.random.normal(45, 10, len(dates))
        memory_data = np.random.normal(62, 8, len(dates))
        latency_data = np.random.normal(45, 5, len(dates))
        
        # Create trend charts
        fig = go.Figure()
        
        fig.add_trace(go.Scatter(
            x=dates, y=cpu_data,
            mode='lines',
            name='CPU Usage (%)',
            line=dict(color='#FF6B6B')
        ))
        
        fig.add_trace(go.Scatter(
            x=dates, y=memory_data,
            mode='lines',
            name='Memory Usage (%)',
            line=dict(color='#2EC4B6')
        ))
        
        fig.add_trace(go.Scatter(
            x=dates, y=latency_data,
            mode='lines',
            name='Inference Latency (ms)',
            line=dict(color='#FFB700')
        ))
        
        fig.update_layout(
            title="System Performance Trends (Last 7 Days)",
            xaxis_title="Time",
            yaxis_title="Value",
            hovermode='x unified'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Performance summary
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Avg CPU Usage", "45.2%", "2.1%")
        with col2:
            st.metric("Avg Memory Usage", "62.8%", "1.3%")
        with col3:
            st.metric("Avg Latency", "44.7ms", "-0.8ms")
    
    def render_configuration_tab(self):
        st.subheader("Monitoring Configuration")
        
        # Alert thresholds configuration
        st.subheader("🚨 Alert Thresholds")
        
        col1, col2 = st.columns(2)
        
        with col1:
            cpu_threshold = st.slider("CPU Usage Threshold (%)", 0, 100, 80)
            memory_threshold = st.slider("Memory Usage Threshold (%)", 0, 100, 85)
            latency_threshold = st.slider("Latency Threshold (ms)", 0, 200, 100)
        
        with col2:
            error_threshold = st.slider("Error Rate Threshold (%)", 0, 10, 1)
            accuracy_threshold = st.slider("Accuracy Threshold (%)", 80, 100, 90)
            uptime_threshold = st.slider("Uptime Threshold (%)", 95, 100, 99)
        
        # Notification settings
        st.subheader("📧 Notification Settings")
        
        email_alerts = st.checkbox("Email Alerts", value=True)
        slack_alerts = st.checkbox("Slack Notifications", value=True)
        webhook_alerts = st.checkbox("Webhook Alerts", value=False)
        
        # Save configuration
        if st.button("💾 Save Configuration"):
            st.success("Configuration saved successfully!")
    
    def run_monitoring_simulation(self):
        st.subheader("🔍 Monitoring Simulation")
        
        if st.button("▶️ Start Monitoring Simulation"):
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            steps = [
                "Initializing monitoring agents...",
                "Collecting system metrics...",
                "Analyzing model performance...",
                "Checking alert conditions...",
                "Updating dashboard...",
                "Monitoring cycle complete!"
            ]
            
            for i, step in enumerate(steps):
                status_text.text(step)
                progress_bar.progress((i + 1) / len(steps))
                time.sleep(0.8)
            
            st.success("✅ Monitoring simulation completed successfully!")

# Initialize and run the app
if __name__ == "__main__":
    app = MonitoringObservabilityDemo()
    app.render_monitoring_dashboard()`,
                        explanation: "This interactive monitoring dashboard demonstrates real-time metrics visualization, alert management, and performance trend analysis for AI systems with comprehensive observability features.",
                        steps: [
                            "Initialize monitoring metrics with system, model, and business KPIs",
                            "Create interactive dashboard with real-time metric cards and status indicators",
                            "Implement alert management system with severity-based filtering",
                            "Display performance trends with time-series charts and summary statistics"
                        ]
                    },
                    "gpt-implementation": {
                        title: "GPT Implementation from Scratch Demo",
                        code: `# GPT Implementation from Scratch - Interactive Architecture Builder
import streamlit as st
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import time

class GPTArchitectureBuilder:
    def __init__(self):
        self.architecture_components = {
            "Token Embedding": {
                "description": "Convert tokens to dense vector representations",
                "parameters": {"vocab_size": 50257, "embed_dim": 768},
                "code": """
class TokenEmbedding(nn.Module):
    def __init__(self, vocab_size, embed_dim):
        super().__init__()
        self.embedding = nn.Embedding(vocab_size, embed_dim)
        
    def forward(self, x):
        return self.embedding(x)
                """
            },
            "Positional Encoding": {
                "description": "Add positional information to token embeddings",
                "parameters": {"max_seq_len": 1024, "embed_dim": 768},
                "code": """
class PositionalEncoding(nn.Module):
    def __init__(self, embed_dim, max_seq_len=1024):
        super().__init__()
        pe = torch.zeros(max_seq_len, embed_dim)
        position = torch.arange(0, max_seq_len).unsqueeze(1)
        
        div_term = torch.exp(torch.arange(0, embed_dim, 2) * 
                           -(np.log(10000.0) / embed_dim))
        
        pe[:, 0::2] = torch.sin(position * div_term)
        pe[:, 1::2] = torch.cos(position * div_term)
        pe = pe.unsqueeze(0)
        self.register_buffer('pe', pe)
        
    def forward(self, x):
        return x + self.pe[:, :x.size(1)]
                """
            },
            "Multi-Head Attention": {
                "description": "Self-attention mechanism with multiple attention heads",
                "parameters": {"embed_dim": 768, "num_heads": 12, "dropout": 0.1},
                "code": """
class MultiHeadAttention(nn.Module):
    def __init__(self, embed_dim, num_heads, dropout=0.1):
        super().__init__()
        self.embed_dim = embed_dim
        self.num_heads = num_heads
        self.head_dim = embed_dim // num_heads
        
        self.q_linear = nn.Linear(embed_dim, embed_dim)
        self.k_linear = nn.Linear(embed_dim, embed_dim)
        self.v_linear = nn.Linear(embed_dim, embed_dim)
        self.out_linear = nn.Linear(embed_dim, embed_dim)
        
        self.dropout = nn.Dropout(dropout)
        
    def forward(self, x, mask=None):
        batch_size, seq_len, embed_dim = x.size()
        
        # Linear transformations
        Q = self.q_linear(x)
        K = self.k_linear(x)
        V = self.v_linear(x)
        
        # Reshape for multi-head attention
        Q = Q.view(batch_size, seq_len, self.num_heads, self.head_dim).transpose(1, 2)
        K = K.view(batch_size, seq_len, self.num_heads, self.head_dim).transpose(1, 2)
        V = V.view(batch_size, seq_len, self.num_heads, self.head_dim).transpose(1, 2)
        
        # Scaled dot-product attention
        scores = torch.matmul(Q, K.transpose(-2, -1)) / np.sqrt(self.head_dim)
        
        if mask is not None:
            scores = scores.masked_fill(mask == 0, -1e9)
            
        attention_weights = F.softmax(scores, dim=-1)
        attention_weights = self.dropout(attention_weights)
        
        context = torch.matmul(attention_weights, V)
        context = context.transpose(1, 2).contiguous().view(
            batch_size, seq_len, embed_dim
        )
        
        return self.out_linear(context)
                """
            },
            "Feed Forward Network": {
                "description": "Position-wise feed-forward network with ReLU activation",
                "parameters": {"embed_dim": 768, "ff_dim": 3072, "dropout": 0.1},
                "code": """
class FeedForward(nn.Module):
    def __init__(self, embed_dim, ff_dim, dropout=0.1):
        super().__init__()
        self.linear1 = nn.Linear(embed_dim, ff_dim)
        self.linear2 = nn.Linear(ff_dim, embed_dim)
        self.dropout = nn.Dropout(dropout)
        
    def forward(self, x):
        return self.linear2(self.dropout(F.relu(self.linear1(x))))
                """
            },
            "Transformer Block": {
                "description": "Complete transformer block with attention and feed-forward layers",
                "parameters": {"embed_dim": 768, "num_heads": 12, "ff_dim": 3072, "dropout": 0.1},
                "code": """
class TransformerBlock(nn.Module):
    def __init__(self, embed_dim, num_heads, ff_dim, dropout=0.1):
        super().__init__()
        self.attention = MultiHeadAttention(embed_dim, num_heads, dropout)
        self.feed_forward = FeedForward(embed_dim, ff_dim, dropout)
        self.norm1 = nn.LayerNorm(embed_dim)
        self.norm2 = nn.LayerNorm(embed_dim)
        self.dropout = nn.Dropout(dropout)
        
    def forward(self, x, mask=None):
        # Self-attention with residual connection
        attn_output = self.attention(x, mask)
        x = self.norm1(x + self.dropout(attn_output))
        
        # Feed-forward with residual connection
        ff_output = self.feed_forward(x)
        x = self.norm2(x + self.dropout(ff_output))
        
        return x
                """
            },
            "GPT Model": {
                "description": "Complete GPT model with multiple transformer blocks",
                "parameters": {"vocab_size": 50257, "embed_dim": 768, "num_layers": 12, "num_heads": 12, "max_seq_len": 1024},
                "code": """
class GPT(nn.Module):
    def __init__(self, vocab_size, embed_dim, num_layers, num_heads, max_seq_len=1024):
        super().__init__()
        self.embed_dim = embed_dim
        self.token_embedding = TokenEmbedding(vocab_size, embed_dim)
        self.positional_encoding = PositionalEncoding(embed_dim, max_seq_len)
        
        self.transformer_blocks = nn.ModuleList([
            TransformerBlock(embed_dim, num_heads, embed_dim * 4)
            for _ in range(num_layers)
        ])
        
        self.layer_norm = nn.LayerNorm(embed_dim)
        self.lm_head = nn.Linear(embed_dim, vocab_size)
        
    def forward(self, x, mask=None):
        # Token and positional embeddings
        x = self.token_embedding(x)
        x = self.positional_encoding(x)
        
        # Pass through transformer blocks
        for transformer in self.transformer_blocks:
            x = transformer(x, mask)
            
        x = self.layer_norm(x)
        return self.lm_head(x)
                """
            }
        }
    
    def render_architecture_builder(self):
        st.title("GPT Implementation from Scratch")
        st.markdown("Interactive GPT architecture builder with step-by-step training visualization")
        
        # Architecture configuration
        st.subheader("🏗️ Architecture Configuration")
        
        col1, col2 = st.columns(2)
        
        with col1:
            vocab_size = st.slider("Vocabulary Size", 1000, 100000, 50257)
            embed_dim = st.slider("Embedding Dimension", 128, 1024, 768)
            num_layers = st.slider("Number of Layers", 1, 24, 12)
        
        with col2:
            num_heads = st.slider("Number of Attention Heads", 1, 16, 12)
            max_seq_len = st.slider("Maximum Sequence Length", 128, 2048, 1024)
            dropout = st.slider("Dropout Rate", 0.0, 0.5, 0.1)
        
        # Component selector
        st.subheader("🧩 Architecture Components")
        component = st.selectbox("Select Component to Explore", 
                               list(self.architecture_components.keys()))
        
        component_data = self.architecture_components[component]
        
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.subheader("📋 Component Details")
            st.write(f"**Description:** {component_data['description']}")
            
            st.subheader("⚙️ Parameters")
            for param, value in component_data['parameters'].items():
                st.write(f"• {param}: {value}")
        
        with col2:
            st.subheader("💻 Implementation")
            st.code(component_data['code'], language='python')
        
        # Training simulation
        st.subheader("🎓 Training Simulation")
        
        if st.button("🚀 Start Training Simulation"):
            self.simulate_training(vocab_size, embed_dim, num_layers, num_heads)
        
        # Architecture visualization
        st.subheader("📊 Architecture Visualization")
        self.render_architecture_diagram(num_layers, num_heads, embed_dim)
    
    def simulate_training(self, vocab_size, embed_dim, num_layers, num_heads):
        progress_bar = st.progress(0)
        status_text = st.empty()
        loss_chart = st.empty()
        
        # Simulate training steps
        steps = [
            "Initializing GPT model...",
            "Loading training data...",
            "Starting training loop...",
            "Computing forward pass...",
            "Calculating loss...",
            "Backpropagating gradients...",
            "Updating parameters...",
            "Training completed!"
        ]
        
        # Simulate loss reduction
        losses = []
        for i, step in enumerate(steps):
            status_text.text(step)
            progress_bar.progress((i + 1) / len(steps))
            
            # Simulate loss reduction
            if i > 2:  # After initialization
                loss = 10.0 * np.exp(-i * 0.3) + np.random.normal(0, 0.1)
                losses.append(max(loss, 0.1))
                
                # Update loss chart
                if len(losses) > 1:
                    fig = go.Figure()
                    fig.add_trace(go.Scatter(
                        y=losses,
                        mode='lines',
                        name='Training Loss',
                        line=dict(color='#FF6B6B')
                    ))
                    fig.update_layout(
                        title="Training Loss",
                        xaxis_title="Step",
                        yaxis_title="Loss",
                        height=300
                    )
                    loss_chart.plotly_chart(fig, use_container_width=True)
            
            time.sleep(0.8)
        
        st.success("✅ GPT training simulation completed successfully!")
    
    def render_architecture_diagram(self, num_layers, num_heads, embed_dim):
        # Create architecture diagram
        fig = go.Figure()
        
        # Add components
        components = [
            ("Token Embedding", 0, 0),
            ("Positional Encoding", 0, 1),
        ]
        
        # Add transformer blocks
        for i in range(num_layers):
            components.append((f"Transformer Block {i+1}", 1, i))
        
        components.extend([
            ("Layer Norm", 2, num_layers//2),
            ("Language Model Head", 3, num_layers//2)
        ])
        
        # Add nodes
        for name, x, y in components:
            fig.add_trace(go.Scatter(
                x=[x], y=[y],
                mode='markers+text',
                marker=dict(size=50, color='#3A86FF'),
                text=[name],
                textposition="middle center",
                name=name
            ))
        
        # Add connections
        for i in range(len(components)-1):
            fig.add_trace(go.Scatter(
                x=[components[i][1], components[i+1][1]],
                y=[components[i][2], components[i+1][2]],
                mode='lines',
                line=dict(color='#2EC4B6', width=2),
                showlegend=False
            ))
        
        fig.update_layout(
            title="GPT Architecture Diagram",
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            height=400,
            showlegend=False
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # Model statistics
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("Total Parameters", f"{num_layers * embed_dim * 4:,}")
        with col2:
            st.metric("Model Size", f"{num_layers * embed_dim * 4 * 4 / 1e6:.1f} MB")
        with col3:
            st.metric("Attention Heads", num_heads)

# Initialize and run the app
if __name__ == "__main__":
    app = GPTArchitectureBuilder()
    app.render_architecture_builder()`,
                        explanation: "This interactive GPT architecture builder demonstrates the complete implementation of GPT from scratch with step-by-step training visualization, component exploration, and architecture configuration.",
                        steps: [
                            "Initialize GPT architecture components with detailed implementations",
                            "Create interactive architecture configuration with parameter sliders",
                            "Implement training simulation with loss visualization and progress tracking",
                            "Display architecture diagram with component relationships and model statistics"
                        ]
                    },
                    "training-loop-implementation": {
                        title: "Training Loop Implementation Demo",
                        code: `# Training Loop Implementation - Interactive Training Loop Builder with Loss Function Visualization
import streamlit as st
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import time
import pandas as pd

class TrainingLoopBuilder:
    def __init__(self):
        self.training_metrics = {
            "epoch": [],
            "loss": [],
            "accuracy": [],
            "learning_rate": [],
            "gradient_norm": []
        }
        
        self.loss_functions = {
            "CrossEntropyLoss": nn.CrossEntropyLoss(),
            "MSELoss": nn.MSELoss(),
            "BCELoss": nn.BCELoss(),
            "L1Loss": nn.L1Loss(),
            "SmoothL1Loss": nn.SmoothL1Loss()
        }
        
        self.optimizers = {
            "Adam": lambda params, lr: optim.Adam(params, lr=lr),
            "SGD": lambda params, lr: optim.SGD(params, lr=lr, momentum=0.9),
            "AdamW": lambda params, lr: optim.AdamW(params, lr=lr),
            "RMSprop": lambda params, lr: optim.RMSprop(params, lr=lr)
        }
    
    def create_sample_model(self, input_size, hidden_size, output_size):
        return nn.Sequential(
            nn.Linear(input_size, hidden_size),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(hidden_size, hidden_size // 2),
            nn.ReLU(),
            nn.Linear(hidden_size // 2, output_size)
        )
    
    def generate_sample_data(self, num_samples, input_size, num_classes):
        X = torch.randn(num_samples, input_size)
        y = torch.randint(0, num_classes, (num_samples,))
        return X, y
    
    def training_step(self, model, data_loader, criterion, optimizer, device):
        model.train()
        total_loss = 0
        correct = 0
        total = 0
        
        for batch_idx, (data, target) in enumerate(data_loader):
            data, target = data.to(device), target.to(device)
            
            # Zero gradients
            optimizer.zero_grad()
            
            # Forward pass
            output = model(data)
            loss = criterion(output, target)
            
            # Backward pass
            loss.backward()
            
            # Calculate gradient norm
            grad_norm = torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
            
            # Optimizer step
            optimizer.step()
            
            # Metrics
            total_loss += loss.item()
            _, predicted = output.max(1)
            total += target.size(0)
            correct += predicted.eq(target).sum().item()
            
            yield {
                "batch": batch_idx,
                "loss": loss.item(),
                "accuracy": 100. * correct / total,
                "grad_norm": grad_norm.item()
            }
    
    def render_training_loop_builder(self):
        st.title("Training Loop Implementation Demo")
        st.markdown("Interactive training loop builder with real-time loss function visualization and gradient monitoring")
        
        # Training Configuration
        st.subheader("🏗️ Training Configuration")
        col1, col2, col3 = st.columns(3)
        
        with col1:
            input_size = st.slider("Input Size", 10, 1000, 128, step=10)
            hidden_size = st.slider("Hidden Size", 32, 512, 256, step=32)
            output_size = st.slider("Output Classes", 2, 10, 3)
            
        with col2:
            learning_rate = st.select_slider("Learning Rate", 
                                           options=[0.001, 0.003, 0.01, 0.03, 0.1], 
                                           value=0.01)
            batch_size = st.select_slider("Batch Size", 
                                        options=[16, 32, 64, 128, 256], 
                                        value=64)
            num_epochs = st.slider("Number of Epochs", 1, 50, 10)
            
        with col3:
            loss_function = st.selectbox("Loss Function", list(self.loss_functions.keys()))
            optimizer_type = st.selectbox("Optimizer", list(self.optimizers.keys()))
            device = st.selectbox("Device", ["cpu", "cuda" if torch.cuda.is_available() else "cpu"])
        
        # Model Architecture Visualization
        st.subheader("🧠 Model Architecture")
        arch_fig = go.Figure()
        
        layers = [
            {"name": "Input", "size": input_size, "x": 0, "color": "#3A86FF"},
            {"name": "Hidden 1", "size": hidden_size, "x": 1, "color": "#2EC4B6"},
            {"name": "Hidden 2", "size": hidden_size // 2, "x": 2, "color": "#8338EC"},
            {"name": "Output", "size": output_size, "x": 3, "color": "#FFB700"}
        ]
        
        for layer in layers:
            arch_fig.add_trace(go.Scatter(
                x=[layer["x"]], y=[0],
                mode='markers+text',
                marker=dict(size=max(20, min(100, layer["size"] / 10)), color=layer["color"]),
                text=f'{layer["name"]}<br>{layer["size"]} units',
                textposition="bottom center",
                name=layer["name"]
            ))
        
        # Add connections
        for i in range(len(layers) - 1):
            arch_fig.add_trace(go.Scatter(
                x=[layers[i]["x"], layers[i+1]["x"]],
                y=[0, 0],
                mode='lines',
                line=dict(color='gray', width=2),
                showlegend=False
            ))
        
        arch_fig.update_layout(
            title="Neural Network Architecture",
            xaxis=dict(showgrid=False, showticklabels=False),
            yaxis=dict(showgrid=False, showticklabels=False, range=[-1, 1]),
            height=300,
            template="plotly_dark"
        )
        st.plotly_chart(arch_fig, use_container_width=True)
        
        # Training Loop Execution
        if st.button("🚀 Start Training Loop", type="primary"):
            # Initialize model and components
            model = self.create_sample_model(input_size, hidden_size, output_size).to(device)
            criterion = self.loss_functions[loss_function]
            optimizer = self.optimizers[optimizer_type](model.parameters(), learning_rate)
            
            # Generate sample data
            X_train, y_train = self.generate_sample_data(1000, input_size, output_size)
            train_dataset = torch.utils.data.TensorDataset(X_train, y_train)
            train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
            
            # Training metrics containers
            loss_container = st.empty()
            metrics_container = st.empty()
            progress_bar = st.progress(0)
            
            # Real-time training visualization
            fig = make_subplots(
                rows=2, cols=2,
                subplot_titles=('Training Loss', 'Accuracy', 'Learning Rate Schedule', 'Gradient Norm'),
                specs=[[{"secondary_y": False}, {"secondary_y": False}],
                       [{"secondary_y": False}, {"secondary_y": False}]]
            )
            
            self.training_metrics = {"epoch": [], "loss": [], "accuracy": [], "learning_rate": [], "gradient_norm": []}
            
            # Training loop
            for epoch in range(num_epochs):
                epoch_loss = 0
                epoch_accuracy = 0
                epoch_grad_norm = 0
                num_batches = len(train_loader)
                
                for batch_metrics in self.training_step(model, train_loader, criterion, optimizer, device):
                    epoch_loss += batch_metrics["loss"]
                    epoch_accuracy = batch_metrics["accuracy"]
                    epoch_grad_norm += batch_metrics["grad_norm"]
                
                # Record epoch metrics
                avg_loss = epoch_loss / num_batches
                avg_grad_norm = epoch_grad_norm / num_batches
                current_lr = optimizer.param_groups[0]['lr']
                
                self.training_metrics["epoch"].append(epoch + 1)
                self.training_metrics["loss"].append(avg_loss)
                self.training_metrics["accuracy"].append(epoch_accuracy)
                self.training_metrics["learning_rate"].append(current_lr)
                self.training_metrics["gradient_norm"].append(avg_grad_norm)
                
                # Update visualizations
                fig = make_subplots(
                    rows=2, cols=2,
                    subplot_titles=('Training Loss', 'Accuracy (%)', 'Learning Rate', 'Gradient Norm'),
                    specs=[[{"secondary_y": False}, {"secondary_y": False}],
                           [{"secondary_y": False}, {"secondary_y": False}]]
                )
                
                # Loss plot
                fig.add_trace(go.Scatter(
                    x=self.training_metrics["epoch"],
                    y=self.training_metrics["loss"],
                    mode='lines+markers',
                    name='Loss',
                    line=dict(color='#FF6B6B', width=3)
                ), row=1, col=1)
                
                # Accuracy plot
                fig.add_trace(go.Scatter(
                    x=self.training_metrics["epoch"],
                    y=self.training_metrics["accuracy"],
                    mode='lines+markers',
                    name='Accuracy',
                    line=dict(color='#2EC4B6', width=3)
                ), row=1, col=2)
                
                # Learning rate plot
                fig.add_trace(go.Scatter(
                    x=self.training_metrics["epoch"],
                    y=self.training_metrics["learning_rate"],
                    mode='lines+markers',
                    name='Learning Rate',
                    line=dict(color='#8338EC', width=3)
                ), row=2, col=1)
                
                # Gradient norm plot
                fig.add_trace(go.Scatter(
                    x=self.training_metrics["epoch"],
                    y=self.training_metrics["gradient_norm"],
                    mode='lines+markers',
                    name='Gradient Norm',
                    line=dict(color='#FFB700', width=3)
                ), row=2, col=2)
                
                fig.update_layout(
                    title="Training Metrics Dashboard",
                    height=600,
                    template="plotly_dark",
                    showlegend=False
                )
                
                loss_container.plotly_chart(fig, use_container_width=True)
                
                # Update metrics display
                col1, col2, col3, col4 = metrics_container.columns(4)
                col1.metric("Current Loss", f"{avg_loss:.4f}")
                col2.metric("Accuracy", f"{epoch_accuracy:.2f}%")
                col3.metric("Learning Rate", f"{current_lr:.4f}")
                col4.metric("Grad Norm", f"{avg_grad_norm:.4f}")
                
                # Update progress
                progress_bar.progress((epoch + 1) / num_epochs)
                
                # Add small delay for visualization
                time.sleep(0.1)
            
            st.success("Training completed successfully!")
            
            # Training summary
            st.subheader("📊 Training Summary")
            summary_df = pd.DataFrame(self.training_metrics)
            st.dataframe(summary_df)
            
            # Model parameters info
            total_params = sum(p.numel() for p in model.parameters())
            trainable_params = sum(p.numel() for p in model.parameters() if p.requires_grad)
            
            col1, col2, col3 = st.columns(3)
            col1.metric("Total Parameters", f"{total_params:,}")
            col2.metric("Trainable Parameters", f"{trainable_params:,}")
            col3.metric("Final Loss", f"{self.training_metrics['loss'][-1]:.4f}")

# Initialize and run the app
if __name__ == "__main__":
    app = TrainingLoopBuilder()
    app.render_training_loop_builder()`,
                        explanation: "This interactive training loop builder demonstrates the complete implementation of a training loop with real-time loss function visualization, gradient monitoring, and comprehensive metrics tracking.",
                        steps: [
                            "Configure training parameters including model architecture, learning rate, and batch size",
                            "Visualize neural network architecture with interactive component sizing",
                            "Execute training loop with real-time loss and accuracy visualization",
                            "Monitor gradient norms and learning rate schedules with comprehensive metrics dashboard",
                            "Display training summary with parameter counts and final performance metrics"
                        ]
                    },
                    "model-evaluation-metrics": {
                        title: "Model Evaluation Metrics Demo",
                        code: `# Model Evaluation Metrics - Interactive Evaluation Calculator with Perplexity Analyzer
import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import math
from collections import Counter
import re
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import nltk
import warnings
warnings.filterwarnings('ignore')

class ModelEvaluationMetrics:
    def __init__(self):
        self.evaluation_results = {}
        
        # Sample texts for demonstration
        self.sample_references = [
            "The quick brown fox jumps over the lazy dog.",
            "Machine learning is a subset of artificial intelligence.",
            "Natural language processing enables computers to understand human language.",
            "Deep learning models use neural networks with multiple layers.",
            "Transformers have revolutionized the field of NLP."
        ]
        
        self.sample_candidates = [
            "A fast brown fox leaps over a sleepy dog.",
            "ML is a branch of AI technology.",
            "NLP allows machines to comprehend human speech.",
            "Deep neural networks contain many hidden layers.",
            "Transformer architectures changed NLP completely."
        ]
    
    def calculate_perplexity(self, text, vocab_size=10000):
        """Calculate perplexity for a given text"""
        # Simple tokenization
        tokens = re.findall(r'\b\w+\b', text.lower())
        if len(tokens) < 2:
            return float('inf')
        
        # Calculate bigram probabilities (simplified)
        bigrams = [(tokens[i], tokens[i+1]) for i in range(len(tokens)-1)]
        bigram_counts = Counter(bigrams)
        unigram_counts = Counter(tokens)
        
        # Calculate log probability
        log_prob = 0
        for bigram in bigrams:
            # Simple smoothing
            bigram_prob = (bigram_counts[bigram] + 1) / (unigram_counts[bigram[0]] + vocab_size)
            log_prob += math.log(bigram_prob)
        
        # Calculate perplexity
        perplexity = math.exp(-log_prob / len(bigrams))
        return perplexity
    
    def calculate_bleu_score(self, reference, candidate, n=4):
        """Calculate BLEU score"""
        ref_tokens = reference.lower().split()
        cand_tokens = candidate.lower().split()
        
        if len(cand_tokens) == 0:
            return 0
        
        # Calculate n-gram precisions
        precisions = []
        for i in range(1, n+1):
            ref_ngrams = [tuple(ref_tokens[j:j+i]) for j in range(len(ref_tokens)-i+1)]
            cand_ngrams = [tuple(cand_tokens[j:j+i]) for j in range(len(cand_tokens)-i+1)]
            
            if len(cand_ngrams) == 0:
                precisions.append(0)
                continue
                
            ref_counts = Counter(ref_ngrams)
            cand_counts = Counter(cand_ngrams)
            
            overlap = sum(min(ref_counts[ngram], cand_counts[ngram]) for ngram in cand_counts)
            precision = overlap / len(cand_ngrams)
            precisions.append(precision)
        
        # Geometric mean
        if any(p == 0 for p in precisions):
            return 0
        
        bleu = (np.prod(precisions) ** (1/n))
        
        # Brevity penalty
        bp = min(1, math.exp(1 - len(ref_tokens) / len(cand_tokens)))
        
        return bp * bleu
    
    def calculate_rouge_score(self, reference, candidate):
        """Calculate ROUGE-L score"""
        ref_tokens = reference.lower().split()
        cand_tokens = candidate.lower().split()
        
        # Longest Common Subsequence
        def lcs_length(x, y):
            m, n = len(x), len(y)
            dp = [[0] * (n + 1) for _ in range(m + 1)]
            
            for i in range(1, m + 1):
                for j in range(1, n + 1):
                    if x[i-1] == y[j-1]:
                        dp[i][j] = dp[i-1][j-1] + 1
                    else:
                        dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            
            return dp[m][n]
        
        lcs_len = lcs_length(ref_tokens, cand_tokens)
        
        if len(ref_tokens) == 0 or len(cand_tokens) == 0:
            return 0
        
        precision = lcs_len / len(cand_tokens) if len(cand_tokens) > 0 else 0
        recall = lcs_len / len(ref_tokens) if len(ref_tokens) > 0 else 0
        
        if precision + recall == 0:
            return 0
        
        f1 = 2 * precision * recall / (precision + recall)
        return f1
    
    def calculate_semantic_similarity(self, reference, candidate):
        """Calculate semantic similarity using TF-IDF and cosine similarity"""
        vectorizer = TfidfVectorizer()
        try:
            tfidf_matrix = vectorizer.fit_transform([reference, candidate])
            similarity = cosine_similarity(tfidf_matrix[0:1], tfidf_matrix[1:2])[0][0]
            return similarity
        except:
            return 0
    
    def evaluate_classification_metrics(self, y_true, y_pred):
        """Calculate classification metrics"""
        return {
            'accuracy': accuracy_score(y_true, y_pred),
            'precision': precision_score(y_true, y_pred, average='weighted', zero_division=0),
            'recall': recall_score(y_true, y_pred, average='weighted', zero_division=0),
            'f1': f1_score(y_true, y_pred, average='weighted', zero_division=0)
        }
    
    def render_evaluation_demo(self):
        st.title("Model Evaluation Metrics Demo")
        st.markdown("Interactive evaluation calculator with perplexity analyzer and comprehensive metrics")
        
        # Evaluation Type Selection
        st.subheader("📊 Evaluation Type")
        eval_type = st.selectbox(
            "Select Evaluation Type",
            ["Text Generation", "Text Classification", "Custom Text Evaluation"]
        )
        
        if eval_type == "Text Generation":
            self.render_text_generation_eval()
        elif eval_type == "Text Classification":
            self.render_classification_eval()
        else:
            self.render_custom_text_eval()
    
    def render_text_generation_eval(self):
        st.subheader("📝 Text Generation Evaluation")
        
        # Input options
        input_option = st.radio("Input Method", ["Use Sample Data", "Enter Custom Text"])
        
        if input_option == "Use Sample Data":
            st.write("Using predefined reference and candidate texts:")
            references = self.sample_references
            candidates = self.sample_candidates
        else:
            st.write("Enter your own texts:")
            num_pairs = st.slider("Number of text pairs", 1, 10, 3)
            references = []
            candidates = []
            
            for i in range(num_pairs):
                col1, col2 = st.columns(2)
                with col1:
                    ref = st.text_area(f"Reference Text {i+1}", key=f"ref_{i}")
                    references.append(ref)
                with col2:
                    cand = st.text_area(f"Candidate Text {i+1}", key=f"cand_{i}")
                    candidates.append(cand)
        
        if st.button("🚀 Calculate Metrics", type="primary"):
            # Calculate metrics for each pair
            results = []
            for i, (ref, cand) in enumerate(zip(references, candidates)):
                if ref and cand:  # Only evaluate non-empty texts
                    perplexity = self.calculate_perplexity(cand)
                    bleu = self.calculate_bleu_score(ref, cand)
                    rouge = self.calculate_rouge_score(ref, cand)
                    semantic_sim = self.calculate_semantic_similarity(ref, cand)
                    
                    results.append({
                        'Pair': i+1,
                        'Perplexity': perplexity,
                        'BLEU Score': bleu,
                        'ROUGE-L': rouge,
                        'Semantic Similarity': semantic_sim,
                        'Reference': ref[:50] + "..." if len(ref) > 50 else ref,
                        'Candidate': cand[:50] + "..." if len(cand) > 50 else cand
                    })
            
            if results:
                # Display results table
                st.subheader("📊 Evaluation Results")
                df = pd.DataFrame(results)
                st.dataframe(df, use_container_width=True)
                
                # Metrics visualization
                fig = make_subplots(
                    rows=2, cols=2,
                    subplot_titles=('Perplexity (Lower is Better)', 'BLEU Score', 'ROUGE-L Score', 'Semantic Similarity'),
                    specs=[[{"secondary_y": False}, {"secondary_y": False}],
                           [{"secondary_y": False}, {"secondary_y": False}]]
                )
                
                pairs = [f"Pair {i}" for i in df['Pair']]
                
                # Perplexity (inverted scale for better visualization)
                fig.add_trace(go.Bar(
                    x=pairs,
                    y=df['Perplexity'],
                    name='Perplexity',
                    marker_color='#FF6B6B'
                ), row=1, col=1)
                
                # BLEU Score
                fig.add_trace(go.Bar(
                    x=pairs,
                    y=df['BLEU Score'],
                    name='BLEU',
                    marker_color='#2EC4B6'
                ), row=1, col=2)
                
                # ROUGE-L Score
                fig.add_trace(go.Bar(
                    x=pairs,
                    y=df['ROUGE-L'],
                    name='ROUGE-L',
                    marker_color='#8338EC'
                ), row=2, col=1)
                
                # Semantic Similarity
                fig.add_trace(go.Bar(
                    x=pairs,
                    y=df['Semantic Similarity'],
                    name='Semantic Similarity',
                    marker_color='#FFB700'
                ), row=2, col=2)
                
                fig.update_layout(
                    title="Text Generation Evaluation Metrics",
                    height=600,
                    template="plotly_dark",
                    showlegend=False
                )
                
                st.plotly_chart(fig, use_container_width=True)
                
                # Summary statistics
                st.subheader("📈 Summary Statistics")
                col1, col2, col3, col4 = st.columns(4)
                
                col1.metric("Avg Perplexity", f"{df['Perplexity'].mean():.2f}")
                col2.metric("Avg BLEU", f"{df['BLEU Score'].mean():.3f}")
                col3.metric("Avg ROUGE-L", f"{df['ROUGE-L'].mean():.3f}")
                col4.metric("Avg Semantic Sim", f"{df['Semantic Similarity'].mean():.3f}")
    
    def render_classification_eval(self):
        st.subheader("🎯 Text Classification Evaluation")
        
        # Generate sample classification data
        np.random.seed(42)
        n_samples = st.slider("Number of samples", 50, 500, 200)
        n_classes = st.slider("Number of classes", 2, 5, 3)
        
        # Simulate predictions with some noise
        y_true = np.random.randint(0, n_classes, n_samples)
        # Add some prediction errors
        y_pred = y_true.copy()
        error_rate = st.slider("Error rate", 0.0, 0.5, 0.15)
        n_errors = int(n_samples * error_rate)
        error_indices = np.random.choice(n_samples, n_errors, replace=False)
        y_pred[error_indices] = np.random.randint(0, n_classes, n_errors)
        
        if st.button("📊 Calculate Classification Metrics", type="primary"):
            # Calculate metrics
            metrics = self.evaluate_classification_metrics(y_true, y_pred)
            
            # Display metrics
            st.subheader("📊 Classification Results")
            col1, col2, col3, col4 = st.columns(4)
            
            col1.metric("Accuracy", f"{metrics['accuracy']:.3f}")
            col2.metric("Precision", f"{metrics['precision']:.3f}")
            col3.metric("Recall", f"{metrics['recall']:.3f}")
            col4.metric("F1 Score", f"{metrics['f1']:.3f}")
            
            # Confusion Matrix Visualization
            from sklearn.metrics import confusion_matrix
            cm = confusion_matrix(y_true, y_pred)
            
            fig = go.Figure(data=go.Heatmap(
                z=cm,
                x=[f'Predicted {i}' for i in range(n_classes)],
                y=[f'True {i}' for i in range(n_classes)],
                colorscale='Blues',
                showscale=True
            ))
            
            fig.update_layout(
                title="Confusion Matrix",
                xaxis_title="Predicted Labels",
                yaxis_title="True Labels",
                template="plotly_dark"
            )
            
            st.plotly_chart(fig, use_container_width=True)
            
            # Metrics comparison
            metrics_df = pd.DataFrame([metrics])
            st.subheader("📈 Metrics Details")
            st.dataframe(metrics_df, use_container_width=True)
    
    def render_custom_text_eval(self):
        st.subheader("✏️ Custom Text Evaluation")
        
        col1, col2 = st.columns(2)
        
        with col1:
            reference_text = st.text_area(
                "Reference Text",
                "The quick brown fox jumps over the lazy dog.",
                height=150
            )
        
        with col2:
            candidate_text = st.text_area(
                "Candidate Text",
                "A fast brown fox leaps over a sleepy dog.",
                height=150
            )
        
        if st.button("🔍 Analyze Texts", type="primary"):
            if reference_text and candidate_text:
                # Calculate all metrics
                perplexity = self.calculate_perplexity(candidate_text)
                bleu = self.calculate_bleu_score(reference_text, candidate_text)
                rouge = self.calculate_rouge_score(reference_text, candidate_text)
                semantic_sim = self.calculate_semantic_similarity(reference_text, candidate_text)
                
                # Display results
                st.subheader("📊 Analysis Results")
                
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("Perplexity", f"{perplexity:.2f}")
                col2.metric("BLEU Score", f"{bleu:.3f}")
                col3.metric("ROUGE-L", f"{rouge:.3f}")
                col4.metric("Semantic Similarity", f"{semantic_sim:.3f}")
                
                # Detailed analysis
                st.subheader("🔬 Detailed Analysis")
                
                # Text statistics
                ref_words = len(reference_text.split())
                cand_words = len(candidate_text.split())
                
                stats_df = pd.DataFrame({
                    'Metric': ['Word Count', 'Character Count', 'Sentence Count'],
                    'Reference': [ref_words, len(reference_text), reference_text.count('.') + reference_text.count('!') + reference_text.count('?')],
                    'Candidate': [cand_words, len(candidate_text), candidate_text.count('.') + candidate_text.count('!') + candidate_text.count('?')]
                })
                
                st.dataframe(stats_df, use_container_width=True)
                
                # Interpretation guide
                st.subheader("📖 Metrics Interpretation")
                st.write("""
                - **Perplexity**: Lower values indicate better language modeling (typical range: 10-200)
                - **BLEU Score**: Higher values indicate better translation/generation quality (0-1 scale)
                - **ROUGE-L**: Higher values indicate better summarization quality (0-1 scale)
                - **Semantic Similarity**: Higher values indicate more similar meaning (0-1 scale)
                """)

# Initialize and run the app
if __name__ == "__main__":
    app = ModelEvaluationMetrics()
    app.render_evaluation_demo()`,
                        explanation: "This interactive model evaluation framework provides comprehensive metrics calculation including perplexity analysis, BLEU/ROUGE scores, semantic similarity, and classification metrics with detailed visualizations.",
                        steps: [
                            "Select evaluation type: text generation, classification, or custom evaluation",
                            "Input reference and candidate texts or use sample data",
                            "Calculate comprehensive metrics including perplexity, BLEU, ROUGE, and semantic similarity",
                            "Visualize results with interactive charts and confusion matrices",
                            "Display summary statistics and detailed analysis with interpretation guidance"
                        ]
                    },
                    "mcp-integration": {
                        title: "MCP Integration Example",
                        code: `from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
import asyncio

async def main():
    # Connect to MCP server
    server_params = StdioServerParameters(
        command="python", 
        args=["-m", "mcp_server"]
    )
    
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            # Initialize session
            await session.initialize()
            
            # List available tools
            tools = await session.list_tools()
            print(f"Available tools: {[t.name for t in tools.tools]}")
            
            # Call a tool
            result = await session.call_tool(
                "search_documents",
                arguments={"query": "AI architecture patterns"}
            )
            print(f"Search result: {result.content}")

asyncio.run(main())`,
                        explanation: "This MCP integration example demonstrates how to connect to and interact with Model Context Protocol servers. It shows the complete workflow from connection to tool discovery and execution.",
                        steps: [
                            "Set up MCP server connection parameters",
                            "Establish client session with stdio transport",
                            "Initialize session and discover available tools",
                            "Execute tool calls with proper argument handling"
                        ]
                    }
                };

                let currentDemo = "ai-engineering-best-practices";
                let currentStep = 0;
                let isRunning = false;

                // Initialize the demo
                function initializeDemo() {
                    updateCodeDisplay();
                    updateExplanation();
                    renderExecutionFlow();
                    updateMetrics();
                }

                // Update code display with responsive syntax highlighting
                function updateCodeDisplay() {
                    const codeEditor = document.getElementById("animated-code-editor");
                    const example = codeExamples[currentDemo];
                    const editorBounds = codeEditor.getBoundingClientRect();
                    const isSmallCodeScreen = editorBounds.width < 400;

                    // Clear previous content
                    codeEditor.innerHTML = "";

                    // Add responsive line numbers and syntax highlighting
                    const lines = example.code.split('\n');
                    lines.forEach((line, index) => {
                        const lineDiv = document.createElement('div');
                        lineDiv.className = 'code-line';
                        lineDiv.style.opacity = '0';
                        lineDiv.style.transform = 'translateX(-20px)';
                        lineDiv.style.fontSize = isSmallCodeScreen ? '11px' : '13px';
                        lineDiv.style.lineHeight = isSmallCodeScreen ? '1.3' : '1.5';

                        const lineNumber = document.createElement('span');
                        lineNumber.className = 'line-number';
                        lineNumber.textContent = String(index + 1).padStart(2, '0');
                        lineNumber.style.color = 'var(--text-secondary)';
                        lineNumber.style.marginRight = isSmallCodeScreen ? '6px' : '10px';
                        lineNumber.style.userSelect = 'none';
                        lineNumber.style.fontSize = isSmallCodeScreen ? '10px' : '12px';

                        const lineContent = document.createElement('span');
                        lineContent.className = 'line-content';
                        lineContent.innerHTML = highlightSyntax(line);
                        lineContent.style.fontSize = isSmallCodeScreen ? '11px' : '13px';

                        lineDiv.appendChild(lineNumber);
                        lineDiv.appendChild(lineContent);
                        codeEditor.appendChild(lineDiv);

                        // Animate line appearance
                        setTimeout(() => {
                            lineDiv.style.transition = 'all 0.3s ease';
                            lineDiv.style.opacity = '1';
                            lineDiv.style.transform = 'translateX(0)';
                        }, index * 100);
                    });
                }

                // Simple syntax highlighting
                function highlightSyntax(code) {
                    return code
                        .replace(/\b(from|import|def|class|async|await|return|if|else|for|while|try|except|with|as)\b/g, '<span class="token keyword">$1</span>')
                        .replace(/\b(OpenAI|FastAPI|pipeline|ClientSession)\b/g, '<span class="token function">$1</span>')
                        .replace(/"([^"]*)"/g, '<span class="token string">"$1"</span>')
                        .replace(/'([^']*)'/g, '<span class="token string">\'$1\'</span>')
                        .replace(/#([^\n]*)/g, '<span class="token comment">#$1</span>');
                }

                // Update explanation
                function updateExplanation() {
                    const explanation = document.getElementById("code-explanation");
                    const example = codeExamples[currentDemo];

                    explanation.innerHTML = `
                    <div class="mb-2"><strong>${example.title}</strong></div>
                    <div class="mb-3">${example.explanation}</div>
                    <div><strong>Key Steps:</strong></div>
                    <ul class="list-disc list-inside mt-1">
                        ${example.steps.map(step => `<li>${step}</li>`).join('')}
                    </ul>
                `;
                }

                // Render responsive execution flow visualization
                function renderExecutionFlow() {
                    const example = codeExamples[currentDemo];
                    const steps = example.steps;

                    svg.selectAll("*").remove();

                    // Responsive flow node sizing
                    const nodeWidth = isSmallScreen ? 80 : isMediumScreen ? 100 : 120;
                    const nodeHeight = isSmallScreen ? 45 : isMediumScreen ? 50 : 60;
                    const spacing = isSmallScreen ? 10 : 20;
                    const totalWidth = steps.length * (nodeWidth + spacing) - spacing;
                    const startX = Math.max(10, (width - totalWidth) / 2);

                    const nodes = steps.map((step, i) => ({
                        x: startX + i * (nodeWidth + spacing),
                        y: height / 2,
                        text: step,
                        index: i
                    }));

                    // Draw connections
                    for (let i = 0; i < nodes.length - 1; i++) {
                        svg.append("line")
                            .attr("x1", nodes[i].x + nodeWidth)
                            .attr("y1", nodes[i].y + nodeHeight / 2)
                            .attr("x2", nodes[i + 1].x)
                            .attr("y2", nodes[i + 1].y + nodeHeight / 2)
                            .attr("stroke", "var(--accent-cyan)")
                            .attr("stroke-width", 2)
                            .attr("opacity", 0.3)
                            .attr("marker-end", "url(#arrow)");
                    }

                    // Draw nodes
                    const nodeGroups = svg.selectAll(".flow-node")
                        .data(nodes)
                        .enter().append("g")
                        .attr("class", "flow-node")
                        .attr("transform", d => `translate(${d.x}, ${d.y})`);

                    nodeGroups.append("rect")
                        .attr("width", nodeWidth)
                        .attr("height", nodeHeight)
                        .attr("rx", 8)
                        .attr("fill", "var(--accent-blue)")
                        .attr("opacity", 0.8)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);

                    nodeGroups.append("text")
                        .attr("x", nodeWidth / 2)
                        .attr("y", nodeHeight / 2)
                        .attr("text-anchor", "middle")
                        .attr("dy", "0.35em")
                        .attr("fill", "white")
                        .style("font-size", isSmallScreen ? "8px" : "10px")
                        .style("font-weight", "500")
                        .text(d => isSmallScreen ? `${d.index + 1}` : `Step ${d.index + 1}`);

                    // Add arrow marker
                    svg.append("defs").append("marker")
                        .attr("id", "arrow")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 8)
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", "var(--accent-cyan)");
                }

                // Update performance metrics
                function updateMetrics() {
                    const metrics = document.getElementById("demo-metrics");
                    const executionTime = Math.floor(Math.random() * 500) + 100;
                    const memoryUsage = Math.floor(Math.random() * 50) + 10;
                    const apiCalls = Math.floor(Math.random() * 5) + 1;
                    const successRate = Math.floor(Math.random() * 10) + 90;

                    metrics.innerHTML = `
                    <div>Execution Time: <span class="text-accent-green">${executionTime}ms</span></div>
                    <div>Memory Usage: <span class="text-accent-cyan">${memoryUsage}MB</span></div>
                    <div>API Calls: <span class="text-accent-purple">${apiCalls}</span></div>
                    <div>Success Rate: <span class="text-accent-green">${successRate}%</span></div>
                `;
                }

                // Simulate code execution
                function simulateExecution() {
                    const console = document.getElementById("demo-console");
                    const example = codeExamples[currentDemo];

                    console.innerHTML = "";

                    const outputs = {
                        "ai-engineering-best-practices": [
                            "Initializing AI Engineering Best Practices viewer...",
                            "Loading practice categories...",
                            "Rendering interactive documentation...",
                            "Setting up code examples...",
                            "Practice viewer ready! Select a category to explore best practices.",
                            "✅ AI Engineering Best Practices demo loaded successfully"
                        ],
                        "model-deployment-patterns": [
                            "Loading Model Deployment Patterns selector...",
                            "Initializing Docker Compose configurations...",
                            "Setting up Kubernetes manifests...",
                            "Creating architecture diagrams...",
                            "Deployment pattern selector ready!",
                            "✅ Model Deployment Patterns demo loaded successfully"
                        ],
                        "performance-optimization": [
                            "Initializing Performance Optimization dashboard...",
                            "Loading CUDA kernel optimization techniques...",
                            "Setting up performance profiling tools...",
                            "Configuring benchmarking metrics...",
                            "Performance optimization dashboard ready!",
                            "✅ Performance Optimization Techniques demo loaded successfully"
                        ],
                        "monitoring-observability": [
                            "Starting Monitoring and Observability dashboard...",
                            "Initializing real-time metrics collection...",
                            "Setting up alert management system...",
                            "Configuring performance trend analysis...",
                            "Monitoring dashboard operational!",
                            "✅ Monitoring and Observability demo loaded successfully"
                        ],
                        "gpt-implementation": [
                            "Initializing GPT Architecture Builder...",
                            "Loading transformer components...",
                            "Setting up architecture configuration...",
                            "Preparing training simulation...",
                            "GPT implementation demo ready!",
                            "✅ GPT Implementation from Scratch demo loaded successfully"
                        ],
                        "training-loop-implementation": [
                            "Initializing Training Loop Builder...",
                            "Setting up loss function visualization...",
                            "Configuring optimizer parameters...",
                            "Preparing gradient computation...",
                            "Loading training metrics dashboard...",
                            "Training loop implementation demo ready!",
                            "✅ Training Loop Implementation demo loaded successfully"
                        ],
                        "model-evaluation-metrics": [
                            "Initializing Model Evaluation Framework...",
                            "Loading evaluation metrics library...",
                            "Setting up perplexity analyzer...",
                            "Configuring BLEU and ROUGE calculators...",
                            "Preparing semantic similarity evaluator...",
                            "Model evaluation metrics demo ready!",
                            "✅ Model Evaluation Metrics demo loaded successfully"
                        ],
                        "rag-implementation": [
                            "Initializing OpenAI embeddings...",
                            "Creating vector store from documents...",
                            "Setting up RetrievalQA chain...",
                            "Processing query: 'What is machine learning?'",
                            "Retrieved 3 relevant documents",
                            "Generated response: 'Machine learning is a subset of AI...'"
                        ],
                        "agent-workflow": [
                            "Initializing AutoGen agents...",
                            "Creating researcher agent...",
                            "Creating analyst agent...",
                            "Setting up group chat...",
                            "Starting collaborative conversation...",
                            "Research completed: Found 5 key AI trends"
                        ],
                        "model-serving": [
                            "Loading FastAPI application...",
                            "Initializing GPT-2 model...",
                            "Starting server on port 8000...",
                            "Health check: OK",
                            "Received generation request...",
                            "Generated text: 'The future of AI...'"
                        ],
                        "mcp-integration": [
                            "Connecting to MCP server...",
                            "Establishing client session...",
                            "Discovering available tools...",
                            "Found 3 tools: search_documents, analyze_data, generate_report",
                            "Executing search_documents...",
                            "Search completed: Found 10 relevant documents"
                        ]
                    };

                    const messages = outputs[currentDemo] || ["Demo output not available"];

                    messages.forEach((message, index) => {
                        setTimeout(() => {
                            const line = document.createElement('div');
                            line.textContent = `> ${message}`;
                            line.style.opacity = '0';
                            line.style.transform = 'translateY(10px)';
                            console.appendChild(line);

                            setTimeout(() => {
                                line.style.transition = 'all 0.3s ease';
                                line.style.opacity = '1';
                                line.style.transform = 'translateY(0)';
                            }, 50);

                            console.scrollTop = console.scrollHeight;
                        }, index * 800);
                    });
                }

                // Event listeners
                document.getElementById("demo-selector").addEventListener("change", function () {
                    currentDemo = this.value;
                    currentStep = 0;
                    initializeDemo();
                });

                document.getElementById("run-demo").addEventListener("click", function () {
                    if (isRunning) return;
                    isRunning = true;
                    this.textContent = "⏸️ Pause";
                    this.style.backgroundColor = "var(--accent-purple)";

                    simulateExecution();
                    updateMetrics();

                    setTimeout(() => {
                        isRunning = false;
                        this.textContent = "▶️ Run Demo";
                        this.style.backgroundColor = "var(--accent-green)";
                    }, 5000);
                });

                document.getElementById("step-through").addEventListener("click", function () {
                    // Step through animation
                    const lines = document.querySelectorAll('.code-line');
                    lines.forEach((line, index) => {
                        setTimeout(() => {
                            line.style.backgroundColor = 'rgba(58, 134, 255, 0.2)';
                            setTimeout(() => {
                                line.style.backgroundColor = 'transparent';
                            }, 1000);
                        }, index * 500);
                    });
                });

                document.getElementById("reset-demo").addEventListener("click", function () {
                    currentStep = 0;
                    document.getElementById("demo-console").innerHTML = "";
                    updateMetrics();
                    initializeDemo();
                });

                // Initialize
                initializeDemo();
            }

            /** Renders the LLM Architecture Performance Comparison visualization with comprehensive metrics. */
            function renderLLMPerformanceViz() {
                const container = d3.select("#llm-performance-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;
                
                const margin = { top: 60, right: 80, bottom: 80, left: 80 };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                
                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced gradient definitions for performance visualization
                const defs = svg.append("defs");
                
                // Performance gradient (green spectrum)
                const performanceGrad = defs.append("linearGradient")
                    .attr("id", "performance-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");
                performanceGrad.append("stop").attr("offset", "0%").attr("stop-color", "var(--color-performance)").attr("stop-opacity", 0.8);
                performanceGrad.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-green-dark)").attr("stop-opacity", 0.6);
                
                // Speed gradient (blue spectrum)
                const speedGrad = defs.append("linearGradient")
                    .attr("id", "speed-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");
                speedGrad.append("stop").attr("offset", "0%").attr("stop-color", "var(--color-alignment)").attr("stop-opacity", 0.8);
                speedGrad.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-blue-dark)").attr("stop-opacity", 0.6);
                
                // Memory gradient (purple spectrum)
                const memoryGrad = defs.append("linearGradient")
                    .attr("id", "memory-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");
                memoryGrad.append("stop").attr("offset", "0%").attr("stop-color", "var(--color-efficiency)").attr("stop-opacity", 0.8);
                memoryGrad.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-purple-dark)").attr("stop-opacity", 0.6);
                
                // Cost gradient (orange spectrum)
                const costGrad = defs.append("linearGradient")
                    .attr("id", "cost-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");
                costGrad.append("stop").attr("offset", "0%").attr("stop-color", "var(--color-compute)").attr("stop-opacity", 0.8);
                costGrad.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-orange-dark)").attr("stop-opacity", 0.6);

                // Comprehensive LLM architecture data with performance metrics
                const architectures = [
                    {
                        name: "GPT-4",
                        type: "Decoder-Only",
                        parameters: "1.76T",
                        accuracy: 95,
                        speed: 60,
                        memory: 85,
                        cost: 90,
                        context: "128k",
                        strengths: ["Generation", "Reasoning", "Code"],
                        weaknesses: ["Cost", "Speed"],
                        x: width * 0.2, // Improved spacing to eliminate overlap
                        y: height * 0.2, // Improved spacing to eliminate overlap
                        color: "var(--color-alignment)",
                        gradient: "url(#performance-grad)"
                    },
                    {
                        name: "BERT",
                        type: "Encoder-Only",
                        parameters: "340M",
                        accuracy: 88,
                        speed: 95,
                        memory: 40,
                        cost: 20,
                        context: "512",
                        strengths: ["Understanding", "Speed", "Efficiency"],
                        weaknesses: ["Generation", "Context"],
                        x: width * 0.8, // Improved spacing to eliminate overlap
                        y: height * 0.8, // Improved spacing to eliminate overlap
                        color: "var(--color-performance)",
                        gradient: "url(#speed-grad)"
                    },
                    {
                        name: "T5",
                        type: "Encoder-Decoder",
                        parameters: "11B",
                        accuracy: 92,
                        speed: 75,
                        memory: 60,
                        cost: 50,
                        context: "512",
                        strengths: ["Both Tasks", "Versatility"],
                        weaknesses: ["Memory", "Context"],
                        x: width * 0.5,
                        y: height * 0.5,
                        color: "var(--color-efficiency)",
                        gradient: "url(#memory-grad)"
                    },
                    {
                        name: "LLaMA 2",
                        type: "Decoder-Only",
                        parameters: "70B",
                        accuracy: 90,
                        speed: 80,
                        memory: 70,
                        cost: 30,
                        context: "4k",
                        strengths: ["Open Source", "Performance"],
                        weaknesses: ["Context", "Licensing"],
                        x: width * 0.15, // Improved spacing to eliminate overlap with GPT-4
                        y: height * 0.6, // Improved spacing to eliminate overlap
                        color: "var(--color-compute)",
                        gradient: "url(#cost-grad)"
                    },
                    {
                        name: "Mixtral 8x7B",
                        type: "Mixture of Experts",
                        parameters: "56B",
                        accuracy: 88,
                        speed: 85,
                        memory: 50,
                        cost: 25,
                        context: "32k",
                        strengths: ["Efficiency", "Speed", "Cost"],
                        weaknesses: ["Complexity", "Memory"],
                        x: width * 0.7, // Improved spacing to eliminate overlap with BERT
                        y: height * 0.4, // Improved spacing to eliminate overlap
                        color: "var(--color-data)",
                        gradient: "url(#speed-grad)"
                    }
                ];

                // Create performance matrix background
                const matrixGroup = svg.append("g").attr("class", "performance-matrix");
                
                // Add grid lines for performance matrix
                const gridSize = 20;
                for (let i = 0; i <= width; i += gridSize) {
                    matrixGroup.append("line")
                        .attr("x1", i).attr("y1", 0)
                        .attr("x2", i).attr("y2", height)
                        .attr("stroke", "rgba(255,255,255,0.05)")
                        .attr("stroke-width", 1);
                }
                for (let i = 0; i <= height; i += gridSize) {
                    matrixGroup.append("line")
                        .attr("x1", 0).attr("y1", i)
                        .attr("x2", width).attr("y2", i)
                        .attr("stroke", "rgba(255,255,255,0.05)")
                        .attr("stroke-width", 1);
                }

                // Create architecture nodes with performance indicators
                const nodeGroup = svg.append("g").attr("class", "architecture-nodes");
                
                architectures.forEach((arch, i) => {
                    const node = nodeGroup.append("g")
                        .attr("class", "architecture-node")
                        .attr("transform", `translate(${arch.x}, ${arch.y})`);

                    // Main architecture circle with gradient and consistent size encoding based on performance
                    const baseRadius = 30;
                    const performanceSize = getSizeByPerformance(arch.accuracy); // Use consistent size encoding
                    const sizeMultiplier = performanceSize / 12; // Normalize to base size of 12
                    const circleRadius = baseRadius * sizeMultiplier;
                    
                    const mainCircle = node.append("circle")
                        .attr("r", circleRadius)
                        .attr("fill", arch.gradient)
                        .attr("stroke", arch.color)
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.9);

                    // Performance rings with dynamic sizing and consistent scaling
                    const ringRadius1 = circleRadius + 12; // Increased spacing for better visual hierarchy
                    const ringRadius2 = circleRadius + 18; // Increased spacing for better visual hierarchy
                    
                    const performanceRing = node.append("circle")
                        .attr("r", ringRadius1)
                        .attr("fill", "none")
                        .attr("stroke", "#2EC4B6")
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.6)
                        .attr("stroke-dasharray", `${2 * Math.PI * ringRadius1 * (arch.accuracy / 100)} ${2 * Math.PI * ringRadius1}`)
                        .attr("stroke-dashoffset", -Math.PI * ringRadius1);

                    const speedRing = node.append("circle")
                        .attr("r", ringRadius2)
                        .attr("fill", "none")
                        .attr("stroke", "#3A86FF")
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.6)
                        .attr("stroke-dasharray", `${2 * Math.PI * ringRadius2 * (arch.speed / 100)} ${2 * Math.PI * ringRadius2}`)
                        .attr("stroke-dashoffset", -Math.PI * ringRadius2);

                    const memoryRing = node.append("circle")
                        .attr("r", ringRadius2 + 5)
                        .attr("fill", "none")
                        .attr("stroke", "#8338EC")
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.6)
                        .attr("stroke-dasharray", `${2 * Math.PI * (ringRadius2 + 5) * (arch.memory / 100)} ${2 * Math.PI * (ringRadius2 + 5)}`)
                        .attr("stroke-dashoffset", -Math.PI * (ringRadius2 + 5));

                    // Architecture name
                    node.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", "-5")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "12")
                        .attr("font-weight", "bold")
                        .text(arch.name);

                    // Parameter count
                    node.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", "8")
                        .attr("fill", "#B0B3B8")
                        .attr("font-size", "10")
                        .text(arch.parameters);

                    // Architecture type
                    node.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", "20")
                        .attr("fill", "#B0B3B8")
                        .attr("font-size", "9")
                        .text(arch.type);

                    // Performance metrics labels
                    const metricsGroup = node.append("g").attr("class", "performance-metrics");
                    
                    // Accuracy indicator
                    metricsGroup.append("circle")
                        .attr("cx", -25)
                        .attr("cy", -25)
                        .attr("r", 8)
                        .attr("fill", "#2EC4B6")
                        .attr("opacity", 0.8);
                    metricsGroup.append("text")
                        .attr("x", -25)
                        .attr("y", -20)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "8")
                        .attr("font-weight", "bold")
                        .text(arch.accuracy);

                    // Speed indicator
                    metricsGroup.append("circle")
                        .attr("cx", 25)
                        .attr("cy", -25)
                        .attr("r", 8)
                        .attr("fill", "#3A86FF")
                        .attr("opacity", 0.8);
                    metricsGroup.append("text")
                        .attr("x", 25)
                        .attr("y", -20)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "8")
                        .attr("font-weight", "bold")
                        .text(arch.speed);

                    // Memory indicator
                    metricsGroup.append("circle")
                        .attr("cx", -25)
                        .attr("cy", 25)
                        .attr("r", 8)
                        .attr("fill", "#8338EC")
                        .attr("opacity", 0.8);
                    metricsGroup.append("text")
                        .attr("x", -25)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "8")
                        .attr("font-weight", "bold")
                        .text(arch.memory);

                    // Cost indicator
                    metricsGroup.append("circle")
                        .attr("cx", 25)
                        .attr("cy", 25)
                        .attr("r", 8)
                        .attr("fill", "#FFB700")
                        .attr("opacity", 0.8);
                    metricsGroup.append("text")
                        .attr("x", 25)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "8")
                        .attr("font-weight", "bold")
                        .text(arch.cost);

                    // Interactive tooltip
                    const tooltip = d3.select("body").append("div")
                        .attr("class", "tooltip")
                        .style("opacity", 0)
                        .style("position", "absolute")
                        .style("background", "rgba(0,0,0,0.9)")
                        .style("color", "#E0E1DD")
                        .style("padding", "12px")
                        .style("border-radius", "8px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000");

                    node.on("mouseover", function(event) {
                        tooltip.transition().duration(200).style("opacity", 1);
                        tooltip.html(`
                            <div style="font-weight: bold; color: ${arch.color}; margin-bottom: 8px;">${arch.name}</div>
                            <div style="margin-bottom: 4px;"><strong>Type:</strong> ${arch.type}</div>
                            <div style="margin-bottom: 4px;"><strong>Parameters:</strong> ${arch.parameters}</div>
                            <div style="margin-bottom: 4px;"><strong>Context:</strong> ${arch.context}</div>
                            <div style="margin-bottom: 8px;"><strong>Performance:</strong></div>
                            <div style="margin-bottom: 2px;">• Accuracy: ${arch.accuracy}%</div>
                            <div style="margin-bottom: 2px;">• Speed: ${arch.speed}%</div>
                            <div style="margin-bottom: 2px;">• Memory: ${arch.memory}%</div>
                            <div style="margin-bottom: 8px;">• Cost: ${arch.cost}%</div>
                            <div style="margin-bottom: 4px;"><strong>Strengths:</strong> ${arch.strengths.join(", ")}</div>
                            <div><strong>Weaknesses:</strong> ${arch.weaknesses.join(", ")}</div>
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition().duration(200).style("opacity", 0);
                    });

                    // Add entrance animation
                    mainCircle.attr("r", 0)
                        .transition()
                        .duration(800)
                        .delay(i * 200)
                        .attr("r", 35)
                        .ease(d3.easeBackOut);

                    performanceRing.attr("r", 0)
                        .transition()
                        .duration(1000)
                        .delay(i * 200 + 400)
                        .attr("r", 45)
                        .ease(d3.easeBackOut);

                    speedRing.attr("r", 0)
                        .transition()
                        .duration(1200)
                        .delay(i * 200 + 600)
                        .attr("r", 50)
                        .ease(d3.easeBackOut);

                    memoryRing.attr("r", 0)
                        .transition()
                        .duration(1400)
                        .delay(i * 200 + 800)
                        .attr("r", 55)
                        .ease(d3.easeBackOut);
                });

                // Add performance axis labels
                const axisGroup = svg.append("g").attr("class", "performance-axes");
                
                // X-axis label (Performance vs Cost)
                axisGroup.append("text")
                    .attr("x", width / 2)
                    .attr("y", height + 50)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#B0B3B8")
                    .attr("font-size", "14")
                    .attr("font-weight", "bold")
                    .text("Performance vs Cost Trade-off");

                // Y-axis label (Speed vs Memory)
                axisGroup.append("text")
                    .attr("x", -50)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#B0B3B8")
                    .attr("font-size", "14")
                    .attr("font-weight", "bold")
                    .attr("transform", "rotate(-90, -50, " + (height / 2) + ")")
                    .text("Speed vs Memory Trade-off");

                // Add legend
                const legendGroup = svg.append("g").attr("class", "performance-legend");
                const legendData = [
                    { color: "#2EC4B6", label: "Accuracy", metric: "Performance" },
                    { color: "#3A86FF", label: "Speed", metric: "Inference" },
                    { color: "#8338EC", label: "Memory", metric: "Usage" },
                    { color: "#FFB700", label: "Cost", metric: "Efficiency" }
                ];

                legendData.forEach((item, i) => {
                    const legendItem = legendGroup.append("g")
                        .attr("transform", `translate(${width - 120}, ${20 + i * 25})`);

                    legendItem.append("circle")
                        .attr("r", 8)
                        .attr("fill", item.color)
                        .attr("opacity", 0.8);

                    legendItem.append("text")
                        .attr("x", 20)
                        .attr("y", 5)
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "11")
                        .text(item.label);

                    legendItem.append("text")
                        .attr("x", 20)
                        .attr("y", 18)
                        .attr("fill", "#B0B3B8")
                        .attr("font-size", "9")
                        .text(item.metric);
                });

                // Add performance comparison title
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", -20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#E0E1DD")
                    .attr("font-size", "16")
                    .attr("font-weight", "bold")
                    .text("LLM Architecture Performance Matrix");

                // Add subtitle
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", -5)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#B0B3B8")
                    .attr("font-size", "12")
                    .text("Multi-dimensional performance analysis for enterprise decision-making");
            }

            /** Renders the LLM Architecture Decision Tree visualization with interactive decision points. */
            function renderLLMDecisionTreeViz() {
                const container = d3.select("#llm-decision-tree-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;
                
                const margin = { top: 60, right: 40, bottom: 40, left: 40 };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                
                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced gradient definitions for decision tree
                const defs = svg.append("defs");
                
                // Decision node gradient
                const decisionGrad = defs.append("linearGradient")
                    .attr("id", "decision-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");
                decisionGrad.append("stop").attr("offset", "0%").attr("stop-color", "#3A86FF").attr("stop-opacity", 0.9);
                decisionGrad.append("stop").attr("offset", "100%").attr("stop-color", "#1A5CFF").attr("stop-opacity", 0.7);
                
                // Option gradient
                const optionGrad = defs.append("linearGradient")
                    .attr("id", "option-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");
                optionGrad.append("stop").attr("offset", "0%").attr("stop-color", "#2EC4B6").attr("stop-opacity", 0.9);
                optionGrad.append("stop").attr("offset", "100%").attr("stop-color", "#1DA9A0").attr("stop-opacity", 0.7);
                
                // Recommendation gradient
                const recommendationGrad = defs.append("linearGradient")
                    .attr("id", "recommendation-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");
                recommendationGrad.append("stop").attr("offset", "0%").attr("stop-color", "#8338EC").attr("stop-opacity", 0.9);
                recommendationGrad.append("stop").attr("offset", "100%").attr("stop-color", "#6D2BCA").attr("stop-opacity", 0.7);

                // Decision tree data structure
                const decisionTree = {
                    id: "root",
                    question: "What is your primary use case?",
                    type: "decision",
                    x: width / 2,
                    y: 50,
                    options: [
                        {
                            id: "generation",
                            label: "Text Generation",
                            description: "Creating new text content",
                            next: {
                                id: "gen_performance",
                                question: "What are your performance requirements?",
                                type: "decision",
                                options: [
                                    {
                                        id: "gen_high_perf",
                                        label: "High Performance",
                                        description: "Maximum accuracy and quality",
                                        next: {
                                            id: "gen_high_cost",
                                            question: "What is your budget constraint?",
                                            type: "decision",
                                            options: [
                                                {
                                                    id: "gen_high_cost_high",
                                                    label: "High Budget",
                                                    description: "Cost is not a primary concern",
                                                    recommendation: {
                                                        architecture: "GPT-4",
                                                        type: "Decoder-Only",
                                                        parameters: "1.76T",
                                                        reasoning: "Best-in-class generation quality with state-of-the-art reasoning capabilities",
                                                        strengths: ["Superior quality", "Advanced reasoning", "Code generation"],
                                                        weaknesses: ["High cost", "Slower inference"]
                                                    }
                                                },
                                                {
                                                    id: "gen_high_cost_medium",
                                                    label: "Medium Budget",
                                                    description: "Balanced cost and performance",
                                                    recommendation: {
                                                        architecture: "Claude-3.5 Sonnet",
                                                        type: "Decoder-Only",
                                                        parameters: "200B",
                                                        reasoning: "Excellent generation quality with better cost efficiency than GPT-4",
                                                        strengths: ["High quality", "Better cost", "Long context"],
                                                        weaknesses: ["Slower than smaller models"]
                                                    }
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        id: "gen_balanced",
                                        label: "Balanced Performance",
                                        description: "Good quality with reasonable speed",
                                        next: {
                                            id: "gen_balanced_deployment",
                                            question: "How do you want to deploy?",
                                            type: "decision",
                                            options: [
                                                {
                                                    id: "gen_balanced_api",
                                                    label: "API Service",
                                                    description: "Use commercial API",
                                                    recommendation: {
                                                        architecture: "GPT-3.5 Turbo",
                                                        type: "Decoder-Only",
                                                        parameters: "175B",
                                                        reasoning: "Fast, cost-effective generation with good quality",
                                                        strengths: ["Fast inference", "Cost effective", "Easy integration"],
                                                        weaknesses: ["Limited customization"]
                                                    }
                                                },
                                                {
                                                    id: "gen_balanced_self",
                                                    label: "Self-hosted",
                                                    description: "Deploy your own model",
                                                    recommendation: {
                                                        architecture: "LLaMA 2 70B",
                                                        type: "Decoder-Only",
                                                        parameters: "70B",
                                                        reasoning: "Open-source alternative with good generation quality",
                                                        strengths: ["Open source", "Customizable", "No API costs"],
                                                        weaknesses: ["Infrastructure requirements", "Licensing considerations"]
                                                    }
                                                }
                                            ]
                                        }
                                    },
                                    {
                                        id: "gen_speed",
                                        label: "High Speed",
                                        description: "Fast inference is critical",
                                        recommendation: {
                                            architecture: "Mixtral 8x7B",
                                            type: "Mixture of Experts",
                                            parameters: "56B",
                                            reasoning: "Mixture-of-experts design provides fast inference with good quality",
                                            strengths: ["Very fast", "Efficient", "Good quality"],
                                            weaknesses: ["Complex architecture", "Memory requirements"]
                                        }
                                    }
                                ]
                            }
                        },
                        {
                            id: "understanding",
                            label: "Text Understanding",
                            description: "Analyzing and classifying text",
                            next: {
                                id: "und_performance",
                                question: "What is your accuracy requirement?",
                                type: "decision",
                                options: [
                                    {
                                        id: "und_high_acc",
                                        label: "High Accuracy",
                                        description: "Maximum classification accuracy",
                                        recommendation: {
                                            architecture: "RoBERTa Large",
                                            type: "Encoder-Only",
                                            parameters: "355M",
                                            reasoning: "State-of-the-art performance on understanding tasks",
                                            strengths: ["Highest accuracy", "Proven performance", "Extensive benchmarks"],
                                            weaknesses: ["Larger model", "Slower inference"]
                                        }
                                    },
                                    {
                                        id: "und_balanced",
                                        label: "Balanced Accuracy",
                                        description: "Good accuracy with reasonable speed",
                                        recommendation: {
                                            architecture: "BERT Base",
                                            type: "Encoder-Only",
                                            parameters: "110M",
                                            reasoning: "Excellent balance of accuracy and efficiency for understanding tasks",
                                            strengths: ["Good accuracy", "Fast inference", "Wide adoption"],
                                            weaknesses: ["Lower accuracy than large models"]
                                        }
                                    },
                                    {
                                        id: "und_speed",
                                        label: "High Speed",
                                        description: "Fast inference is critical",
                                        recommendation: {
                                            architecture: "DistilBERT",
                                            type: "Encoder-Only",
                                            parameters: "66M",
                                            reasoning: "Distilled version of BERT with 60% fewer parameters",
                                            strengths: ["Very fast", "Small size", "Good accuracy"],
                                            weaknesses: ["Lower accuracy than full BERT"]
                                        }
                                    }
                                ]
                            }
                        },
                        {
                            id: "both",
                            label: "Both Tasks",
                            description: "Generation and understanding",
                            next: {
                                id: "both_complexity",
                                question: "What is your task complexity?",
                                type: "decision",
                                options: [
                                    {
                                        id: "both_complex",
                                        label: "Complex Tasks",
                                        description: "Sophisticated reasoning required",
                                        recommendation: {
                                            architecture: "T5-11B",
                                            type: "Encoder-Decoder",
                                            parameters: "11B",
                                            reasoning: "Large T5 model excels at complex text-to-text tasks",
                                            strengths: ["Handles both tasks", "High quality", "Versatile"],
                                            weaknesses: ["Large model", "High resource requirements"]
                                        }
                                    },
                                    {
                                        id: "both_simple",
                                        label: "Simple Tasks",
                                        description: "Straightforward text processing",
                                        recommendation: {
                                            architecture: "T5-Base",
                                            type: "Encoder-Decoder",
                                            parameters: "220M",
                                            reasoning: "Efficient T5 model for simpler text-to-text tasks",
                                            strengths: ["Balanced performance", "Reasonable size", "Good efficiency"],
                                            weaknesses: ["Limited for complex tasks"]
                                        }
                                    }
                                ]
                            }
                        }
                    ]
                };

                // State management
                let currentPath = [];
                let currentNode = decisionTree;

                // Create decision tree visualization
                function renderDecisionTree() {
                    svg.selectAll("*").remove();
                    
                    // Add title
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", -20)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "16")
                        .attr("font-weight", "bold")
                        .text("LLM Architecture Decision Tree");

                    // Add subtitle
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", -5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#B0B3B8")
                        .attr("font-size", "12")
                        .text("Click through the decision points to find your optimal architecture");

                    // Render current node
                    renderNode(currentNode, 0);
                }

                function renderNode(node, level) {
                    const nodeGroup = svg.append("g").attr("class", `node-level-${level}`);
                    
                    // Calculate position
                    const nodeWidth = 200;
                    const nodeHeight = 80;
                    const spacing = 250;
                    
                    // Render decision node
                    const decisionRect = nodeGroup.append("rect")
                        .attr("x", node.x - nodeWidth / 2)
                        .attr("y", node.y - nodeHeight / 2)
                        .attr("width", nodeWidth)
                        .attr("height", nodeHeight)
                        .attr("rx", 10)
                        .attr("fill", "url(#decision-grad)")
                        .attr("stroke", "#3A86FF")
                        .attr("stroke-width", 2)
                        .attr("opacity", 0.9);

                    // Add question text
                    nodeGroup.append("text")
                        .attr("x", node.x)
                        .attr("y", node.y - 10)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "12")
                        .attr("font-weight", "bold")
                        .text(node.question);

                    // Add back button if not root
                    if (level > 0) {
                        const backButton = nodeGroup.append("g")
                            .attr("class", "back-button")
                            .attr("transform", `translate(${node.x - nodeWidth / 2 - 30}, ${node.y})`)
                            .style("cursor", "pointer");

                        backButton.append("circle")
                            .attr("r", 15)
                            .attr("fill", "#FFB700")
                            .attr("opacity", 0.8);

                        backButton.append("text")
                            .attr("text-anchor", "middle")
                            .attr("dy", "0.35em")
                            .attr("fill", "#E0E1DD")
                            .attr("font-size", "12")
                            .attr("font-weight", "bold")
                            .text("←");

                        backButton.on("click", function() {
                            currentPath.pop();
                            currentNode = currentPath.length > 0 ? currentPath[currentPath.length - 1] : decisionTree;
                            renderDecisionTree();
                        });
                    }

                    // Render options
                    if (node.options) {
                        const optionSpacing = Math.min(300, (height - node.y - 100) / node.options.length);
                        
                        node.options.forEach((option, i) => {
                            const optionY = node.y + 100 + (i * optionSpacing);
                            const optionGroup = svg.append("g").attr("class", `option-${option.id}`);
                            
                            // Draw connection line with enhanced styling
                            svg.append("line")
                                .attr("x1", node.x)
                                .attr("y1", node.y + nodeHeight / 2)
                                .attr("x2", node.x)
                                .attr("y2", optionY - 30)
                                .attr("stroke", "#2EC4B6")
                                .attr("stroke-width", 3) // Increased line weight for better visibility
                                .attr("opacity", 0.8)
                                .attr("stroke-dasharray", "5,5") // Dashed line for better visual hierarchy
                                .style("filter", "drop-shadow(0 0 3px rgba(46, 196, 182, 0.3))"); // Subtle glow effect

                            // Option rectangle with enhanced styling and consistent sizing
                            const buttonWidth = 320; // Consistent button width for better visual hierarchy
                            const buttonHeight = 70; // Consistent button height for better visual hierarchy
                            const buttonRadius = 12; // Consistent border radius for better visual consistency
                            
                            const optionRect = optionGroup.append("rect")
                                .attr("x", node.x - buttonWidth / 2) // Centered positioning
                                .attr("y", optionY - buttonHeight / 2) // Centered positioning
                                .attr("width", buttonWidth)
                                .attr("height", buttonHeight)
                                .attr("rx", buttonRadius)
                                .attr("ry", buttonRadius) // Consistent border radius
                                .attr("fill", "url(#option-grad)")
                                .attr("stroke", "#2EC4B6")
                                .attr("stroke-width", 3) // Increased border width for better visibility
                                .attr("opacity", 0.9)
                                .style("cursor", "pointer")
                                .style("transition", "all 0.2s ease") // Smooth transitions
                                .style("filter", "drop-shadow(0 2px 8px rgba(46, 196, 182, 0.2))"); // Subtle shadow for depth

                            // Option label with enhanced typography
                            optionGroup.append("text")
                                .attr("x", node.x)
                                .attr("y", optionY - 8) // Adjusted for new button height
                                .attr("text-anchor", "middle")
                                .attr("fill", "white")
                                .attr("font-size", "16") // Increased font size for better readability
                                .attr("font-weight", "700") // Increased font weight for better hierarchy
                                .attr("font-family", "Inter, system-ui, sans-serif")
                                .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)") // Text shadow for better contrast
                                .text(option.label);

                            // Option description with enhanced styling
                            optionGroup.append("text")
                                .attr("x", node.x)
                                .attr("y", optionY + 12) // Adjusted for new button height
                                .attr("text-anchor", "middle")
                                .attr("fill", "rgba(255,255,255,0.9)") // Increased opacity for better readability
                                .attr("font-size", "12") // Increased font size
                                .attr("font-weight", "500") // Increased font weight
                                .attr("font-family", "Inter, system-ui, sans-serif")
                                .style("text-shadow", "0 1px 2px rgba(0,0,0,0.2)") // Subtle text shadow
                                .text(option.description);

                            // Click handler
                            optionGroup.on("click", function() {
                                if (option.recommendation) {
                                    showRecommendation(option.recommendation);
                                } else if (option.next) {
                                    currentPath.push(currentNode);
                                    currentNode = option.next;
                                    renderDecisionTree();
                                }
                            });

                            // Enhanced hover effects with better visual feedback
                            optionGroup.on("mouseover", function() {
                                optionRect.transition().duration(200)
                                    .attr("opacity", 1)
                                    .attr("stroke-width", 4) // Increased stroke width on hover
                                    .style("filter", "drop-shadow(0 4px 12px rgba(46, 196, 182, 0.4))") // Enhanced shadow on hover
                                    .style("transform", "scale(1.02)"); // Subtle scale effect
                                
                                // Highlight connection line on hover
                                svg.selectAll("line").filter(function() {
                                    return d3.select(this).attr("x1") == node.x && 
                                           d3.select(this).attr("y1") == node.y + nodeHeight / 2;
                                }).transition().duration(200)
                                    .attr("stroke-width", 4)
                                    .attr("opacity", 1)
                                    .style("filter", "drop-shadow(0 0 6px rgba(46, 196, 182, 0.5))");
                            })
                            .on("mouseout", function() {
                                optionRect.transition().duration(200)
                                    .attr("opacity", 0.9)
                                    .attr("stroke-width", 3)
                                    .style("filter", "drop-shadow(0 2px 8px rgba(46, 196, 182, 0.2))")
                                    .style("transform", "scale(1)");
                                
                                // Reset connection line
                                svg.selectAll("line").filter(function() {
                                    return d3.select(this).attr("x1") == node.x && 
                                           d3.select(this).attr("y1") == node.y + nodeHeight / 2;
                                }).transition().duration(200)
                                    .attr("stroke-width", 3)
                                    .attr("opacity", 0.8)
                                    .style("filter", "drop-shadow(0 0 3px rgba(46, 196, 182, 0.3))");
                            });
                        });
                    }
                }

                function showRecommendation(recommendation) {
                    svg.selectAll("*").remove();
                    
                    // Add title
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "18")
                        .attr("font-weight", "bold")
                        .text("Recommended Architecture");

                    // Recommendation card
                    const cardGroup = svg.append("g")
                        .attr("transform", `translate(${width / 2 - 200}, 60)`);

                    const cardRect = cardGroup.append("rect")
                        .attr("width", 400)
                        .attr("height", 400)
                        .attr("rx", 15)
                        .attr("fill", "url(#recommendation-grad)")
                        .attr("stroke", "#8338EC")
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.9);

                    // Architecture name
                    cardGroup.append("text")
                        .attr("x", 200)
                        .attr("y", 50)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "20")
                        .attr("font-weight", "bold")
                        .text(recommendation.architecture);

                    // Architecture details
                    const details = [
                        `Type: ${recommendation.type}`,
                        `Parameters: ${recommendation.parameters}`,
                        "",
                        "Reasoning:",
                        recommendation.reasoning,
                        "",
                        "Strengths:",
                        ...recommendation.strengths.map(s => `• ${s}`),
                        "",
                        "Weaknesses:",
                        ...recommendation.weaknesses.map(w => `• ${w}`)
                    ];

                    details.forEach((detail, i) => {
                        const y = 80 + (i * 15);
                        cardGroup.append("text")
                            .attr("x", 20)
                            .attr("y", y)
                            .attr("fill", i === 0 || i === 3 || i === 6 || i === 9 ? "#E0E1DD" : "#B0B3B8")
                            .attr("font-size", i === 0 || i === 3 || i === 6 || i === 9 ? "12" : "10")
                            .attr("font-weight", i === 0 || i === 3 || i === 6 || i === 9 ? "bold" : "normal")
                            .text(detail);
                    });

                    // Back button
                    const backButton = svg.append("g")
                        .attr("class", "back-button")
                        .attr("transform", `translate(50, 50)`)
                        .style("cursor", "pointer");

                    backButton.append("circle")
                        .attr("r", 20)
                        .attr("fill", "#FFB700")
                        .attr("opacity", 0.8);

                    backButton.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", "0.35em")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "14")
                        .attr("font-weight", "bold")
                        .text("← Back");

                    backButton.on("click", function() {
                        currentPath = [];
                        currentNode = decisionTree;
                        renderDecisionTree();
                    });

                    // Restart button
                    const restartButton = svg.append("g")
                        .attr("class", "restart-button")
                        .attr("transform", `translate(${width - 100}, 50)`)
                        .style("cursor", "pointer");

                    restartButton.append("circle")
                        .attr("r", 20)
                        .attr("fill", "#2EC4B6")
                        .attr("opacity", 0.8);

                    restartButton.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", "0.35em")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "10")
                        .attr("font-weight", "bold")
                        .text("Restart");

                    restartButton.on("click", function() {
                        currentPath = [];
                        currentNode = decisionTree;
                        renderDecisionTree();
                    });
                }

                // Initialize
                renderDecisionTree();
            }

            /** Renders the LLM Architecture Timeline visualization with interactive milestones. */
            function renderLLMTimelineViz() {
                const container = d3.select("#llm-timeline-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;
                
                const margin = { top: 80, right: 40, bottom: 80, left: 40 };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                
                const svg = container.append("svg")
                    .attr("width", bounds.width)
                    .attr("height", bounds.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced gradient definitions for timeline
                const defs = svg.append("defs");
                
                // Standardized pattern definitions for texture encoding
                const patterns = [
                    { id: "dots-pattern", type: "dots", size: 4, spacing: 8 },
                    { id: "lines-pattern", type: "lines", width: 2, spacing: 6 },
                    { id: "grid-pattern", type: "grid", size: 6, spacing: 12 },
                    { id: "diagonal-pattern", type: "diagonal", width: 2, spacing: 8 },
                    { id: "circles-pattern", type: "circles", radius: 3, spacing: 10 },
                    { id: "waves-pattern", type: "waves", amplitude: 2, frequency: 4 }
                ];
                
                patterns.forEach(pattern => {
                    const patternDef = defs.append("pattern")
                        .attr("id", pattern.id)
                        .attr("width", pattern.spacing)
                        .attr("height", pattern.spacing)
                        .attr("patternUnits", "userSpaceOnUse");
                    
                    if (pattern.type === "dots") {
                        patternDef.append("circle")
                            .attr("cx", pattern.spacing / 2)
                            .attr("cy", pattern.spacing / 2)
                            .attr("r", pattern.size / 2)
                            .attr("fill", "rgba(255,255,255,0.3)");
                    } else if (pattern.type === "lines") {
                        patternDef.append("line")
                            .attr("x1", 0)
                            .attr("y1", pattern.spacing / 2)
                            .attr("x2", pattern.spacing)
                            .attr("y2", pattern.spacing / 2)
                            .attr("stroke", "rgba(255,255,255,0.3)")
                            .attr("stroke-width", pattern.width);
                    } else if (pattern.type === "grid") {
                        patternDef.append("rect")
                            .attr("width", pattern.spacing)
                            .attr("height", pattern.spacing)
                            .attr("fill", "none")
                            .attr("stroke", "rgba(255,255,255,0.2)")
                            .attr("stroke-width", 1);
                    } else if (pattern.type === "diagonal") {
                        patternDef.append("line")
                            .attr("x1", 0)
                            .attr("y1", 0)
                            .attr("x2", pattern.spacing)
                            .attr("y2", pattern.spacing)
                            .attr("stroke", "rgba(255,255,255,0.3)")
                            .attr("stroke-width", pattern.width);
                    } else if (pattern.type === "circles") {
                        patternDef.append("circle")
                            .attr("cx", pattern.spacing / 2)
                            .attr("cy", pattern.spacing / 2)
                            .attr("r", pattern.radius)
                            .attr("fill", "none")
                            .attr("stroke", "rgba(255,255,255,0.3)")
                            .attr("stroke-width", 1);
                    } else if (pattern.type === "waves") {
                        const pathData = `M 0,${pattern.spacing/2} Q ${pattern.spacing/4},${pattern.spacing/2 - pattern.amplitude} ${pattern.spacing/2},${pattern.spacing/2} T ${pattern.spacing},${pattern.spacing/2}`;
                        patternDef.append("path")
                            .attr("d", pathData)
                            .attr("fill", "none")
                            .attr("stroke", "rgba(255,255,255,0.3)")
                            .attr("stroke-width", 1);
                    }
                });
                
                // Timeline gradient
                const timelineGrad = defs.append("linearGradient")
                    .attr("id", "timeline-grad")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "0%");
                timelineGrad.append("stop").attr("offset", "0%").attr("stop-color", "#3A86FF").attr("stop-opacity", 0.8);
                timelineGrad.append("stop").attr("offset", "50%").attr("stop-color", "#2EC4B6").attr("stop-opacity", 0.8);
                timelineGrad.append("stop").attr("offset", "100%").attr("stop-color", "#8338EC").attr("stop-opacity", 0.8);
                
                // Milestone gradient
                const milestoneGrad = defs.append("radialGradient")
                    .attr("id", "milestone-grad")
                    .attr("cx", "50%").attr("cy", "50%").attr("r", "50%");
                milestoneGrad.append("stop").attr("offset", "0%").attr("stop-color", "#FFB700").attr("stop-opacity", 0.9);
                milestoneGrad.append("stop").attr("offset", "100%").attr("stop-color", "#E09800").attr("stop-opacity", 0.7);

                // Enhanced timeline data with improved temporal positioning and consistent spacing
                const timelineData = [
                    {
                        year: 2018,
                        month: 6,
                        name: "GPT-1",
                        type: "Decoder-Only",
                        parameters: "117M",
                        breakthrough: "First transformer-based language model",
                        impact: "Established autoregressive language modeling",
                        color: "#3A86FF",
                        pattern: "url(#dots-pattern)",
                        x: 0,
                        y: height * 0.5,
                        details: "Introduced the GPT architecture using transformer decoder blocks for unsupervised pre-training followed by supervised fine-tuning."
                    },
                    {
                        year: 2018,
                        month: 10,
                        name: "BERT",
                        type: "Encoder-Only",
                        parameters: "340M",
                        breakthrough: "Bidirectional attention mechanism",
                        impact: "Revolutionized understanding tasks",
                        color: "#2EC4B6",
                        pattern: "url(#lines-pattern)",
                        x: width * 0.14,
                        y: height * 0.5,
                        details: "Introduced bidirectional training of transformers, enabling models to see both left and right context simultaneously."
                    },
                    {
                        year: 2019,
                        month: 2,
                        name: "GPT-2",
                        type: "Decoder-Only",
                        parameters: "1.5B",
                        breakthrough: "Scaling transformer models",
                        impact: "Demonstrated emergent capabilities",
                        color: "#3A86FF",
                        x: width * 0.24,
                        y: height * 0.5,
                        details: "Scaled up GPT architecture to 1.5B parameters, showing that larger models develop unexpected capabilities."
                    },
                    {
                        year: 2019,
                        month: 10,
                        name: "T5",
                        type: "Encoder-Decoder",
                        parameters: "11B",
                        breakthrough: "Text-to-text transfer paradigm",
                        impact: "Unified framework for all NLP tasks",
                        color: "#8338EC",
                        pattern: "url(#grid-pattern)",
                        x: width * 0.34,
                        y: height * 0.5,
                        details: "Introduced the text-to-text transfer transformer, treating all NLP tasks as text generation problems."
                    },
                    {
                        year: 2020,
                        month: 5,
                        name: "GPT-3",
                        type: "Decoder-Only",
                        parameters: "175B",
                        breakthrough: "Massive scale and few-shot learning",
                        impact: "Demonstrated emergent reasoning abilities",
                        color: "#3A86FF",
                        x: width * 0.44,
                        y: height * 0.5,
                        details: "Scaled to 175B parameters, demonstrating few-shot and zero-shot learning capabilities without fine-tuning."
                    },
                    {
                        year: 2021,
                        month: 1,
                        name: "T5-11B",
                        type: "Encoder-Decoder",
                        parameters: "11B",
                        breakthrough: "Efficient text-to-text processing",
                        impact: "Balanced performance and efficiency",
                        color: "#8338EC",
                        x: width * 0.54,
                        y: height * 0.5,
                        details: "Optimized T5 architecture with improved training efficiency and better performance on text-to-text tasks."
                    },
                    {
                        year: 2022,
                        month: 3,
                        name: "PaLM",
                        type: "Decoder-Only",
                        parameters: "540B",
                        breakthrough: "Pathways architecture and scaling",
                        impact: "Advanced reasoning and code generation",
                        color: "#00A6FB",
                        x: width * 0.64,
                        y: height * 0.5,
                        details: "Introduced Pathways architecture with 540B parameters, achieving state-of-the-art performance on reasoning tasks."
                    },
                    {
                        year: 2023,
                        month: 2,
                        name: "LLaMA",
                        type: "Decoder-Only",
                        parameters: "65B",
                        breakthrough: "Open-source efficiency",
                        impact: "Democratized large language models",
                        color: "#FFB700",
                        x: width * 0.74,
                        y: height * 0.5,
                        details: "Open-source model that achieved GPT-3 level performance with significantly fewer parameters through better training."
                    },
                    {
                        year: 2023,
                        month: 11,
                        name: "Mixtral 8x7B",
                        type: "Mixture of Experts",
                        parameters: "56B",
                        breakthrough: "Sparse mixture-of-experts",
                        impact: "Efficient inference with high quality",
                        color: "#2EC4B6",
                        x: width * 0.82,
                        y: height / 2,
                        details: "Introduced mixture-of-experts architecture, using only 12.9B active parameters while maintaining high performance."
                    },
                    {
                        year: 2024,
                        month: 6,
                        name: "Qwen2.5",
                        type: "Decoder-Only",
                        parameters: "72B",
                        breakthrough: "Multilingual and multimodal",
                        impact: "Advanced multilingual capabilities",
                        color: "#8338EC",
                        x: width * 0.92,
                        y: height / 2,
                        details: "State-of-the-art multilingual model with strong performance across 27 languages and multimodal capabilities."
                    }
                ];

                // Create timeline axis
                const timelineAxis = svg.append("g").attr("class", "timeline-axis");
                
                // Main timeline line
                timelineAxis.append("line")
                    .attr("x1", 0)
                    .attr("y1", height / 2)
                    .attr("x2", width)
                    .attr("y2", height / 2)
                    .attr("stroke", "url(#timeline-grad)")
                    .attr("stroke-width", 4)
                    .attr("opacity", 0.8);

                // Year markers with improved spacing and temporal progression
                const years = [2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025];
                years.forEach((year, i) => {
                    const x = (i / (years.length - 1)) * width;
                    
                    // Year marker line with increased height for better visibility and temporal flow
                    timelineAxis.append("line")
                        .attr("x1", x)
                        .attr("y1", height / 2 - 30)
                        .attr("x2", x)
                        .attr("y2", height / 2 + 30)
                        .attr("stroke", "#B0B3B8")
                        .attr("stroke-width", 2)
                        .attr("opacity", 0.7)
                        .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))");
                    
                    // Year label with enhanced positioning and temporal progression styling
                    timelineAxis.append("text")
                        .attr("x", x)
                        .attr("y", height / 2 - 50)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "14")
                        .attr("font-weight", "bold")
                        .attr("text-shadow", "0 2px 4px rgba(0,0,0,0.6)")
                        .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.4))")
                        .text(year);
                });

                // Create milestone nodes
                const milestoneGroup = svg.append("g").attr("class", "milestones");
                
                timelineData.forEach((milestone, i) => {
                    // Enhanced milestone positioning with better temporal alignment
                    const milestoneNode = milestoneGroup.append("g")
                        .attr("class", `milestone-${i}`)
                        .attr("transform", `translate(${milestone.x}, ${milestone.y})`);

                    // Milestone circle with enhanced styling and temporal progression
                    const circle = milestoneNode.append("circle")
                        .attr("r", 24)
                        .attr("fill", "url(#milestone-grad)")
                        .attr("stroke", milestone.color)
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.9)
                        .style("cursor", "pointer")
                        .style("filter", "drop-shadow(0 3px 6px rgba(0,0,0,0.4))")
                        .style("transition", "all 0.3s ease");

                    // Milestone name with improved styling and temporal progression
                    milestoneNode.append("text")
                        .attr("text-anchor", "middle")
                        .attr("dy", "0.35em")
                        .attr("fill", "#FFFFFF")
                        .attr("font-size", "12")
                        .attr("font-weight", "bold")
                        .attr("text-shadow", "0 2px 4px rgba(0,0,0,0.8)")
                        .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.5))")
                        .text(milestone.name);

                    // Enhanced connection line to timeline with improved positioning and temporal flow
                    milestoneNode.append("line")
                        .attr("x1", 0)
                        .attr("y1", 24)
                        .attr("x2", 0)
                        .attr("y2", 0)
                        .attr("stroke", milestone.color)
                        .attr("stroke-width", 3)
                        .attr("opacity", 0.8)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                        .style("transition", "all 0.3s ease");

                    // Milestone details panel with enhanced positioning to prevent overlap and improve temporal flow
                    const detailsPanel = milestoneNode.append("g")
                        .attr("class", "details-panel")
                        .attr("transform", `translate(0, ${i % 2 === 0 ? -120 : 120})`)
                        .style("opacity", 0)
                        .style("transition", "opacity 0.3s ease");

                    // Enhanced panel background with temporal progression styling
                    detailsPanel.append("rect")
                        .attr("x", -130)
                        .attr("y", -70)
                        .attr("width", 260)
                        .attr("height", 140)
                        .attr("rx", 12)
                        .attr("fill", "rgba(0,0,0,0.95)")
                        .attr("stroke", milestone.color)
                        .attr("stroke-width", 2)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.5))");

                    // Enhanced panel content with improved temporal progression styling
                    detailsPanel.append("text")
                        .attr("x", 0)
                        .attr("y", -45)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "13")
                        .attr("font-weight", "bold")
                        .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                        .text(milestone.name);

                    detailsPanel.append("text")
                        .attr("x", 0)
                        .attr("y", -28)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#B0B3B8")
                        .attr("font-size", "11")
                        .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                        .text(`${milestone.type} • ${milestone.parameters}`);

                    detailsPanel.append("text")
                        .attr("x", 0)
                        .attr("y", -10)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#FFB700")
                        .attr("font-size", "11")
                        .attr("font-weight", "bold")
                        .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.4)")
                        .text(milestone.breakthrough);

                    detailsPanel.append("text")
                        .attr("x", 0)
                        .attr("y", 8)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#2EC4B6")
                        .attr("font-size", "10")
                        .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                        .text(milestone.impact);

                    detailsPanel.append("text")
                        .attr("x", 0)
                        .attr("y", 25)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#B0B3B8")
                        .attr("font-size", "9")
                        .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.2)")
                        .text(milestone.details);

                    // Interactive tooltip
                    const tooltip = d3.select("body").append("div")
                        .attr("class", "tooltip")
                        .style("opacity", 0)
                        .style("position", "absolute")
                        .style("background", "rgba(0,0,0,0.9)")
                        .style("color", "#E0E1DD")
                        .style("padding", "12px")
                        .style("border-radius", "8px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000");

                    // Hover effects
                    milestoneNode.on("mouseover", function(event) {
                        detailsPanel.transition().duration(200).style("opacity", 1);
                        circle.transition().duration(200).attr("r", 25);
                        
                        tooltip.transition().duration(200).style("opacity", 1);
                        tooltip.html(`
                            <div style="font-weight: bold; color: ${milestone.color}; margin-bottom: 8px;">${milestone.name}</div>
                            <div style="margin-bottom: 4px;"><strong>Year:</strong> ${milestone.year}</div>
                            <div style="margin-bottom: 4px;"><strong>Type:</strong> ${milestone.type}</div>
                            <div style="margin-bottom: 4px;"><strong>Parameters:</strong> ${milestone.parameters}</div>
                            <div style="margin-bottom: 8px;"><strong>Breakthrough:</strong> ${milestone.breakthrough}</div>
                            <div style="margin-bottom: 4px;"><strong>Impact:</strong> ${milestone.impact}</div>
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", function() {
                        detailsPanel.transition().duration(200).style("opacity", 0);
                        circle.transition().duration(200).attr("r", 20);
                        tooltip.transition().duration(200).style("opacity", 0);
                    });

                    // Add entrance animation
                    circle.attr("r", 0)
                        .transition()
                        .duration(800)
                        .delay(i * 100)
                        .attr("r", 20)
                        .ease(d3.easeBackOut);
                });

                // Add timeline title
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", -40)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#E0E1DD")
                    .attr("font-size", "18")
                    .attr("font-weight", "bold")
                    .text("LLM Architecture Evolution Timeline");

                // Add subtitle
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", -20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#B0B3B8")
                    .attr("font-size", "12")
                    .text("Key milestones in Large Language Model development (2018-2025)");

                // Add legend
                const legendGroup = svg.append("g").attr("class", "timeline-legend");
                const legendData = [
                    { color: "#3A86FF", label: "Decoder-Only", description: "Autoregressive generation" },
                    { color: "#2EC4B6", label: "Encoder-Only", description: "Bidirectional understanding" },
                    { color: "#8338EC", label: "Encoder-Decoder", description: "Text-to-text processing" },
                    { color: "#00A6FB", label: "Pathways", description: "Advanced scaling" },
                    { color: "#FFB700", label: "Open Source", description: "Community accessible" }
                ];

                legendData.forEach((item, i) => {
                    const legendItem = legendGroup.append("g")
                        .attr("transform", `translate(${width - 150}, ${20 + i * 30})`);

                    legendItem.append("circle")
                        .attr("r", 8)
                        .attr("fill", item.color)
                        .attr("opacity", 0.8);

                    legendItem.append("text")
                        .attr("x", 20)
                        .attr("y", 5)
                        .attr("fill", "#E0E1DD")
                        .attr("font-size", "11")
                        .text(item.label);

                    legendItem.append("text")
                        .attr("x", 20)
                        .attr("y", 18)
                        .attr("fill", "#B0B3B8")
                        .attr("font-size", "9")
                        .text(item.description);
                });
            }

            /** Calls all rendering functions to initialize and update the visuals. */
        function renderLLMComponentBreakdownViz() {
            const container = d3.select("#llm-component-breakdown-viz");
            container.selectAll("*").remove();
            
            const width = container.node().offsetWidth;
            const height = 600;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            const vizWidth = width - margin.left - margin.right;
            const vizHeight = height - margin.top - margin.bottom;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Define gradients
            const defs = svg.append("defs");
            
            const attentionGradient = defs.append("linearGradient")
                .attr("id", "attention-gradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "100%");
            attentionGradient.append("stop").attr("offset", "0%").attr("stop-color", "#3B82F6");
            attentionGradient.append("stop").attr("offset", "100%").attr("stop-color", "#1E40AF");
            
            const feedforwardGradient = defs.append("linearGradient")
                .attr("id", "feedforward-gradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "100%");
            feedforwardGradient.append("stop").attr("offset", "0%").attr("stop-color", "#10B981");
            feedforwardGradient.append("stop").attr("offset", "100%").attr("stop-color", "#047857");
            
            const positionalGradient = defs.append("linearGradient")
                .attr("id", "positional-gradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "100%");
            positionalGradient.append("stop").attr("offset", "0%").attr("stop-color", "#F59E0B");
            positionalGradient.append("stop").attr("offset", "100%").attr("stop-color", "#D97706");
            
            const normalizationGradient = defs.append("linearGradient")
                .attr("id", "normalization-gradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "100%");
            normalizationGradient.append("stop").attr("offset", "0%").attr("stop-color", "#8B5CF6");
            normalizationGradient.append("stop").attr("offset", "100%").attr("stop-color", "#7C3AED");
            
            // Component data with improved spacing and positioning
            const components = [
                {
                    id: "input-embedding",
                    name: "Input Embedding",
                    type: "embedding",
                    x: 50,
                    y: 100,
                    width: 120,
                    height: 60,
                    description: "Converts input tokens to dense vector representations",
                    details: "Each token is mapped to a high-dimensional vector that captures semantic meaning"
                },
                {
                    id: "positional-encoding",
                    name: "Positional Encoding",
                    type: "positional",
                    x: 200,
                    y: 100,
                    width: 120,
                    height: 60,
                    description: "Adds position information to embeddings",
                    details: "Sinusoidal or learned encodings that provide sequence order information"
                },
                {
                    id: "multi-head-attention",
                    name: "Multi-Head Attention",
                    type: "attention",
                    x: 360,
                    y: 50,
                    width: 150,
                    height: 100,
                    description: "Computes attention weights between all token pairs",
                    details: "Multiple attention heads capture different types of relationships simultaneously"
                },
                {
                    id: "add-norm-1",
                    name: "Add & Norm",
                    type: "normalization",
                    x: 540,
                    y: 80,
                    width: 100,
                    height: 40,
                    description: "Residual connection and layer normalization",
                    details: "Stabilizes training and enables deep networks"
                },
                {
                    id: "feedforward",
                    name: "Feedforward Network",
                    type: "feedforward",
                    x: 360,
                    y: 200,
                    width: 150,
                    height: 80,
                    description: "Point-wise feedforward transformation",
                    details: "Expands to 4x hidden dimension, applies ReLU, then projects back"
                },
                {
                    id: "add-norm-2",
                    name: "Add & Norm",
                    type: "normalization",
                    x: 540,
                    y: 220,
                    width: 100,
                    height: 40,
                    description: "Second residual connection and normalization",
                    details: "Final normalization before output"
                },
                {
                    id: "output-projection",
                    name: "Output Projection",
                    type: "embedding",
                    x: 660,
                    y: 150,
                    width: 120,
                    height: 60,
                    description: "Projects to vocabulary size for next token prediction",
                    details: "Final linear layer that outputs probability distribution over vocabulary"
                }
            ];
            
            // Create component rectangles
            const componentRects = g.selectAll(".component")
                .data(components)
                .enter().append("g")
                .attr("class", "component")
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            componentRects.append("rect")
                .attr("width", d => d.width)
                .attr("height", d => d.height)
                .attr("rx", 8)
                .attr("fill", d => {
                    switch(d.type) {
                        case "attention": return "url(#attention-gradient)";
                        case "feedforward": return "url(#feedforward-gradient)";
                        case "positional": return "url(#positional-gradient)";
                        case "normalization": return "url(#normalization-gradient)";
                        default: return "#6B7280";
                    }
                })
                .attr("stroke", "#374151")
                .attr("stroke-width", 2)
                .style("opacity", 0.9)
                .on("mouseover", function(event, d) {
                    d3.select(this).style("opacity", 1).attr("stroke-width", 3);
                    
                    // Show tooltip
                    const tooltip = g.append("g")
                        .attr("class", "tooltip")
                        .attr("transform", `translate(${d.x + d.width + 10}, ${d.y})`);
                    
                    tooltip.append("rect")
                        .attr("width", 200)
                        .attr("height", 80)
                        .attr("rx", 4)
                        .attr("fill", "#1F2937")
                        .attr("stroke", "#374151")
                        .attr("stroke-width", 1);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 20)
                        .attr("fill", "#F3F4F6")
                        .attr("font-size", "12px")
                        .attr("font-weight", "bold")
                        .text(d.name);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 40)
                        .attr("fill", "#D1D5DB")
                        .attr("font-size", "10px")
                        .text(d.description);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 60)
                        .attr("fill", "#9CA3AF")
                        .attr("font-size", "9px")
                        .text(d.details);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).style("opacity", 0.9).attr("stroke-width", 2);
                    g.selectAll(".tooltip").remove();
                });
            
            // Add component labels
            componentRects.append("text")
                .attr("x", d => d.width / 2)
                .attr("y", d => d.height / 2 - 5)
                .attr("text-anchor", "middle")
                .attr("fill", "#FFFFFF")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(d => d.name.split(" ")[0]);
            
            componentRects.append("text")
                .attr("x", d => d.width / 2)
                .attr("y", d => d.height / 2 + 10)
                .attr("text-anchor", "middle")
                .attr("fill", "#FFFFFF")
                .attr("font-size", "10px")
                .text(d => d.name.split(" ").slice(1).join(" "));
            
            // Add data flow arrows
            const arrows = [
                { from: "input-embedding", to: "positional-encoding", type: "data" },
                { from: "positional-encoding", to: "multi-head-attention", type: "data" },
                { from: "multi-head-attention", to: "add-norm-1", type: "data" },
                { from: "add-norm-1", to: "feedforward", type: "data" },
                { from: "feedforward", to: "add-norm-2", type: "data" },
                { from: "add-norm-2", to: "output-projection", type: "data" },
                { from: "input-embedding", to: "add-norm-1", type: "residual" },
                { from: "add-norm-1", to: "add-norm-2", type: "residual" }
            ];
            
            arrows.forEach(arrow => {
                const fromComp = components.find(c => c.id === arrow.from);
                const toComp = components.find(c => c.id === arrow.to);
                
                if (fromComp && toComp) {
                    const startX = fromComp.x + fromComp.width;
                    const startY = fromComp.y + fromComp.height / 2;
                    const endX = toComp.x;
                    const endY = toComp.y + toComp.height / 2;
                    
                    // Enhanced connection arrows with improved layer hierarchy and connection clarity
                    const path = g.append("path")
                        .attr("d", `M ${startX} ${startY} Q ${(startX + endX) / 2} ${startY - 30} ${endX} ${endY}`)
                        .attr("fill", "none")
                        .attr("stroke", arrow.type === "residual" ? "#EF4444" : "#6B7280")
                        .attr("stroke-width", arrow.type === "residual" ? 4 : 3)
                        .attr("stroke-dasharray", arrow.type === "residual" ? "8,4" : "none")
                        .style("opacity", 0.9)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                        .style("transition", "all 0.3s ease");
                    
                    // Enhanced arrowhead with improved styling and connection clarity
                    const arrowhead = g.append("polygon")
                        .attr("points", `${endX-8},${endY-5} ${endX},${endY} ${endX-8},${endY+5}`)
                        .attr("fill", arrow.type === "residual" ? "#EF4444" : "#6B7280")
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                        .style("transition", "all 0.3s ease");
                }
            });
            
            // Add attention mechanism detail with enhanced positioning and layer hierarchy
            const attentionDetail = g.append("g")
                .attr("class", "attention-detail")
                .attr("transform", "translate(50, 350)");
            
            // Add background for attention detail section
            attentionDetail.append("rect")
                .attr("x", -10)
                .attr("y", -10)
                .attr("width", 350)
                .attr("height", 80)
                .attr("rx", 8)
                .attr("fill", "rgba(31, 41, 55, 0.6)")
                .attr("stroke", "#374151")
                .attr("stroke-width", 1)
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");
            
            attentionDetail.append("text")
                .attr("x", 0)
                .attr("y", 0)
                .attr("fill", "#F3F4F6")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                .text("Multi-Head Attention Mechanism");
            
            // Attention heads visualization with improved spacing and connection clarity
            const heads = ["Head 1", "Head 2", "Head 3", "Head 4"];
            const headGroups = attentionDetail.selectAll(".attention-head")
                .data(heads)
                .enter().append("g")
                .attr("class", "attention-head")
                .attr("transform", (d, i) => `translate(${i * 85}, 30)`);
            
            headGroups.append("rect")
                .attr("width", 65)
                .attr("height", 40)
                .attr("rx", 6)
                .attr("fill", "url(#attention-gradient)")
                .attr("stroke", "#374151")
                .attr("stroke-width", 2)
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.2))");
            
            headGroups.append("text")
                .attr("x", 32.5)
                .attr("y", 25)
                .attr("text-anchor", "middle")
                .attr("fill", "#FFFFFF")
                .attr("font-size", "10px")
                .attr("font-weight", "bold")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                .text(d => d);
            
            // Add mathematical notation with separated positioning to prevent overlap
            const mathNotation = g.append("g")
                .attr("class", "math-notation")
                .attr("transform", "translate(450, 350)");
            
            // Enhanced background for mathematical notation with improved separation
            mathNotation.append("rect")
                .attr("x", -15)
                .attr("y", -10)
                .attr("width", 320)
                .attr("height", 80)
                .attr("rx", 8)
                .attr("fill", "rgba(31, 41, 55, 0.9)")
                .attr("stroke", "#374151")
                .attr("stroke-width", 2)
                .style("filter", "drop-shadow(0 3px 6px rgba(0,0,0,0.4))");
            
            mathNotation.append("text")
                .attr("x", 0)
                .attr("y", 0)
                .attr("fill", "#F3F4F6")
                .attr("font-size", "13px")
                .attr("font-weight", "bold")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                .text("Attention(Q,K,V) = softmax(QK^T/√d_k)V");
            
            mathNotation.append("text")
                .attr("x", 0)
                .attr("y", 20)
                .attr("fill", "#D1D5DB")
                .attr("font-size", "11px")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                .text("MultiHead(Q,K,V) = Concat(head₁,...,headₕ)W^O");
            
            mathNotation.append("text")
                .attr("x", 0)
                .attr("y", 40)
                .attr("fill", "#D1D5DB")
                .attr("font-size", "11px")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                .text("where headᵢ = Attention(QWᵢ^Q, KWᵢ^K, VWᵢ^V)");
            
            // Add legend
            const legend = g.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(50, 450)");
            
            const legendItems = [
                { color: "url(#attention-gradient)", label: "Attention Mechanism" },
                { color: "url(#feedforward-gradient)", label: "Feedforward Network" },
                { color: "url(#positional-gradient)", label: "Positional Encoding" },
                { color: "url(#normalization-gradient)", label: "Layer Normalization" }
            ];
            
            const legendGroups = legend.selectAll(".legend-item")
                .data(legendItems)
                .enter().append("g")
                .attr("class", "legend-item")
                .attr("transform", (d, i) => `translate(${i * 150}, 0)`);
            
            legendGroups.append("rect")
                .attr("width", 15)
                .attr("height", 15)
                .attr("rx", 2)
                .attr("fill", d => d.color);
            
            legendGroups.append("text")
                .attr("x", 20)
                .attr("y", 12)
                .attr("fill", "#D1D5DB")
                .attr("font-size", "11px")
                .text(d => d.label);
            
            // Add entrance animation
            componentRects.selectAll("rect")
                .style("opacity", 0)
                .transition()
                .duration(800)
                .delay((d, i) => i * 100)
                .style("opacity", 0.9);
        }

        function renderLLMMemoryContextViz() {
            const container = d3.select("#llm-memory-context-viz");
            container.selectAll("*").remove();
            
            const width = container.node().offsetWidth;
            const height = 600;
            const margin = { top: 20, right: 20, bottom: 20, left: 20 };
            const vizWidth = width - margin.left - margin.right;
            const vizHeight = height - margin.top - margin.bottom;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Define gradients
            const defs = svg.append("defs");
            
            const contextGradient = defs.append("linearGradient")
                .attr("id", "context-gradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "100%");
            contextGradient.append("stop").attr("offset", "0%").attr("stop-color", "#3B82F6");
            contextGradient.append("stop").attr("offset", "100%").attr("stop-color", "#1E40AF");
            
            const memoryGradient = defs.append("linearGradient")
                .attr("id", "memory-gradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "100%");
            memoryGradient.append("stop").attr("offset", "0%").attr("stop-color", "#10B981");
            memoryGradient.append("stop").attr("offset", "100%").attr("stop-color", "#047857");
            
            const efficientGradient = defs.append("linearGradient")
                .attr("id", "efficient-gradient")
                .attr("x1", "0%").attr("y1", "0%")
                .attr("x2", "100%").attr("y2", "100%");
            efficientGradient.append("stop").attr("offset", "0%").attr("stop-color", "#F59E0B");
            efficientGradient.append("stop").attr("offset", "100%").attr("stop-color", "#D97706");
            
            // Architecture data with context window and memory characteristics
            const architectures = [
                {
                    name: "GPT-3.5",
                    contextWindow: 4096,
                    maxContext: 16384,
                    memoryType: "Standard Attention",
                    complexity: "O(n²)",
                    efficiency: "Medium",
                    color: "url(#context-gradient)",
                    x: 50,
                    y: 100,
                    width: 120,
                    height: 80,
                    description: "Standard transformer with fixed context window",
                    details: "Quadratic attention complexity limits practical context length"
                },
                {
                    name: "GPT-4",
                    contextWindow: 8192,
                    maxContext: 128000,
                    memoryType: "Extended Context",
                    complexity: "O(n²)",
                    efficiency: "Medium",
                    color: "url(#context-gradient)",
                    x: 200,
                    y: 100,
                    width: 120,
                    height: 80,
                    description: "Extended context with improved efficiency",
                    details: "Larger context window with optimized attention patterns"
                },
                {
                    name: "Claude-3.5",
                    contextWindow: 200000,
                    maxContext: 200000,
                    memoryType: "Large Context",
                    complexity: "O(n²)",
                    efficiency: "High",
                    color: "url(#memory-gradient)",
                    x: 350,
                    y: 100,
                    width: 120,
                    height: 80,
                    description: "Very large context window for long documents",
                    details: "Optimized for processing entire books and long conversations"
                },
                {
                    name: "Longformer",
                    contextWindow: 4096,
                    maxContext: 16384,
                    memoryType: "Sliding Window",
                    complexity: "O(n)",
                    efficiency: "High",
                    color: "url(#efficient-gradient)",
                    x: 50,
                    y: 220,
                    width: 120,
                    height: 80,
                    description: "Linear complexity with sliding window attention",
                    details: "Efficient processing of long documents with local attention"
                },
                {
                    name: "BigBird",
                    contextWindow: 4096,
                    maxContext: 16384,
                    memoryType: "Sparse Attention",
                    complexity: "O(n)",
                    efficiency: "High",
                    color: "url(#efficient-gradient)",
                    x: 200,
                    y: 220,
                    width: 120,
                    height: 80,
                    description: "Sparse attention patterns for efficiency",
                    details: "Global + local + random attention for linear complexity"
                },
                {
                    name: "Mamba",
                    contextWindow: 2048,
                    maxContext: 2048,
                    memoryType: "State Space",
                    complexity: "O(n)",
                    efficiency: "Very High",
                    color: "url(#efficient-gradient)",
                    x: 350,
                    y: 220,
                    width: 120,
                    height: 80,
                    description: "Linear-time sequence modeling with state space models",
                    details: "Revolutionary approach with constant memory per layer"
                }
            ];
            
            // Create architecture rectangles
            const archRects = g.selectAll(".architecture")
                .data(architectures)
                .enter().append("g")
                .attr("class", "architecture")
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            archRects.append("rect")
                .attr("width", d => d.width)
                .attr("height", d => d.height)
                .attr("rx", 8)
                .attr("fill", d => d.color)
                .attr("stroke", "#374151")
                .attr("stroke-width", 2)
                .style("opacity", 0.9)
                .on("mouseover", function(event, d) {
                    d3.select(this).style("opacity", 1).attr("stroke-width", 3);
                    
                    // Show detailed tooltip
                    const tooltip = g.append("g")
                        .attr("class", "tooltip")
                        .attr("transform", `translate(${d.x + d.width + 10}, ${d.y})`);
                    
                    tooltip.append("rect")
                        .attr("width", 250)
                        .attr("height", 120)
                        .attr("rx", 4)
                        .attr("fill", "#1F2937")
                        .attr("stroke", "#374151")
                        .attr("stroke-width", 1);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 20)
                        .attr("fill", "#F3F4F6")
                        .attr("font-size", "12px")
                        .attr("font-weight", "bold")
                        .text(d.name);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 40)
                        .attr("fill", "#D1D5DB")
                        .attr("font-size", "10px")
                        .text(`Context: ${d.contextWindow.toLocaleString()} tokens`);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 60)
                        .attr("fill", "#D1D5DB")
                        .attr("font-size", "10px")
                        .text(`Memory: ${d.memoryType}`);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 80)
                        .attr("fill", "#D1D5DB")
                        .attr("font-size", "10px")
                        .text(`Complexity: ${d.complexity}`);
                    
                    tooltip.append("text")
                        .attr("x", 10)
                        .attr("y", 100)
                        .attr("fill", "#9CA3AF")
                        .attr("font-size", "9px")
                        .text(d.details);
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).style("opacity", 0.9).attr("stroke-width", 2);
                    g.selectAll(".tooltip").remove();
                });
            
            // Add architecture labels
            archRects.append("text")
                .attr("x", d => d.width / 2)
                .attr("y", d => d.height / 2 - 10)
                .attr("text-anchor", "middle")
                .attr("fill", "#FFFFFF")
                .attr("font-size", "11px")
                .attr("font-weight", "bold")
                .text(d => d.name);
            
            archRects.append("text")
                .attr("x", d => d.width / 2)
                .attr("y", d => d.height / 2 + 5)
                .attr("text-anchor", "middle")
                .attr("fill", "#FFFFFF")
                .attr("font-size", "9px")
                .text(d => `${d.contextWindow.toLocaleString()} tokens`);
            
            archRects.append("text")
                .attr("x", d => d.width / 2)
                .attr("y", d => d.height / 2 + 20)
                .attr("text-anchor", "middle")
                .attr("fill", "#FFFFFF")
                .attr("font-size", "8px")
                .text(d => d.complexity);
            
            // Create context window comparison chart with improved positioning
            const chartData = architectures.map(arch => ({
                name: arch.name,
                contextWindow: arch.contextWindow,
                maxContext: arch.maxContext,
                efficiency: arch.efficiency
            }));
            
            const chartX = 50;
            const chartY = 340;
            const chartWidth = 380;
            const chartHeight = 140;
            
            const xScale = d3.scaleBand()
                .domain(chartData.map(d => d.name))
                .range([0, chartWidth])
                .padding(0.1);
            
            const yScale = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d.maxContext)])
                .range([chartHeight, 0]);
            
            const chartG = g.append("g")
                .attr("class", "context-chart")
                .attr("transform", `translate(${chartX}, ${chartY})`);
            
            // Add chart title
            chartG.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", -10)
                .attr("text-anchor", "middle")
                .attr("fill", "#F3F4F6")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .text("Context Window Comparison");
            
            // Add bars for context windows with improved styling
            chartG.selectAll(".context-bar")
                .data(chartData)
                .enter().append("rect")
                .attr("class", "context-bar")
                .attr("x", d => xScale(d.name))
                .attr("y", d => yScale(d.contextWindow))
                .attr("width", xScale.bandwidth())
                .attr("height", d => chartHeight - yScale(d.contextWindow))
                .attr("fill", d => {
                    switch(d.efficiency) {
                        case "Very High": return "url(#efficient-gradient)";
                        case "High": return "url(#memory-gradient)";
                        default: return "url(#context-gradient)";
                    }
                })
                .attr("opacity", 0.9)
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.2))");
            
            // Add max context bars with improved styling
            chartG.selectAll(".max-context-bar")
                .data(chartData)
                .enter().append("rect")
                .attr("class", "max-context-bar")
                .attr("x", d => xScale(d.name) + xScale.bandwidth() * 0.1)
                .attr("y", d => yScale(d.maxContext))
                .attr("width", xScale.bandwidth() * 0.8)
                .attr("height", d => chartHeight - yScale(d.maxContext))
                .attr("fill", "none")
                .attr("stroke", "#9CA3AF")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "4,4")
                .style("opacity", 0.8);
            
            // Add x-axis
            chartG.append("g")
                .attr("transform", `translate(0, ${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .attr("fill", "#9CA3AF")
                .attr("font-size", "10px")
                .style("text-anchor", "end")
                .attr("transform", "rotate(-45)");
            
            // Add y-axis
            chartG.append("g")
                .call(d3.axisLeft(yScale).tickFormat(d => d >= 1000 ? `${d/1000}k` : d))
                .selectAll("text")
                .attr("fill", "#9CA3AF")
                .attr("font-size", "10px");
            
            // Add complexity comparison with enhanced positioning to prevent overlap
            const complexityG = g.append("g")
                .attr("class", "complexity-comparison")
                .attr("transform", "translate(450, 340)");
            
            // Add background for complexity legend
            complexityG.append("rect")
                .attr("x", -10)
                .attr("y", -10)
                .attr("width", 200)
                .attr("height", 120)
                .attr("rx", 8)
                .attr("fill", "rgba(31, 41, 55, 0.8)")
                .attr("stroke", "#374151")
                .attr("stroke-width", 1)
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");
            
            complexityG.append("text")
                .attr("x", 0)
                .attr("y", 0)
                .attr("fill", "#F3F4F6")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                .text("Computational Complexity");
            
            const complexityData = [
                { type: "Standard Attention", complexity: "O(n²)", efficiency: "Low", color: "#EF4444" },
                { type: "Sliding Window", complexity: "O(n)", efficiency: "High", color: "#10B981" },
                { type: "Sparse Attention", complexity: "O(n)", efficiency: "High", color: "#F59E0B" },
                { type: "State Space Models", complexity: "O(n)", efficiency: "Very High", color: "#8B5CF6" }
            ];
            
            const complexityItems = complexityG.selectAll(".complexity-item")
                .data(complexityData)
                .enter().append("g")
                .attr("class", "complexity-item")
                .attr("transform", (d, i) => `translate(0, ${i * 25 + 20})`);
            
            complexityItems.append("rect")
                .attr("width", 16)
                .attr("height", 16)
                .attr("rx", 3)
                .attr("fill", d => d.color)
                .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))");
            
            complexityItems.append("text")
                .attr("x", 22)
                .attr("y", 12)
                .attr("fill", "#D1D5DB")
                .attr("font-size", "11px")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                .text(d => `${d.type}: ${d.complexity}`);
            
            // Add memory mechanism diagram with enhanced positioning to prevent overlap
            const memoryG = g.append("g")
                .attr("class", "memory-mechanisms")
                .attr("transform", "translate(50, 500)");
            
            // Add background for memory strategies section
            memoryG.append("rect")
                .attr("x", -10)
                .attr("y", -10)
                .attr("width", 500)
                .attr("height", 60)
                .attr("rx", 8)
                .attr("fill", "rgba(31, 41, 55, 0.6)")
                .attr("stroke", "#374151")
                .attr("stroke-width", 1)
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");
            
            memoryG.append("text")
                .attr("x", 0)
                .attr("y", 0)
                .attr("fill", "#F3F4F6")
                .attr("font-size", "12px")
                .attr("font-weight", "bold")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                .text("Memory Management Strategies");
            
            const memoryStrategies = [
                { name: "Attention Caching", description: "Cache key-value pairs for reuse" },
                { name: "Context Compression", description: "Compress old context to save memory" },
                { name: "Hierarchical Processing", description: "Process documents in chunks" },
                { name: "External Memory", description: "Use external storage for long-term memory" }
            ];
            
            const strategyItems = memoryG.selectAll(".strategy-item")
                .data(memoryStrategies)
                .enter().append("g")
                .attr("class", "strategy-item")
                .attr("transform", (d, i) => `translate(${i * 120}, 20)`);
            
            strategyItems.append("circle")
                .attr("r", 10)
                .attr("fill", "url(#memory-gradient)")
                .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");
            
            strategyItems.append("text")
                .attr("x", 0)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("fill", "#D1D5DB")
                .attr("font-size", "9px")
                .attr("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                .text(d => d.name);
            
            strategyItems.append("text")
                .attr("x", 0)
                .attr("y", 40)
                .attr("text-anchor", "middle")
                .attr("fill", "#9CA3AF")
                .attr("font-size", "8px")
                .text(d => d.description);
            
            // Add entrance animation
            archRects.selectAll("rect")
                .style("opacity", 0)
                .transition()
                .duration(800)
                .delay((d, i) => i * 100)
                .style("opacity", 0.9);
        }

        // Foundation Visualizations are defined above, now we define the main render function
        function renderAllVisualizations() {
            try {
                console.log('Starting to render all visualizations...');
                
                // Foundation Visualizations (LLM Foundations section)
                renderSystemDesignViz(); renderOSViz(); renderMlDlViz(); renderTransformerViz(); 
                
                // Core Technology Visualizations  
                renderAgenticViz(); renderMlopsViz(); renderRagViz(); renderVectorDbViz(); renderMultimodalViz();
                
                // LLM Architecture Visualizations
                if (typeof renderLLMPerformanceViz === 'function') renderLLMPerformanceViz(); 
                if (typeof renderLLMDecisionTreeViz === 'function') renderLLMDecisionTreeViz(); 
                if (typeof renderLLMTimelineViz === 'function') renderLLMTimelineViz(); 
                if (typeof renderLLMComponentBreakdownViz === 'function') renderLLMComponentBreakdownViz(); 
                if (typeof renderLLMMemoryContextViz === 'function') renderLLMMemoryContextViz();
                
                // Interactive Visualizations
                if (typeof renderArchitecturePlaygroundViz === 'function') renderArchitecturePlaygroundViz(); 
                if (typeof renderAnimatedCodeExamplesViz === 'function') renderAnimatedCodeExamplesViz();
                
                // Advanced Visualizations (will be called later after functions are defined)
                setTimeout(() => {
                    try {
                        if (typeof renderFoundationModelViz === 'function') renderFoundationModelViz();
                        if (typeof renderFineTuningViz === 'function') renderFineTuningViz();
                        if (typeof renderVectorDbVizAdvanced === 'function') renderVectorDbVizAdvanced();
                        if (typeof renderAdvancedRAGPipelinesViz === 'function') renderAdvancedRAGPipelinesViz();
                        if (typeof renderChainOfThoughtDemo === 'function') renderChainOfThoughtDemo();
                        if (typeof renderTreeOfThoughtsDemo === 'function') renderTreeOfThoughtsDemo();
                        if (typeof renderInferenceOptimizationViz === 'function') renderInferenceOptimizationViz();
                        if (typeof renderAdvancedRetrievalViz === 'function') renderAdvancedRetrievalViz();
                        if (typeof renderPromptEngineeringViz === 'function') renderPromptEngineeringViz();
                        if (typeof renderLLMAppStackViz === 'function') renderLLMAppStackViz();
                        if (typeof renderPromptInjectionViz === 'function') renderPromptInjectionViz();
                        if (typeof renderCloudNativeViz === 'function') renderCloudNativeViz();
                        if (typeof renderMultimodalDataViz === 'function') renderMultimodalDataViz();
                        if (typeof renderLLMOpsObservabilityViz === 'function') renderLLMOpsObservabilityViz();
                        if (typeof renderLLMEvalViz === 'function') renderLLMEvalViz();
                        if (typeof renderCICDIaCViz === 'function') renderCICDIaCViz();
                        
                        // Protocol Visualizations
                        if (typeof renderUPGMathematicalViz === 'function') renderUPGMathematicalViz();
                        if (typeof renderHPTAlgorithmViz === 'function') renderHPTAlgorithmViz();
                        if (typeof renderLLMTypesComparisonViz === 'function') renderLLMTypesComparisonViz();
                        if (typeof renderAgenticRAGComparisonViz === 'function') renderAgenticRAGComparisonViz();
                        if (typeof renderAgenticFrameworksViz === 'function') renderAgenticFrameworksViz();
                        if (typeof renderFineTuningTechniquesViz === 'function') renderFineTuningTechniquesViz();
                        if (typeof renderCostPerformanceCalculatorViz === 'function') renderCostPerformanceCalculatorViz();
                        if (typeof renderFrontendIntegrationViz === 'function') renderFrontendIntegrationViz();
                        if (typeof renderBiasInterpretabilityViz === 'function') renderBiasInterpretabilityViz();
                        if (typeof renderMCPProtocolViz === 'function') renderMCPProtocolViz();
                        if (typeof renderA2AProtocolViz === 'function') renderA2AProtocolViz();
                        if (typeof renderAGUIProtocolViz === 'function') renderAGUIProtocolViz();
                        if (typeof renderAdaptationSpeedAdvantageViz === 'function') renderAdaptationSpeedAdvantageViz();
                        
                        console.log('All advanced visualizations rendered successfully');
                    } catch (error) {
                        console.error('Error rendering advanced visualizations:', error);
                    }
                }, 200);
                
                console.log('Foundation visualizations rendered successfully');
            } catch (error) {
                console.error('Error rendering visualizations:', error);
            }
        }

            // --- DIAGNOSTIC & DEBUG FRAMEWORK ---
            function runDiagnostics() {
                console.log('🔍 STARTING COMPREHENSIVE DIAGNOSTICS...');
                
                // Priority 1.1: Script Tag Structure Check
                const scripts = document.querySelectorAll('script');
                console.log(`📊 Script tags found: ${scripts.length}`);
                
                // Priority 1.2: Function Definition Check
                const requiredFunctions = [
                    'renderSystemDesignViz', 'renderOSViz', 'renderMlDlViz', 'renderTransformerViz',
                    'renderFoundationModelViz', 'renderAdvancedRAGPipelinesViz', 'arrowMarker', 'getResponsiveMargins'
                ];
                
                console.log('🔧 Function availability check:');
                requiredFunctions.forEach(func => {
                    const available = typeof window[func] === 'function';
                    console.log(`  ${available ? '✅' : '❌'} ${func}: ${typeof window[func]}`);
                });
                
                // Priority 1.3: DOM Ready State Check
                console.log(`📋 DOM readyState: ${document.readyState}`);
                console.log(`🌐 D3.js available: ${typeof d3 !== 'undefined' ? '✅' : '❌'}`);
                
                // Priority 1.4: Container Element Check
                const containers = [
                    'system-design-viz', 'os-viz', 'ml-dl-viz', 'transformer-viz',
                    'foundation-model-viz', 'advanced-rag-pipelines-viz'
                ];
                
                console.log('🎯 Container elements check:');
                containers.forEach(id => {
                    const element = document.getElementById(id);
                    const bounds = element ? element.getBoundingClientRect() : null;
                    console.log(`  ${element ? '✅' : '❌'} #${id}: ${bounds ? `${bounds.width}x${bounds.height}` : 'NOT FOUND'}`);
                });
                
                return true;
            }

            // --- PRINT-FRIENDLY TOGGLE SYSTEM ---
            function initializePrintMode() {
                // Add toggle buttons to navigation
                const nav = document.getElementById('navigation');
                if (nav) {
                    // Print-friendly toggle
                    const printToggle = document.createElement('button');
                    printToggle.innerHTML = '🖨️ Print Mode';
                    printToggle.className = 'nav-link bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded text-sm';
                    printToggle.onclick = togglePrintFriendlyMode;
                    
                    // PDF export button
                    const pdfButton = document.createElement('button');
                    pdfButton.innerHTML = '📄 Export PDF';
                    pdfButton.className = 'nav-link bg-blue-700 hover:bg-blue-600 px-3 py-1 rounded text-sm';
                    pdfButton.onclick = exportToPDF;
                    
                    nav.appendChild(printToggle);
                    nav.appendChild(pdfButton);
                }
            }

            function togglePrintFriendlyMode() {
                document.body.classList.toggle('print-friendly-mode');
                const isActive = document.body.classList.contains('print-friendly-mode');
                console.log(`🖨️ Print-friendly mode: ${isActive ? 'ENABLED' : 'DISABLED'}`);
                
                if (isActive) {
                    // Re-render all visualizations in print-friendly mode
                    setTimeout(() => renderAllVisualizations(), 100);
                }
            }

            function exportToPDF() {
                // Open print-optimized version in new tab
                const printWindow = window.open('', '_blank');
                const currentHTML = document.documentElement.outerHTML;
                
                // Add print-specific CSS and remove animations
                const printHTML = currentHTML.replace(
                    '<body class="blueprint-grid">',
                    '<body class="blueprint-grid print-friendly-mode pdf-export-mode">'
                );
                
                printWindow.document.write(printHTML);
                printWindow.document.close();
                
                // Trigger print dialog after content loads
                printWindow.onload = () => {
                    setTimeout(() => {
                        printWindow.print();
                    }, 1000);
                };
            }

            // --- SAFE INITIALIZATION SEQUENCE ---
            document.addEventListener('DOMContentLoaded', function () {
                console.log('🚀 DOM Content Loaded - Starting initialization...');
                
                // Step 1: Run diagnostics
                if (runDiagnostics()) {
                    console.log('✅ Diagnostics passed, proceeding with initialization...');
                    
                    // Step 2: Initialize print mode controls
                    initializePrintMode();
                    
                    // Step 3: Start visualization rendering with progressive loading
                    setTimeout(() => {
                        console.log('🎨 Starting visualization rendering...');
                        renderAllVisualizations();
                    }, 200);
                } else {
                    console.error('❌ Diagnostics failed - aborting initialization');
                }
            });
            
            // Enhanced responsive resize handler for main visualizations
            let mainResizeTimer;
            let mainLastWidth = window.innerWidth;
            let mainLastHeight = window.innerHeight;
            
            function handleMainResize() {
                const currentWidth = window.innerWidth;
                const currentHeight = window.innerHeight;
                
                // Only re-render if there's a significant size change
                if (Math.abs(currentWidth - mainLastWidth) > 50 || Math.abs(currentHeight - mainLastHeight) > 50) {
                    mainLastWidth = currentWidth;
                    mainLastHeight = currentHeight;
                    
                    clearTimeout(mainResizeTimer);
                    mainResizeTimer = setTimeout(renderAllVisualizations, 150);
                }
            }
            
            window.addEventListener('resize', handleMainResize);

            const navLinks = document.querySelectorAll('.nav-link');
            const sections = document.querySelectorAll('main section');
            const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { navLinks.forEach(link => { const href = link.getAttribute('href'); link.classList.toggle('active', href === `#${entry.target.id}`); }); } }); }, { rootMargin: "-40% 0px -40% 0px" });
            sections.forEach(section => observer.observe(section));

            const ollamaBtn = document.getElementById('ollama-connect-btn');
            const modal = document.getElementById('ollama-modal');
            const closeModalBtn = document.getElementById('close-modal-btn');
            
            // Only add event listeners if elements exist
            if (ollamaBtn && modal && closeModalBtn) {
                const openModal = () => modal.classList.add('active');
                const closeModal = () => modal.classList.remove('active');
                ollamaBtn.addEventListener('click', openModal);
                closeModalBtn.addEventListener('click', closeModal);
                modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
                document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && modal.classList.contains('active')) closeModal(); });
            }
        });
    </script>
    <script>
        // Foundation Model Ecosystem and Advanced Pattern Visualizations
        // Note: Removed duplicate DOMContentLoaded - utility functions are now defined globally above

            function renderFoundationModelViz() {
                const container = d3.select("#foundation-model-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 40 : isTablet ? 50 : 60, 
                    right: isMobile ? 40 : isTablet ? 50 : 60, 
                    bottom: isMobile ? 60 : isTablet ? 70 : 80, 
                    left: isMobile ? 40 : isTablet ? 50 : 80 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for sophisticated backgrounds
                const defs = svg.append("defs");
                const modalityGradients = [
                    { id: "multimodal-grad", colors: ["#8338EC", "#A855F7"] },
                    { id: "code-grad", colors: ["#3A86FF", "#60A5FA"] },
                    { id: "opensource-grad", colors: ["#2EC4B6", "#34D399"] },
                    { id: "voice-grad", colors: ["#00A6FB", "#0EA5E9"] },
                    { id: "edge-grad", colors: ["#FF6B6B", "#F87171"] }
                ];

                modalityGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                // Quadrant background patterns with flexible sizing
                const quadrantWidth = Math.max(width / 2, 200); // Ensure minimum quadrant width
                const quadrantHeight = Math.max(height / 2, 150); // Ensure minimum quadrant height
                const quadrants = [
                    { x: 0, y: 0, w: quadrantWidth, h: quadrantHeight, label: "Proprietary + High Capability", pattern: "proprietary-high" },
                    { x: quadrantWidth, y: 0, w: quadrantWidth, h: quadrantHeight, label: "Open + High Capability", pattern: "open-high" },
                    { x: 0, y: quadrantHeight, w: quadrantWidth, h: quadrantHeight, label: "Proprietary + Specialized", pattern: "proprietary-spec" },
                    { x: quadrantWidth, y: quadrantHeight, w: quadrantWidth, h: quadrantHeight, label: "Open + Specialized", pattern: "open-spec" }
                ];

                quadrants.forEach((q, i) => {
                    const colors = ["rgba(131, 56, 236, 0.03)", "rgba(46, 196, 182, 0.03)", "rgba(58, 134, 255, 0.03)", "rgba(255, 107, 107, 0.03)"];
                    svg.append("rect")
                        .attr("x", q.x)
                        .attr("y", q.y)
                        .attr("width", q.w)
                        .attr("height", q.h)
                        .attr("fill", colors[i])
                        .attr("stroke", "rgba(224, 224, 224, 0.2)")
                        .attr("stroke-dasharray", "5,5");
                        
                    svg.append("text")
                        .attr("x", q.x + q.w / 2)
                        .attr("y", q.y + (isMobile ? 15 : 20))
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", isMobile ? "9px" : "11px")
                        .style("font-weight", "500")
                        .text(q.label);
                });

                // Enhanced model data with performance metrics
                const models = [
                    { name: "GPT-5", x: 0.2, y: 0.95, size: 14, modality: "General Multimodal", details: "Expected leader in complex reasoning and fluid multimodal interaction. Estimated 100T+ parameters with advanced multimodal understanding.", performance: 98, cost: 95, availability: "Q2 2025" },
                    { name: "Gemini 2.5 Pro", x: 0.25, y: 0.93, size: 13, modality: "General Multimodal", details: "Deeply integrated with Google's ecosystem; excels at video and long context understanding up to 2M tokens.", performance: 97, cost: 92, availability: "Available" },
                    { name: "Gemini 2.5 Flash", x: 0.3, y: 0.85, size: 10, modality: "General Multimodal", details: "High-speed, lower-cost version optimized for scalable applications and real-time inference.", performance: 89, cost: 60, availability: "Available" },
                    { name: "Claude 4", x: 0.15, y: 0.92, size: 12, modality: "Text & Code", details: "Specialized in safety, constitutional AI, and extremely long context windows (1M+ tokens) for enterprise applications.", performance: 96, cost: 88, availability: "Q1 2025" },
                    { name: "Llama 4 (70B)", x: 0.8, y: 0.85, size: 12, modality: "Open-Source Generalist", details: "The dominant open-source model for general-purpose fine-tuning with commercial-friendly licensing.", performance: 90, cost: 30, availability: "Available" },
                    { name: "DeepSeek-R1-Coder", x: 0.85, y: 0.82, size: 10, modality: "Text & Code", details: "Leading open-source model highly specialized for code generation, debugging, and software engineering tasks.", performance: 92, cost: 25, availability: "Available" },
                    { name: "Qwen 2.5 (72B)", x: 0.75, y: 0.83, size: 11, modality: "Open-Source Generalist", details: "Strong multilingual capabilities and general reasoning from Alibaba's research with excellent Chinese language support.", performance: 88, cost: 28, availability: "Available" },
                    { name: "Moshi-V2V", x: 0.4, y: 0.75, size: 8, modality: "Voice-to-Voice", details: "Specialized foundation model for real-time, low-latency voice conversations with emotional understanding.", performance: 85, cost: 70, availability: "Beta" },
                    { name: "Qwen-VL-Micro", x: 0.9, y: 0.65, size: 6, modality: "Edge Multimodal", details: "Hyper-efficient vision-language model optimized for on-device inference and microcontroller deployment.", performance: 75, cost: 15, availability: "Available" }
                ];

                const modalityColors = {
                    "General Multimodal": "url(#multimodal-grad)",
                    "Text & Code": "url(#code-grad)",
                    "Open-Source Generalist": "url(#opensource-grad)",
                    "Voice-to-Voice": "url(#voice-grad)",
                    "Edge Multimodal": "url(#edge-grad)"
                };

                const modalities = Object.keys(modalityColors);
                const xScale = d3.scaleLinear().domain([0, 1]).range([0, width]);
                const yScale = d3.scaleLinear().domain([0.6, 1]).range([height, 0]);

                // Enhanced axis styling with gradient lines
                svg.append("line").attr("x1", 0).attr("y1", height).attr("x2", width).attr("y2", height).attr("stroke", "url(#opensource-grad)").attr("stroke-width", 3).attr("opacity", 0.6);
                svg.append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", height).attr("stroke", "url(#multimodal-grad)").attr("stroke-width", 3).attr("opacity", 0.6);

                // Grid lines for better readability
                for (let i = 0.1; i <= 0.9; i += 0.2) {
                    svg.append("line").attr("x1", xScale(i)).attr("y1", 0).attr("x2", xScale(i)).attr("y2", height).attr("stroke", "var(--secondary-border)").attr("stroke-dasharray", "2,4").attr("opacity", 0.3);
                }
                for (let i = 0.7; i <= 0.9; i += 0.1) {
                    svg.append("line").attr("x1", 0).attr("y1", yScale(i)).attr("x2", width).attr("y2", yScale(i)).attr("stroke", "var(--secondary-border)").attr("stroke-dasharray", "2,4").attr("opacity", 0.3);
                }

                // Enhanced axis labels with responsive positioning and sizing
                svg.append("text")
                    .attr("text-anchor", "end")
                    .attr("x", width + (isMobile ? 5 : 10))
                    .attr("y", height + (isMobile ? 20 : 25))
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "600")
                    .style("font-size", isMobile ? "11px" : "14px")
                    .text("Open Source & Customizable →");
                    
                svg.append("text")
                    .attr("text-anchor", "start")
                    .attr("x", isMobile ? -10 : -15)
                    .attr("y", isMobile ? -15 : -20)
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "600")
                    .style("font-size", isMobile ? "11px" : "14px")
                    .text("↑ General Capability");

                // Performance vs Cost correlation lines
                models.forEach((model, i) => {
                    if (i > 0) {
                        const prevModel = models[i - 1];
                        if (model.modality === prevModel.modality) {
                            svg.append("line")
                                .attr("x1", xScale(prevModel.x)).attr("y1", yScale(prevModel.y))
                                .attr("x2", xScale(model.x)).attr("y2", yScale(model.y))
                                .attr("stroke", modalityColors[model.modality])
                                .attr("stroke-width", 1)
                                .attr("stroke-dasharray", "3,3")
                                .attr("opacity", 0.4);
                        }
                    }
                });

                // Responsive node sizing calculation
                const calculateNodeSize = (baseSize, containerWidth, containerHeight) => {
                    const scaleFactor = Math.min(containerWidth / 800, containerHeight / 600, 1.2);
                    return Math.max(baseSize * scaleFactor, baseSize * 0.7); // Minimum 70% of original size
                };

                // Enhanced model nodes with advanced pre-attentive attributes and layered effects
                const nodes = svg.selectAll(".model-node").data(models).enter().append("g")
                    .attr("class", "model-node interactive-node")
                    .attr("transform", d => `translate(${xScale(d.x)}, ${yScale(d.y)})`)
                    .attr("opacity", d => d.availability === "Available" ? 1 : d.availability === "Beta" ? 0.85 : 0.65) // opacity encodes availability
                    .on("mouseover", (event, d) => {
                        // Dynamic attribute highlighting on hover
                        d3.select(this).selectAll("circle, rect, polygon, ellipse").transition().duration(200)
                            .attr("stroke-width", 3)
                            .attr("stroke", "rgba(255, 255, 255, 0.8)");
                        showTooltip(event, `<b>${d.name}</b><br><span style='color:${modalityColors[d.modality] === 'url(#multimodal-grad)' ? '#8338EC' : '#3A86FF'};'>●</span> ${d.modality}<br><b>Performance:</b> ${d.performance}/100<br><b>Cost Index:</b> ${d.cost}/100<br><b>Availability:</b> ${d.availability}<br><br>${d.details}`);
                    })
                    .on("mouseout", function () {
                        // Reset highlighting
                        d3.select(this).selectAll("circle, rect, polygon, ellipse").transition().duration(200)
                            .attr("stroke-width", 2)
                            .attr("stroke", "rgba(255, 255, 255, 0.4)");
                        hideTooltip();
                    });

                // Pre-attentive shape encoding based on modality type
                const shapeMapping = {
                    "General Multimodal": "circle",
                    "Text & Code": "rect",
                    "Open-Source Generalist": "polygon",
                    "Voice-to-Voice": "ellipse",
                    "Edge Multimodal": "diamond"
                };

                // Add outer glow effect based on performance with responsive collision detection
                nodes.append("circle")
                    .attr("r", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return Math.min(d.performance / 100 * responsiveSize * 1.5 + responsiveSize, responsiveSize * 2);
                    })
                    .attr("fill", d => modalityColors[d.modality])
                    .attr("opacity", 0.15)
                    .style("filter", "blur(6px)");

                // Add performance ring indicator with responsive sizing
                nodes.append("circle")
                    .attr("r", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return Math.min(d.performance / 100 * responsiveSize * 1.2 + responsiveSize * 0.6, responsiveSize * 1.5);
                    })
                    .attr("fill", "none")
                    .attr("stroke", d => modalityColors[d.modality])
                    .attr("stroke-width", isMobile ? 1.5 : 2)
                    .attr("opacity", 0.6)
                    .style("stroke-dasharray", d => `${d.performance * 0.4} ${100 - d.performance * 0.4}`);

                // Main model shape with pre-attentive encoding and responsive sizing
                nodes.each(function (d) {
                    const g = d3.select(this);
                    const shape = shapeMapping[d.modality];
                    const responsiveSize = calculateNodeSize(d.size, width, height);
                    const strokeWidth = isMobile ? 1.5 : 2;

                    if (shape === "circle") {
                        g.append("circle")
                            .attr("r", responsiveSize)
                            .attr("fill", modalityColors[d.modality])
                            .attr("stroke", "rgba(255, 255, 255, 0.4)")
                            .attr("stroke-width", strokeWidth)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                    } else if (shape === "rect") {
                        g.append("rect")
                            .attr("x", -responsiveSize).attr("y", -responsiveSize)
                            .attr("width", responsiveSize * 2).attr("height", responsiveSize * 2)
                            .attr("fill", modalityColors[d.modality])
                            .attr("stroke", "rgba(255, 255, 255, 0.4)")
                            .attr("stroke-width", strokeWidth)
                            .attr("rx", 3)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                    } else if (shape === "polygon") {
                        const points = [
                            [0, -responsiveSize],
                            [responsiveSize * 0.866, responsiveSize * 0.5],
                            [-responsiveSize * 0.866, responsiveSize * 0.5]
                        ].map(p => p.join(",")).join(" ");
                        g.append("polygon")
                            .attr("points", points)
                            .attr("fill", modalityColors[d.modality])
                            .attr("stroke", "rgba(255, 255, 255, 0.4)")
                            .attr("stroke-width", strokeWidth)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                    } else if (shape === "ellipse") {
                        g.append("ellipse")
                            .attr("rx", responsiveSize * 1.2).attr("ry", responsiveSize * 0.8)
                            .attr("fill", modalityColors[d.modality])
                            .attr("stroke", "rgba(255, 255, 255, 0.4)")
                            .attr("stroke-width", strokeWidth)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                    } else if (shape === "diamond") {
                        const points = [
                            [0, -responsiveSize],
                            [responsiveSize, 0],
                            [0, responsiveSize],
                            [-responsiveSize, 0]
                        ].map(p => p.join(",")).join(" ");
                        g.append("polygon")
                            .attr("points", points)
                            .attr("fill", modalityColors[d.modality])
                            .attr("stroke", "rgba(255, 255, 255, 0.4)")
                            .attr("stroke-width", strokeWidth)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                    }
                });

                // Cost indicator (pre-attentive color intensity encoding) with responsive sizing
                nodes.append("circle")
                    .attr("r", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return isMobile ? 3 : 4;
                    })
                    .attr("cx", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return responsiveSize + (isMobile ? 3 : 5);
                    })
                    .attr("cy", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return -responsiveSize - (isMobile ? 3 : 5);
                    })
                    .attr("fill", d => {
                        const intensity = d.cost / 100;
                        return `rgba(255, ${255 - intensity * 100}, ${255 - intensity * 100}, 0.9)`;
                    })
                    .attr("stroke", "white")
                    .attr("stroke-width", isMobile ? 0.8 : 1);

                // Cost level text with responsive sizing
                nodes.append("text")
                    .attr("x", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return responsiveSize + (isMobile ? 3 : 5);
                    })
                    .attr("y", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return -responsiveSize - (isMobile ? 3 : 5) + (isMobile ? 2 : 3);
                    })
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", isMobile ? "7px" : "8px")
                    .style("font-weight", "600")
                    .text(d => d.cost > 80 ? "$$$" : d.cost > 50 ? "$$" : "$");

                // Performance score indicator with responsive sizing
                nodes.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", isMobile ? "8px" : "10px")
                    .style("font-weight", "700")
                    .style("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                    .text(d => d.performance);

                // Availability status indicator (pre-attentive position encoding) with responsive sizing
                nodes.append("circle")
                    .attr("r", isMobile ? 2.5 : 3)
                    .attr("cx", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return -responsiveSize - (isMobile ? 3 : 5);
                    })
                    .attr("cy", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return -responsiveSize - (isMobile ? 3 : 5);
                    })
                    .attr("fill", d => {
                        if (d.availability === "Available") return "#2EC4B6";
                        if (d.availability === "Beta") return "#FF6B6B";
                        return "#FFA500";
                    })
                    .attr("stroke", "white")
                    .attr("stroke-width", isMobile ? 0.8 : 1);

                // Enhanced text labels with responsive positioning and overflow protection
                nodes.append("text")
                    .attr("x", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return Math.min(responsiveSize + (isMobile ? 6 : 8), isMobile ? 15 : 20);
                    })
                    .attr("y", isMobile ? 3 : 5)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "8px" : "10px")
                    .style("font-weight", "600")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text(d => {
                        const maxLength = isMobile ? 8 : 12;
                        return d.name.length > maxLength ? d.name.substring(0, maxLength - 2) + "..." : d.name;
                    });

                // Availability status indicator with responsive positioning
                nodes.append("text")
                    .attr("x", d => {
                        const responsiveSize = calculateNodeSize(d.size, width, height);
                        return Math.min(responsiveSize + (isMobile ? 6 : 8), isMobile ? 15 : 20);
                    })
                    .attr("y", isMobile ? 14 : 18)
                    .attr("fill", d => d.availability === "Available" ? "#2EC4B6" : d.availability.includes("Q") ? "#FFB700" : "#8E8E93")
                    .style("font-size", isMobile ? "6px" : "8px")
                    .style("font-weight", "500")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text(d => d.availability);

                // Enhanced legend with responsive positioning and consistent formatting
                const legendSpacing = isMobile ? 22 : 28;
                const legendStartY = isMobile ? 15 : 20;
                const legend = svg.selectAll(".legend").data(modalities).enter().append("g")
                    .attr("class", "legend interactive-node")
                    .attr("transform", (d, i) => `translate(${isMobile ? 15 : 20}, ${legendStartY + i * legendSpacing})`);

                legend.append("circle")
                    .attr("cx", isMobile ? 6 : 8)
                    .attr("cy", isMobile ? 6 : 8)
                    .attr("r", isMobile ? 6 : 8)
                    .style("fill", d => modalityColors[d])
                    .attr("stroke", "white")
                    .attr("stroke-width", isMobile ? 0.8 : 1);

                legend.append("text")
                    .attr("x", isMobile ? 20 : 25)
                    .attr("y", isMobile ? 7 : 9)
                    .attr("dy", ".2em")
                    .style("text-anchor", "start")
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "9px" : "11px")
                    .style("font-weight", "500")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text(d => d);

                legend.append("text")
                    .attr("x", isMobile ? 20 : 25)
                    .attr("y", isMobile ? 18 : 22)
                    .style("text-anchor", "start")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", isMobile ? "7px" : "9px")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text(d => {
                        const count = models.filter(m => m.modality === d).length;
                        return `${count} model${count > 1 ? 's' : ''}`;
                    });

                // Enhanced pre-attentive legend with responsive positioning
                const legendY = 30;
                const legendWidth = 160;
                const minLegendMargin = 30;
                const maxLegendX = width - legendWidth - minLegendMargin;
                const minLegendX = width * 0.7;
                const legendX = Math.max(minLegendX, Math.min(maxLegendX, width * 0.8)); // Enhanced responsive positioning

                // Shape legend with consistent formatting
                svg.append("text")
                    .attr("x", legendX)
                    .attr("y", legendY)
                    .attr("text-anchor", "start")
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "700")
                    .style("font-size", "14px")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("Modality Shapes");

                const shapeLegend = [
                    { shape: "circle", label: "Processing Components", color: "var(--color-processing)", description: "Data processing and computation" },
                    { shape: "rect", label: "Data Components", color: "var(--color-data)", description: "Input/output data and interfaces" },
                    { shape: "polygon", label: "Output Components", color: "var(--color-output)", description: "Generated results and responses" },
                    { shape: "ellipse", label: "Storage Components", color: "var(--color-storage)", description: "Data persistence and caching" },
                    { shape: "diamond", label: "Network Components", color: "var(--color-network)", description: "Communication and connectivity" }
                ];

                shapeLegend.forEach((item, i) => {
                    const y = legendY + 25 + i * 20;
                    const x = legendX;

                    if (item.shape === "circle") {
                        svg.append("circle")
                            .attr("cx", x + 8)
                            .attr("cy", y)
                            .attr("r", 6)
                            .attr("fill", item.color)
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (item.shape === "rect") {
                        svg.append("rect")
                            .attr("x", x + 2)
                            .attr("y", y - 6)
                            .attr("width", 12)
                            .attr("height", 12)
                            .attr("fill", item.color)
                            .attr("rx", 2)
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (item.shape === "polygon") {
                        const points = [
                            [x + 8, y - 6],
                            [x + 14, y + 3],
                            [x + 2, y + 3]
                        ].map(p => p.join(",")).join(" ");
                        svg.append("polygon")
                            .attr("points", points)
                            .attr("fill", item.color)
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (item.shape === "ellipse") {
                        svg.append("ellipse")
                            .attr("cx", x + 8)
                            .attr("cy", y)
                            .attr("rx", 8)
                            .attr("ry", 5)
                            .attr("fill", item.color)
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (item.shape === "diamond") {
                        const points = [
                            [x + 8, y - 6],
                            [x + 14, y],
                            [x + 8, y + 6],
                            [x + 2, y]
                        ].map(p => p.join(",")).join(" ");
                        svg.append("polygon")
                            .attr("points", points)
                            .attr("fill", item.color)
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    }

                    svg.append("text")
                        .attr("x", x + 25)
                        .attr("y", y + 3)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(item.label);
                });

                // Cost/Performance indicators legend with consistent formatting
                svg.append("text")
                    .attr("x", legendX)
                    .attr("y", legendY + 140)
                    .attr("text-anchor", "start")
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "700")
                    .style("font-size", "14px")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("Cost Indicators");

                const costLegend = [
                    { label: "High Cost (>80)", color: "#FF6B6B" },
                    { label: "Medium Cost (50-80)", color: "#FFB700" },
                    { label: "Low Cost (<50)", color: "#2EC4B6" }
                ];

                costLegend.forEach((item, i) => {
                    const y = legendY + 160 + (i * 18);
                    svg.append("circle")
                        .attr("cx", legendX + 8)
                        .attr("cy", y)
                        .attr("r", 3)
                        .attr("fill", item.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 1);
                    svg.append("text")
                        .attr("x", legendX + 20)
                        .attr("y", y + 4)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(item.label);
                });

                // Availability legend with consistent formatting
                const availabilityLegendY = legendY + 220;
                svg.append("text")
                    .attr("x", legendX)
                    .attr("y", availabilityLegendY)
                    .attr("text-anchor", "start")
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "700")
                    .style("font-size", "14px")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("Availability");

                const availability = [
                    { label: "Available", opacity: 1, color: "#2EC4B6" },
                    { label: "Beta", opacity: 0.85, color: "#FF6B6B" },
                    { label: "Planned", opacity: 0.65, color: "#FFA500" }
                ];

                availability.forEach((a, i) => {
                    const y = availabilityLegendY + 20 + i * 18;
                    svg.append("circle")
                        .attr("cx", legendX + 8)
                        .attr("cy", y)
                        .attr("r", 4)
                        .attr("fill", a.color)
                        .attr("opacity", a.opacity)
                        .attr("stroke", "white")
                        .attr("stroke-width", 1);
                    svg.append("text")
                        .attr("x", legendX + 20)
                        .attr("y", y + 4)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(a.label);
                });
            }

            function renderFineTuningViz() {
                const container = d3.select("#fine-tuning-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive design detection and adaptive margins for mathematical frameworks
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || bounds.width < 600;
                const isTablet = deviceType.type === 'tablet' || (bounds.width >= 600 && bounds.width < 1024);
                
                const margin = { 
                    top: isMobile ? 40 : 60, 
                    right: isMobile ? 20 : 60, 
                    bottom: isMobile ? 40 : 60, 
                    left: isMobile ? 20 : 60 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Add gradient definitions for sophisticated visual effects with consistent color palette
                const defs = svg.append("defs");
                const fullTuneGradient = defs.append("linearGradient").attr("id", "fullTuneGradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                fullTuneGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--color-alignment)").attr("stop-opacity", 0.8);
                fullTuneGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-blue-dark)").attr("stop-opacity", 0.4);

                const loraGradient = defs.append("linearGradient").attr("id", "loraGradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                loraGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--color-efficiency)").attr("stop-opacity", 0.8);
                loraGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-green-dark)").attr("stop-opacity", 0.4);

                const soraGradient = defs.append("linearGradient").attr("id", "soraGradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                soraGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--color-model)").attr("stop-opacity", 0.9);
                soraGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-purple-dark)").attr("stop-opacity", 0.5);

                // Responsive performance metrics data with enhanced mathematical frameworks
                const techniquePositions = isMobile ? [0.25, 0.5, 0.75] : [0.2, 0.5, 0.8];
                const techniques = [
                    {
                        name: "Full Fine-Tuning", x: width * techniquePositions[0], color: "var(--color-alignment)", gradient: "url(#fullTuneGradient)",
                        params: "100%", memory: "100%", speed: "1x", accuracy: "100%", efficiency: "Low",
                        tooltip: "<b>Full Fine-Tuning</b><br>Updates all model parameters for maximum performance. High computational cost but optimal accuracy for specialized tasks.",
                        mathFormula: "ΔW = W_new - W_original"
                    },
                    {
                        name: "LoRA", x: width * techniquePositions[1], color: "var(--color-efficiency)", gradient: "url(#loraGradient)",
                        params: "0.1%", memory: "15%", speed: "3x", accuracy: "95%", efficiency: "High",
                        tooltip: "<b>Low-Rank Adaptation (LoRA)</b><br>Parameter-efficient fine-tuning using low-rank matrices. Achieves 95% accuracy with 99% parameter reduction.",
                        mathFormula: "ΔW = A × B (rank r << d)"
                    },
                    {
                        name: "SoRA", x: width * techniquePositions[2], color: "var(--color-model)", gradient: "url(#soraGradient)",
                        params: "0.05%", memory: "8%", speed: "5x", accuracy: "98%", efficiency: "Breakthrough",
                        tooltip: "<b>Sparse Low-rank Adaptation (SoRA)</b><br>Combines LoRA efficiency with sparsity for breakthrough performance. 5x speedup with 98% accuracy.",
                        mathFormula: "ΔW = A × B × S",
                        sparsityPattern: "S: sparse mask",
                        performanceMetrics: { speedup: "5x", memory: "8%", sparsity: "95%" }
                    }
                ];

                // Responsive layer dimensions based on device type
                const numLayers = isMobile ? 6 : 8; 
                const layerHeight = height * 0.4 / numLayers; 
                const layerWidth = isMobile ? width * 0.18 : width * 0.15;

                techniques.forEach((technique, i) => {
                    const group = svg.append("g")
                        .attr("class", "interactive-node mathematical-technique")
                        .attr("data-technique", technique.name.toLowerCase().replace(/\s+/g, '-'))
                        .attr("transform", `translate(${technique.x - layerWidth / 2}, ${height * 0.1})`)
                        .on("mouseover", (e) => showTooltip(e, technique.tooltip))
                        .on("mouseout", hideTooltip);

                    // Title with consistent typography
                    svg.append("text")
                        .attr("x", technique.x)
                        .attr("y", 25)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-primary)")
                        .style("font-weight", "var(--font-semibold)")
                        .style("font-size", "var(--text-lg)")
                        .style("font-family", "var(--font-primary)")
                        .text(technique.name);

                    // Technique-specific layer rendering
                    if (technique.name === "Full Fine-Tuning") {
                        // All layers active
                        group.selectAll(".layer")
                            .data(d3.range(numLayers))
                            .enter()
                            .append("rect")
                            .attr("class", "layer")
                            .attr("y", d => d * (layerHeight + 2))
                            .attr("width", layerWidth)
                            .attr("height", layerHeight)
                            .attr("fill", technique.gradient)
                            .attr("stroke", "var(--secondary-border)")
                            .attr("stroke-width", 1);
                    } else if (technique.name === "LoRA") {
                        // Sparse adapter layers
                        group.selectAll(".layer")
                            .data(d3.range(numLayers))
                            .enter()
                            .append("rect")
                            .attr("class", "layer")
                            .attr("y", d => d * (layerHeight + 2))
                            .attr("width", layerWidth)
                            .attr("height", layerHeight)
                            .attr("fill", d => d % 3 === 0 ? technique.gradient : "var(--primary-border)")
                            .attr("stroke", "var(--secondary-border)")
                            .attr("stroke-width", 1)
                            .attr("opacity", d => d % 3 === 0 ? 1 : 0.3);
                    } else if (technique.name === "SoRA") {
                        // Enhanced ultra-sparse visualization with responsive mathematical framework and dynamic equation rendering
                        const sparseLayerPattern = isMobile ? [0, 2, 4] : isTablet ? [0, 2, 5, 8] : [0, 3, 6, 9]; // Adaptive sparsity pattern
                        
                        group.selectAll(".layer")
                            .data(d3.range(numLayers))
                            .enter()
                            .append("rect")
                            .attr("class", "layer sora-layer")
                            .attr("y", d => d * (layerHeight + 2))
                            .attr("width", layerWidth)
                            .attr("height", layerHeight)
                            .attr("fill", d => sparseLayerPattern.includes(d) ? technique.gradient : "var(--primary-border)")
                            .attr("stroke", "var(--secondary-border)")
                            .attr("stroke-width", 1)
                            .attr("opacity", d => sparseLayerPattern.includes(d) ? 1 : 0.15)
                            .style("transition", "all 0.3s ease");

                        // Enhanced dynamic mathematical notation for SoRA with responsive sizing and collision detection
                        const mathFontSize = isMobile ? "7px" : isTablet ? "9px" : "11px";
                        const mathY = isMobile ? -8 : -10;
                        
                        // Add background for mathematical notation readability with enhanced styling
                        if (!isMobile) {
                            group.append("rect")
                                .attr("class", "math-background")
                                .attr("x", layerWidth / 2 - 25)
                                .attr("y", mathY - 8)
                                .attr("width", 50)
                                .attr("height", 12)
                                .attr("fill", "var(--bg-color)")
                                .attr("opacity", 0.9)
                                .attr("rx", 3)
                                .style("filter", "drop-shadow(0 1px 3px rgba(0,0,0,0.2))");
                        }
                        
                        // Enhanced mathematical notation with interactive equation rendering
                        const mathText = group.append("text")
                            .attr("class", "sora-notation interactive-equation")
                            .attr("x", layerWidth / 2)
                            .attr("y", mathY)
                            .attr("text-anchor", "middle")
                            .attr("fill", "var(--accent-purple)")
                            .style("font-size", mathFontSize)
                            .style("font-family", "Roboto Mono, monospace")
                            .style("font-weight", "bold")
                            .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                            .style("cursor", "pointer")
                            .text(isMobile ? "ΔW=A·B·S" : isTablet ? "ΔW = A·B·S" : "ΔW = A·B·S");
                        
                        // Add interactive equation explanation on click
                        mathText.on("click", function(event) {
                            const equationTooltip = `<b>SoRA Mathematical Framework</b><br><br><b>Formula:</b> ΔW = A·B·S<br><br><b>Components:</b><br>• A: Low-rank matrix A (r × d)<br>• B: Low-rank matrix B (d × r)<br>• S: Sparse mask matrix (d × d)<br><br><b>Benefits:</b><br>• 5x faster than full fine-tuning<br>• 98% accuracy retention<br>• 95% parameter reduction<br>• Ultra-sparse activation pattern`;
                            showTooltip(event, equationTooltip);
                        });
                        
                        // Add hover effect for equation
                        mathText.on("mouseover", function() {
                            d3.select(this)
                                .style("font-size", isMobile ? "8px" : isTablet ? "10px" : "12px")
                                .style("fill", "var(--accent-cyan)")
                                .style("text-shadow", "0 2px 4px rgba(0,0,0,0.4)");
                        })
                        .on("mouseout", function() {
                            d3.select(this)
                                .style("font-size", mathFontSize)
                                .style("fill", "var(--accent-purple)")
                                .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)");
                        });

                        // Enhanced responsive sparsity mask indicators with adaptive positioning
                        if (!isMobile || (isMobile && width > 300)) {
                            const indicatorOffset = isMobile ? 8 : 12;
                            const indicatorRadius = isMobile ? 2 : 3;
                            
                            sparseLayerPattern.forEach((layerIndex, i) => {
                                const indicator = group.append("circle")
                                    .attr("class", "sparsity-indicator interactive-sparsity")
                                    .attr("cx", layerWidth + indicatorOffset)
                                    .attr("cy", layerIndex * (layerHeight + 2) + layerHeight / 2)
                                    .attr("r", indicatorRadius)
                                    .attr("fill", "var(--accent-green)")
                                    .style("opacity", 0.8)
                                    .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))")
                                    .style("cursor", "pointer");
                                
                                // Enhanced sparsity indicator animation with continuous pulse
                                const animateSparsity = () => {
                                    indicator
                                        .transition()
                                        .delay(i * 200)
                                        .duration(800)
                                        .attr("r", indicatorRadius * 1.5)
                                        .style("opacity", 1)
                                        .transition()
                                        .duration(800)
                                        .attr("r", indicatorRadius)
                                        .style("opacity", 0.8)
                                        .on("end", animateSparsity);
                                };
                                
                                // Start animation
                                animateSparsity();
                                
                                // Add interactive sparsity explanation
                                indicator.on("click", function(event) {
                                    const sparsityTooltip = `<b>Sparse Layer ${layerIndex + 1}</b><br><br><b>Sparsity Pattern:</b> Active layer in SoRA<br><b>Activation:</b> 95% sparse mask<br><b>Efficiency:</b> 5x speedup<br><b>Memory:</b> 8% of full fine-tuning<br><br><b>Mathematical:</b> S[${layerIndex}] = 1 (active)<br>Other layers: S[i] = 0 (inactive)`;
                                    showTooltip(event, sparsityTooltip);
                                });
                                
                                // Add hover effect for sparsity indicators
                                indicator.on("mouseover", function() {
                                    d3.select(this)
                                        .attr("r", indicatorRadius * 1.8)
                                        .style("opacity", 1)
                                        .style("fill", "var(--accent-cyan)")
                                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.4))");
                                })
                                .on("mouseout", function() {
                                    d3.select(this)
                                        .attr("r", indicatorRadius)
                                        .style("opacity", 0.8)
                                        .style("fill", "var(--accent-green)")
                                        .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))");
                                });
                            });

                            // Enhanced mathematical framework display with responsive positioning
                            if (technique.performanceMetrics) {
                                const metricsY = numLayers * (layerHeight + 2) + (isMobile ? 15 : 20);
                                const equationFontSize = isMobile ? "7px" : isTablet ? "8px" : "9px";
                                const metricsFontSize = isMobile ? "6px" : isTablet ? "7px" : "8px";
                                
                                // Add background for equation readability
                                if (!isMobile) {
                                    group.append("rect")
                                        .attr("class", "equation-background")
                                        .attr("x", layerWidth / 2 - 30)
                                        .attr("y", metricsY - 6)
                                        .attr("width", 60)
                                        .attr("height", 10)
                                        .attr("fill", "var(--bg-color)")
                                        .attr("opacity", 0.9)
                                        .attr("rx", 2);
                                }
                                
                                // Sparsity pattern equation with enhanced typography
                                group.append("text")
                                    .attr("class", "sora-equation")
                                    .attr("x", layerWidth / 2)
                                    .attr("y", metricsY)
                                    .attr("text-anchor", "middle")
                                    .attr("fill", "var(--text-primary)")
                                    .style("font-size", equationFontSize)
                                    .style("font-family", "Roboto Mono, monospace")
                                    .style("font-weight", "bold")
                                    .style("text-shadow", "0 1px 2px rgba(0,0,0,0.2)")
                                    .text(technique.sparsityPattern);

                                // Performance metrics display with responsive formatting
                                const metricsText = isMobile ? 
                                    `${technique.performanceMetrics.speedup}x • ${technique.performanceMetrics.sparsity}%` :
                                    `${technique.performanceMetrics.speedup} faster • ${technique.performanceMetrics.sparsity} sparse`;
                                    
                                group.append("text")
                                    .attr("class", "sora-metrics")
                                    .attr("x", layerWidth / 2)
                                    .attr("y", metricsY + (isMobile ? 10 : 15))
                                    .attr("text-anchor", "middle")
                                    .attr("fill", "var(--accent-green)")
                                    .style("font-size", metricsFontSize)
                                    .style("font-weight", "bold")
                                    .style("text-shadow", "0 1px 2px rgba(0,0,0,0.2)")
                                    .text(metricsText);
                            }
                        }
                    }

                    // Enhanced responsive performance metrics with adaptive positioning and formatting
                    const metricsY = height * (isMobile ? 0.7 : 0.65);
                    const metricsSpacing = isMobile ? 12 : 15;
                    const metricsFontSize = isMobile ? "8px" : isTablet ? "9px" : "10px";
                    
                    const metrics = [
                        { label: "Params", value: technique.params, y: metricsY },
                        { label: "Memory", value: technique.memory, y: metricsY + metricsSpacing },
                        { label: "Speed", value: technique.speed, y: metricsY + metricsSpacing * 2 },
                        { label: "Accuracy", value: technique.accuracy, y: metricsY + metricsSpacing * 3 }
                    ];

                    // Add background for metrics readability on mobile
                    if (isMobile && width > 250) {
                        svg.append("rect")
                            .attr("class", "metrics-background")
                            .attr("x", technique.x - 40)
                            .attr("y", metricsY - 8)
                            .attr("width", 80)
                            .attr("height", metricsSpacing * 4 + 8)
                            .attr("fill", "var(--bg-color)")
                            .attr("opacity", 0.9)
                            .attr("rx", 4)
                            .style("filter", "drop-shadow(0 1px 3px rgba(0,0,0,0.1))");
                    }

                    metrics.forEach((metric, index) => {
                        // Enhanced metric display with responsive formatting
                        const metricText = isMobile ? 
                            `${metric.label}: ${metric.value}` : 
                            `${metric.label}: ${metric.value}`;
                            
                        svg.append("text")
                            .attr("x", technique.x)
                            .attr("y", metric.y)
                            .attr("text-anchor", "middle")
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", metricsFontSize)
                            .style("font-family", "var(--font-primary)")
                            .style("font-weight", "var(--font-normal)")
                            .style("text-shadow", isMobile ? "0 1px 2px rgba(0,0,0,0.2)" : "none")
                            .text(metricText);
                            
                        // Add performance indicator for SoRA technique
                        if (technique.name === "SoRA" && !isMobile) {
                            const indicatorColor = index === 2 ? "var(--accent-green)" : // Speed
                                                 index === 3 ? "var(--accent-blue)" : // Accuracy
                                                 "var(--text-secondary)";
                            svg.append("circle")
                                .attr("cx", technique.x - 35)
                                .attr("cy", metric.y - 3)
                                .attr("r", 2)
                                .attr("fill", indicatorColor)
                                .style("opacity", 0.8);
                        }
                    });

                    // Efficiency indicator with consistent styling
                    svg.append("text")
                        .attr("x", technique.x)
                        .attr("y", height * 0.9)
                        .attr("text-anchor", "middle")
                        .attr("fill", technique.color)
                        .style("font-size", "var(--text-md)")
                        .style("font-weight", "var(--font-semibold)")
                        .style("font-family", "var(--font-primary)")
                        .text(technique.efficiency);
                });

                // Enhanced responsive mathematical framework explanation
                const mathExplanation = isMobile ? 
                    "SoRA: 5x faster, 98% accuracy" : 
                    "SoRA: ΔW = A·B·S where S is sparse mask, achieving 5x speedup with 98% accuracy";
                    
                svg.append("text")
                    .attr("class", "mathematical-framework-explanation")
                    .attr("x", width / 2)
                    .attr("y", height * 0.95)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", isMobile ? "10px" : "var(--text-sm)")
                    .style("font-family", "var(--font-mono)")
                    .style("font-weight", "var(--font-medium)")
                    .text(mathExplanation);

                // Add responsive resize handler for mathematical framework updates
                function handleFineTuningResize() {
                    if (container.node()) {
                        const newBounds = container.node().getBoundingClientRect();
                        if (newBounds.width > 0 && Math.abs(newBounds.width - bounds.width) > 50) {
                            renderFineTuningViz(); // Re-render with new dimensions
                        }
                    }
                }

                // Debounced resize handler for performance optimization
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(handleFineTuningResize, 300);
                });
            }

            function renderVectorDbVizAdvanced() {
                const container = d3.select("#vector-db-viz-advanced"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 50, right: 30, bottom: 50, left: 60 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
                const providers = [
                    { name: "Pinecone", x: 0.25, y: 0.8, type: "Hosted", details: "Fully managed, high-performance, and easy to scale." }, { name: "Weaviate", x: 0.3, y: 0.75, type: "Hosted", details: "Offers both managed services and open-source options with GraphQL API." },
                    { name: "Milvus", x: 0.7, y: 0.7, type: "Self-Hosted", details: "Highly scalable, open-source, designed for massive datasets." }, { name: "ChromaDB", x: 0.8, y: 0.3, type: "Self-Hosted", details: "In-process and open-source, great for rapid development and smaller scale." },
                ];
                const xScale = d3.scaleLinear().domain([0, 1]).range([0, width]);
                const yScale = d3.scaleLinear().domain([0, 1]).range([height, 0]);
                svg.append("line").attr("x1", 0).attr("y1", height / 2).attr("x2", width).attr("y2", height / 2).attr("stroke", "var(--secondary-border)").attr("stroke-dasharray", "4");
                svg.append("line").attr("x1", width / 2).attr("y1", 0).attr("x2", width / 2).attr("y2", height).attr("stroke", "var(--secondary-border)").attr("stroke-dasharray", "4");
                svg.append("text").attr("text-anchor", "end").attr("x", width).attr("y", height + 40).attr("fill", "var(--text-secondary)").text("More Control & Open-Source →");
                svg.append("text").attr("text-anchor", "start").attr("x", -50).attr("y", -10).attr("fill", "var(--text-secondary)").text("↑ Enterprise Scale & Performance");
                svg.append("text").attr("x", width * 0.75).attr("y", 20).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "bold").text("Self-Hosted / Open-Source");
                svg.append("text").attr("x", width * 0.25).attr("y", 20).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "bold").text("Hosted / Managed");
                const nodes = svg.selectAll(".provider-node").data(providers).enter().append("g").attr("class", "provider-node interactive-node").attr("transform", d => `translate(${xScale(d.x)}, ${yScale(d.y)})`).on("mouseover", (event, d) => showTooltip(event, `<b>${d.name}</b><br>${d.details}`)).on("mouseout", hideTooltip);
                nodes.append("circle").attr("r", 8).attr("fill", d => d.type === "Hosted" ? "var(--accent-purple)" : "var(--accent-green)");
                nodes.append("text").attr("x", 12).attr("y", 5).attr("fill", "var(--text-primary)").text(d => d.name);
            }

            function renderAdvancedRagViz() {
                const container = d3.select("#advanced-rag-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 40, right: 20, bottom: 20, left: 20 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
                const patterns = ["Standard RAG", "Self-Corrective RAG", "Agentic RAG"];
                const patternWidth = width / patterns.length;
                const nodeRadius = 24;
                const nodeInfo = {
                    "T": { label: "T", tooltip: "Trigger: A user-submitted prompt initiates the process." }, "R": { label: "R", tooltip: "Retrieve: Fetch relevant documents from a knowledge base." },
                    "G": { label: "G", tooltip: "Generate: Synthesize an answer based on the retrieved context." }, "O": { label: "O", tooltip: "Output: The final answer is delivered to the user." },
                    "C": { label: "C", tooltip: "Critique: Evaluate the generated answer for correctness and relevance against the source documents." }, "Ref": { label: "Ref", tooltip: "Refine: Re-generate the answer based on the critique." },
                    "AT": { label: "T", tooltip: "Trigger: An automated system event or a met condition initiates the agent." }, "Agent": { label: "Agent", tooltip: "Orchestrator that analyzes the trigger and decides the next action." },
                    "Rewrite": { label: "Rewrite", tooltip: "The agent rewrites the initial query for better retrieval accuracy." }
                };
                patterns.forEach((pattern, i) => {
                    const g = svg.append("g").attr("transform", `translate(${i * patternWidth}, 0)`);
                    g.append("text").attr("x", patternWidth / 2).attr("y", 0).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "bold").text(pattern);
                    g.append("rect").attr("x", 5).attr("y", 20).attr("width", patternWidth - 10).attr("height", height - 40).attr("fill", "none").attr("stroke", "var(--secondary-border)").attr("stroke-dasharray", "2,2");
                    let nodesData, linksData;
                    const yCenter = height / 2.2;
                    if (i === 0) {
                        nodesData = [{ ...nodeInfo.T, x: patternWidth * 0.15, y: yCenter }, { ...nodeInfo.R, x: patternWidth * 0.4, y: yCenter }, { ...nodeInfo.G, x: patternWidth * 0.65, y: yCenter }, { ...nodeInfo.O, x: patternWidth * 0.9, y: yCenter }];
                        linksData = [{ source: nodesData[0], target: nodesData[1] }, { source: nodesData[1], target: nodesData[2] }, { source: nodesData[2], target: nodesData[3] }];
                    } else if (i === 1) {
                        nodesData = [{ ...nodeInfo.T, x: patternWidth * 0.1, y: yCenter }, { ...nodeInfo.R, x: patternWidth * 0.3, y: yCenter }, { ...nodeInfo.G, x: patternWidth * 0.5, y: yCenter }, { ...nodeInfo.C, x: patternWidth * 0.7, y: yCenter - 60 }, { ...nodeInfo.Ref, x: patternWidth * 0.7, y: yCenter + 60 }, { ...nodeInfo.O, x: patternWidth * 0.9, y: yCenter }];
                        linksData = [{ source: nodesData[0], target: nodesData[1] }, { source: nodesData[1], target: nodesData[2] }, { source: nodesData[2], target: nodesData[3] }, { source: nodesData[3], target: nodesData[4] }, { source: nodesData[4], target: nodesData[2], curve: true }, { source: nodesData[2], target: nodesData[5] }];
                    } else {
                        nodesData = [{ ...nodeInfo.AT, x: patternWidth * 0.1, y: yCenter }, { ...nodeInfo.Agent, x: patternWidth * 0.35, y: yCenter }, { ...nodeInfo.Rewrite, x: patternWidth * 0.6, y: yCenter - 60 }, { ...nodeInfo.R, x: patternWidth * 0.6, y: yCenter + 60 }, { ...nodeInfo.O, x: patternWidth * 0.9, y: yCenter }];
                        linksData = [{ source: nodesData[0], target: nodesData[1] }, { source: nodesData[1], target: nodesData[2] }, { source: nodesData[1], target: nodesData[3] }, { source: nodesData[2], target: nodesData[3], curve: true, note: "Rewritten query is used for retrieval" }, { source: nodesData[3], target: nodesData[1], curve: true, note: "Retrieved context returns to agent for synthesis" }, { source: nodesData[1], target: nodesData[4] }];
                    }
                    arrowMarker(svg, `arrow-rag-${i}`, "var(--accent-purple)");
                    g.append("g").selectAll("path").data(linksData).enter().append("path").attr("stroke", "var(--accent-purple)").attr("stroke-width", 1.5).attr("fill", "none").attr("marker-end", `url(#arrow-rag-${i})`).attr("d", d => {
                        const dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = d.curve ? Math.sqrt(dx * dx + dy * dy) * 1.5 : 0;
                        const sweep = d.source.y > d.target.y ? 0 : 1;
                        return d.curve ? `M${d.source.x},${d.source.y} A${dr},${dr} 0 0,${sweep} ${d.target.x},${d.target.y}` : `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                    });
                    const node = g.append("g").selectAll("g").data(nodesData).enter().append("g").attr("class", "interactive-node").attr("transform", d => `translate(${d.x},${d.y})`).on("mouseover", (e, d) => showTooltip(e, d.tooltip)).on("mouseout", hideTooltip);
                    node.append("circle").attr("r", nodeRadius).attr("fill", d => d.label === "T" ? "var(--accent-cyan)" : "var(--accent-purple)");
                    node.append("text").text(d => d.label).attr("text-anchor", "middle").attr("dy", 5).attr("fill", "var(--bg-color)").style("font-size", "14px").style("font-weight", "bold");
                });
            }

            /** Renders the Model Serving & Inference Optimization visualization with advanced performance cues and Tableau Jedi Master techniques. */
            function renderInferenceOptimizationViz() {
                const container = d3.select("#inference-optimization-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 30 : isTablet ? 35 : 40, 
                    right: isMobile ? 30 : isTablet ? 35 : 40, 
                    bottom: isMobile ? 50 : isTablet ? 55 : 60, 
                    left: isMobile ? 60 : isTablet ? 70 : 80 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers for performance flow
                arrowMarker(svg, "arrow-perf-flow", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-latency", "var(--accent-green)");
                arrowMarker(svg, "arrow-throughput", "var(--accent-blue)");

                // Enhanced data with comprehensive performance metrics and latency cues
                const data = [
                    {
                        tech: "Naive",
                        latency: 500,
                        throughput: 10,
                        cost: 100,
                        efficiency: 20,
                        memory: 8,
                        accuracy: 100,
                        icon: "🐌",
                        color: "var(--accent-blue)",
                        gradient: "naive-grad",
                        details: "Each request processed individually. Simple but inefficient with high latency and low throughput.",
                        improvements: ["Sequential processing", "No optimization", "High resource usage"],
                        latencyCues: { color: "#FF6B6B", intensity: "high", trend: "poor" },
                        performanceProfile: { cpu: 90, gpu: 30, memory: 85, network: 20 },
                        bottleneckType: "memory",
                        scalingCapability: "none",
                        optimizationLevel: "none",
                        monitoringLevel: "basic",
                        latencyBreakdown: { preprocessing: 50, inference: 400, postprocessing: 50 },
                        performanceIndicators: { p50: 500, p95: 600, p99: 800, max: 1000 }
                    },
                    {
                        tech: "Batching",
                        latency: 250,
                        throughput: 40,
                        cost: 60,
                        efficiency: 50,
                        memory: 6,
                        accuracy: 99,
                        icon: "📦",
                        color: "var(--accent-green)",
                        gradient: "batching-grad",
                        details: "Grouping multiple requests together to improve GPU utilization and reduce overhead.",
                        improvements: ["Request batching", "GPU utilization", "Reduced overhead"],
                        latencyCues: { color: "#FFB700", intensity: "medium", trend: "improving" },
                        performanceProfile: { cpu: 70, gpu: 60, memory: 70, network: 40 },
                        bottleneckType: "compute",
                        scalingCapability: "vertical",
                        optimizationLevel: "basic",
                        monitoringLevel: "standard",
                        latencyBreakdown: { preprocessing: 30, inference: 180, postprocessing: 40 },
                        performanceIndicators: { p50: 250, p95: 300, p99: 350, max: 400 }
                    },
                    {
                        tech: "Quantization",
                        latency: 150,
                        throughput: 70,
                        cost: 40,
                        efficiency: 75,
                        memory: 3,
                        accuracy: 98,
                        icon: "⚡",
                        color: "var(--accent-cyan)",
                        gradient: "quantization-grad",
                        details: "Reducing model precision (e.g., FP16 to INT8) for faster computation with minimal accuracy loss.",
                        improvements: ["Model compression", "Faster inference", "Memory optimization"],
                        latencyCues: { color: "#2EC4B6", intensity: "low", trend: "good" },
                        performanceProfile: { cpu: 50, gpu: 80, memory: 40, network: 60 },
                        bottleneckType: "network",
                        scalingCapability: "horizontal",
                        optimizationLevel: "advanced",
                        monitoringLevel: "comprehensive",
                        latencyBreakdown: { preprocessing: 20, inference: 100, postprocessing: 30 },
                        performanceIndicators: { p50: 150, p95: 180, p99: 200, max: 250 }
                    },
                    {
                        tech: "HW Acceleration",
                        latency: 50,
                        throughput: 100,
                        cost: 20,
                        efficiency: 95,
                        memory: 2,
                        accuracy: 97,
                        icon: "🚀",
                        color: "var(--accent-purple)",
                        gradient: "hw-accel-grad",
                        details: "Using specialized hardware like GPUs or TPUs with optimized kernels (e.g., FlashAttention).",
                        improvements: ["Specialized hardware", "Optimized kernels", "Maximum performance"],
                        latencyCues: { color: "#2EC4B6", intensity: "minimal", trend: "excellent" },
                        performanceProfile: { cpu: 20, gpu: 95, memory: 25, network: 80 },
                        bottleneckType: "none",
                        scalingCapability: "elastic",
                        optimizationLevel: "enterprise",
                        monitoringLevel: "real-time",
                        latencyBreakdown: { preprocessing: 5, inference: 35, postprocessing: 10 },
                        performanceIndicators: { p50: 50, p95: 60, p99: 70, max: 80 }
                    }
                ];
                // Create advanced gradient definitions with performance-based styling
                const defs = svg.append("defs");

                // Enhanced gradients with performance-based color intensity
                const gradientConfigs = [
                    { id: "naive-grad", colors: ["#FF6B6B", "#CC5555"], direction: "vertical" },
                    { id: "batching-grad", colors: ["#FFB700", "#E09800"], direction: "diagonal" },
                    { id: "quantization-grad", colors: ["#2EC4B6", "#1DA9A0"], direction: "radial" },
                    { id: "hw-accel-grad", colors: ["#8338EC", "#6D2BCA"], direction: "vertical" }
                ];

                gradientConfigs.forEach(config => {
                    if (config.direction === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", config.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", config.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", config.colors[1]).attr("stop-opacity", 0.6);
                    } else {
                        const gradient = defs.append("linearGradient").attr("id", config.id);
                        if (config.direction === "vertical") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                        } else if (config.direction === "diagonal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                        }
                        gradient.append("stop").attr("offset", "0%").attr("stop-color", config.colors[0]).attr("stop-opacity", 0.9);
                        gradient.append("stop").attr("offset", "100%").attr("stop-color", config.colors[1]).attr("stop-opacity", 0.6);
                    }
                });

                // Add performance flow gradients for animated effects
                const flowGradients = [
                    { id: "latency-flow", colors: ["#FF6B6B", "#2EC4B6"] },
                    { id: "throughput-flow", colors: ["#3A86FF", "#00A6FB"] },
                    { id: "efficiency-flow", colors: ["#FFB700", "#8338EC"] }
                ];

                flowGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.8);
                    gradient.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 1.0);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.8);
                });

                // Responsive sizing calculation functions
                const calculateBarWidth = (containerWidth, containerHeight) => {
                    const baseWidth = 60;
                    const scaleFactor = Math.min(containerWidth / 800, containerHeight / 600, 1.2);
                    return Math.max(baseWidth * scaleFactor, baseWidth * 0.7);
                };

                const calculateFontSize = (baseSize, containerWidth) => {
                    const scaleFactor = Math.min(containerWidth / 800, 1.2);
                    return Math.max(baseSize * scaleFactor, baseSize * 0.8);
                };

                // Enhanced scales with responsive spacing
                const xScale = d3.scaleBand()
                    .domain(data.map(d => d.tech))
                    .range([0, width])
                    .padding(isMobile ? 0.4 : isTablet ? 0.35 : 0.3);

                const yScale = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.latency)])
                    .range([height, 0])
                    .nice();

                // Create responsive performance indicators scale
                const perfScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, isMobile ? 15 : 20]);

                // Enhanced axes with responsive styling
                const xAxis = svg.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(xScale).tickSize(0));

                xAxis.selectAll("text")
                    .attr("class", "text-secondary")
                    .style("font-size", calculateFontSize(12, width) + "px")
                    .style("font-weight", "500");

                xAxis.selectAll("path, line")
                    .attr("stroke", "var(--secondary-border)")
                    .attr("stroke-width", isMobile ? 0.8 : 1);

                const yAxis = svg.append("g")
                    .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(d => `${d}ms`));

                yAxis.selectAll("text")
                    .attr("class", "text-secondary")
                    .style("font-size", calculateFontSize(11, width) + "px");

                yAxis.selectAll("path")
                    .attr("stroke", "var(--secondary-border)")
                    .attr("stroke-width", isMobile ? 0.8 : 1);

                yAxis.selectAll("line")
                    .attr("stroke", "var(--primary-border)")
                    .attr("stroke-opacity", 0.3)
                    .attr("stroke-dasharray", "2,2");

                // Y-axis label with responsive positioning
                svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -margin.left + (isMobile ? 20 : 25))
                    .attr("x", -height / 2)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", calculateFontSize(14, width) + "px")
                    .style("font-weight", "600")
                    .text("Latency (ms) ↓");

                // Create bars with enhanced visual storytelling and performance cues
                const bars = svg.selectAll(".bar")
                    .data(data)
                    .enter()
                    .append("g")
                    .attr("class", "bar-group interactive-node")
                    .attr("transform", d => `translate(${xScale(d.tech)}, 0)`);

                // Add latency cue background indicators with bottleneck type encoding
                bars.append("rect")
                    .attr("class", "latency-cue-bg")
                    .attr("x", -5)
                    .attr("y", 0)
                    .attr("width", xScale.bandwidth() + 10)
                    .attr("height", height)
                    .attr("fill", d => d.latencyCues.color)
                    .attr("opacity", 0.1)
                    .attr("rx", 6);

                // Add bottleneck type indicators (small colored rectangles)
                bars.append("rect")
                    .attr("class", "bottleneck-indicator")
                    .attr("x", xScale.bandwidth() - 8)
                    .attr("y", 5)
                    .attr("width", 6)
                    .attr("height", 6)
                    .attr("fill", d => {
                        const colors = {
                            "memory": "#FF6B6B",
                            "compute": "#FFB700",
                            "network": "#2EC4B6",
                            "none": "#10B981"
                        };
                        return colors[d.bottleneckType] || "#666";
                    })
                    .attr("rx", 1)
                    .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                // Add scaling capability indicators (small shapes)
                bars.append("path")
                    .attr("class", "scaling-indicator")
                    .attr("d", d => {
                        const x = xScale.bandwidth() - 8;
                        const y = 15;
                        const shapes = {
                            "none": `M${x},${y} L${x + 6},${y} L${x + 3},${y + 6} Z`,
                            "vertical": `M${x},${y} L${x + 6},${y} L${x + 6},${y + 6} L${x},${y + 6} Z`,
                            "horizontal": `M${x},${y} L${x + 6},${y} L${x + 6},${y + 6} L${x},${y + 6} Z`,
                            "elastic": `M${x + 3},${y} L${x + 6},${y + 3} L${x + 3},${y + 6} L${x},${y + 3} Z`
                        };
                        return shapes[d.scalingCapability] || shapes["none"];
                    })
                    .attr("fill", d => {
                        const colors = {
                            "none": "#666",
                            "vertical": "#FFB700",
                            "horizontal": "#2EC4B6",
                            "elastic": "#10B981"
                        };
                        return colors[d.scalingCapability] || "#666";
                    })
                    .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                // Add optimization level indicators (small circles with different sizes)
                bars.append("circle")
                    .attr("class", "optimization-indicator")
                    .attr("cx", xScale.bandwidth() - 8)
                    .attr("cy", 25)
                    .attr("r", d => {
                        const sizes = {
                            "none": 2,
                            "basic": 3,
                            "advanced": 4,
                            "enterprise": 5
                        };
                        return sizes[d.optimizationLevel] || 2;
                    })
                    .attr("fill", d => {
                        const colors = {
                            "none": "#666",
                            "basic": "#FFB700",
                            "advanced": "#2EC4B6",
                            "enterprise": "#10B981"
                        };
                        return colors[d.optimizationLevel] || "#666";
                    })
                    .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                // Main performance bars with enhanced gradients
                bars.append("rect")
                    .attr("class", "main-bar")
                    .attr("x", 0)
                    .attr("y", d => yScale(d.latency))
                    .attr("width", xScale.bandwidth())
                    .attr("height", d => height - yScale(d.latency))
                    .attr("fill", d => `url(#${d.gradient})`)
                    .attr("rx", 4)
                    .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))")
                    .on("mouseover", function (event, d) {
                        const perfProfile = d.performanceProfile;
                        const breakdown = d.latencyBreakdown;
                        const indicators = d.performanceIndicators;
                        showTooltip(event, `<b>${d.tech} Optimization</b><br>${d.details}<br><br><b>Performance Metrics:</b><br>• Latency: ${d.latency}ms (${d.latencyCues.trend})<br>• Throughput: ${d.throughput} req/s<br>• Cost: $${d.cost}/hour<br>• Efficiency: ${d.efficiency}%<br>• Memory: ${d.memory}GB<br>• Accuracy: ${d.accuracy}%<br><br><b>Resource Utilization:</b><br>• CPU: ${perfProfile.cpu}%<br>• GPU: ${perfProfile.gpu}%<br>• Memory: ${perfProfile.memory}%<br>• Network: ${perfProfile.network}%<br><br><b>Latency Breakdown:</b><br>• Preprocessing: ${breakdown.preprocessing}ms<br>• Inference: ${breakdown.inference}ms<br>• Postprocessing: ${breakdown.postprocessing}ms<br><br><b>Performance Indicators:</b><br>• P50: ${indicators.p50}ms<br>• P95: ${indicators.p95}ms<br>• P99: ${indicators.p99}ms<br>• Max: ${indicators.max}ms<br><br><b>Architecture:</b><br>• Bottleneck: ${d.bottleneckType}<br>• Scaling: ${d.scalingCapability}<br>• Optimization: ${d.optimizationLevel}<br>• Monitoring: ${d.monitoringLevel}`);

                        // Highlight this bar and dim others
                        svg.selectAll(".main-bar").style("opacity", 0.3);
                        d3.select(this).style("opacity", 1.0);

                        // Show performance profile indicators
                        svg.selectAll(".performance-indicator").style("opacity", 0.2);
                        svg.selectAll(`.perf-${data.indexOf(d)}`).style("opacity", 1.0);
                    })
                    .on("mouseout", function () {
                        hideTooltip();
                        svg.selectAll(".main-bar").style("opacity", 1.0);
                        svg.selectAll(".performance-indicator").style("opacity", 0.6);
                    });

                // Add performance profile indicators on the right side of each bar
                bars.each(function (d, i) {
                    const barGroup = d3.select(this);
                    const perfProfile = d.performanceProfile;
                    const indicatorX = xScale.bandwidth() + 5;

                    // CPU indicator
                    barGroup.append("rect")
                        .attr("class", `performance-indicator perf-${i}`)
                        .attr("x", indicatorX)
                        .attr("y", 10)
                        .attr("width", 3)
                        .attr("height", perfProfile.cpu * 0.8)
                        .attr("fill", "#FF6B6B")
                        .attr("opacity", 0.6);

                    // GPU indicator
                    barGroup.append("rect")
                        .attr("class", `performance-indicator perf-${i}`)
                        .attr("x", indicatorX + 5)
                        .attr("y", 10)
                        .attr("width", 3)
                        .attr("height", perfProfile.gpu * 0.8)
                        .attr("fill", "#3A86FF")
                        .attr("opacity", 0.6);

                    // Memory indicator
                    barGroup.append("rect")
                        .attr("class", `performance-indicator perf-${i}`)
                        .attr("x", indicatorX + 10)
                        .attr("y", 10)
                        .attr("width", 3)
                        .attr("height", perfProfile.memory * 0.8)
                        .attr("fill", "#FFB700")
                        .attr("opacity", 0.6);

                    // Network indicator
                    barGroup.append("rect")
                        .attr("class", `performance-indicator perf-${i}`)
                        .attr("x", indicatorX + 15)
                        .attr("y", 10)
                        .attr("width", 3)
                        .attr("height", perfProfile.network * 0.8)
                        .attr("fill", "#2EC4B6")
                        .attr("opacity", 0.6);

                    // Add latency breakdown visualization (stacked bars)
                    const breakdownX = indicatorX + 25;
                    const breakdownY = 10;
                    const breakdownHeight = 60;
                    const breakdownWidth = 8;

                    // Preprocessing latency
                    barGroup.append("rect")
                        .attr("class", `latency-breakdown perf-${i}`)
                        .attr("x", breakdownX)
                        .attr("y", breakdownY)
                        .attr("width", breakdownWidth)
                        .attr("height", (d.latencyBreakdown.preprocessing / d.latency) * breakdownHeight)
                        .attr("fill", "#FF6B6B")
                        .attr("opacity", 0.7)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                    // Inference latency
                    barGroup.append("rect")
                        .attr("class", `latency-breakdown perf-${i}`)
                        .attr("x", breakdownX)
                        .attr("y", breakdownY + (d.latencyBreakdown.preprocessing / d.latency) * breakdownHeight)
                        .attr("width", breakdownWidth)
                        .attr("height", (d.latencyBreakdown.inference / d.latency) * breakdownHeight)
                        .attr("fill", "#3A86FF")
                        .attr("opacity", 0.7)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                    // Postprocessing latency
                    barGroup.append("rect")
                        .attr("class", `latency-breakdown perf-${i}`)
                        .attr("x", breakdownX)
                        .attr("y", breakdownY + ((d.latencyBreakdown.preprocessing + d.latencyBreakdown.inference) / d.latency) * breakdownHeight)
                        .attr("width", breakdownWidth)
                        .attr("height", (d.latencyBreakdown.postprocessing / d.latency) * breakdownHeight)
                        .attr("fill", "#2EC4B6")
                        .attr("opacity", 0.7)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                    // Add performance indicators (P50, P95, P99, Max)
                    const perfIndicators = d.performanceIndicators;
                    const perfX = breakdownX + 15;
                    const perfY = breakdownY;

                    // P50 indicator
                    barGroup.append("circle")
                        .attr("class", `perf-indicator perf-${i}`)
                        .attr("cx", perfX)
                        .attr("cy", perfY + 10)
                        .attr("r", 2)
                        .attr("fill", "#10B981")
                        .attr("opacity", 0.8);

                    // P95 indicator
                    barGroup.append("circle")
                        .attr("class", `perf-indicator perf-${i}`)
                        .attr("cx", perfX + 8)
                        .attr("cy", perfY + 20)
                        .attr("r", 2)
                        .attr("fill", "#FFB700")
                        .attr("opacity", 0.8);

                    // P99 indicator
                    barGroup.append("circle")
                        .attr("class", `perf-indicator perf-${i}`)
                        .attr("cx", perfX + 16)
                        .attr("cy", perfY + 30)
                        .attr("r", 2)
                        .attr("fill", "#FF6B6B")
                        .attr("opacity", 0.8);

                    // Max indicator
                    barGroup.append("circle")
                        .attr("class", `perf-indicator perf-${i}`)
                        .attr("cx", perfX + 24)
                        .attr("cy", perfY + 40)
                        .attr("r", 2)
                        .attr("fill", "#EF4444")
                        .attr("opacity", 0.8);
                });

                // Add technology icons
                bars.append("text")
                    .attr("x", xScale.bandwidth() / 2)
                    .attr("y", d => yScale(d.latency) - 10)
                    .attr("text-anchor", "middle")
                    .style("font-size", "24px")
                    .text(d => d.icon);

                // Add performance metrics labels
                bars.append("text")
                    .attr("x", xScale.bandwidth() / 2)
                    .attr("y", d => yScale(d.latency) + 20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text(d => `${d.latency}ms`);

                // Add efficiency percentage
                bars.append("text")
                    .attr("x", xScale.bandwidth() / 2)
                    .attr("y", d => yScale(d.latency) + 35)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", "9px")
                    .style("opacity", 0.8)
                    .text(d => `${d.efficiency}% eff`);

                // Add enhanced animated performance flow indicators with multiple metrics
                data.forEach((d, i) => {
                    if (i < data.length - 1) {
                        const currentX = xScale(d.tech) + xScale.bandwidth();
                        const nextX = xScale(data[i + 1].tech);
                        const midY = height / 2;

                        // Latency improvement flow
                        const latencyArrow = svg.append("path")
                            .attr("d", `M ${currentX} ${midY - 20} Q ${(currentX + nextX) / 2} ${midY - 50} ${nextX} ${midY - 20}`)
                            .attr("stroke", "url(#latency-flow)")
                            .attr("fill", "none")
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.8)
                            .attr("marker-end", "url(#arrow-latency)");

                        // Throughput improvement flow
                        const throughputArrow = svg.append("path")
                            .attr("d", `M ${currentX} ${midY} Q ${(currentX + nextX) / 2} ${midY - 30} ${nextX} ${midY}`)
                            .attr("stroke", "url(#throughput-flow)")
                            .attr("fill", "none")
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.8)
                            .attr("marker-end", "url(#arrow-throughput)");

                        // Efficiency improvement flow
                        const efficiencyArrow = svg.append("path")
                            .attr("d", `M ${currentX} ${midY + 20} Q ${(currentX + nextX) / 2} ${midY - 10} ${nextX} ${midY + 20}`)
                            .attr("stroke", "url(#efficiency-flow)")
                            .attr("fill", "none")
                            .attr("stroke-width", 3)
                            .attr("opacity", 0.8)
                            .attr("marker-end", "url(#arrow-perf-flow)");

                        // Animate the improvement flows with staggered timing
                        [latencyArrow, throughputArrow, efficiencyArrow].forEach((arrow, arrowIndex) => {
                            const pathLength = arrow.node().getTotalLength();
                            arrow.attr("stroke-dasharray", `${pathLength} ${pathLength}`)
                                .attr("stroke-dashoffset", pathLength)
                                .transition()
                                .duration(2500)
                                .delay(i * 600 + arrowIndex * 200)
                                .attr("stroke-dashoffset", 0);
                        });

                        // Enhanced improvement metrics display
                        const improvementMetrics = [
                            {
                                label: "Latency",
                                value: `${Math.round((d.latency - data[i + 1].latency) / d.latency * 100)}% faster`,
                                y: midY - 60,
                                color: "#2EC4B6"
                            },
                            {
                                label: "Throughput",
                                value: `${Math.round((data[i + 1].throughput - d.throughput) / d.throughput * 100)}% increase`,
                                y: midY - 40,
                                color: "#3A86FF"
                            },
                            {
                                label: "Efficiency",
                                value: `${Math.round((data[i + 1].efficiency - d.efficiency) / d.efficiency * 100)}% improvement`,
                                y: midY - 20,
                                color: "#8338EC"
                            }
                        ];

                        improvementMetrics.forEach(metric => {
                            svg.append("text")
                                .attr("x", (currentX + nextX) / 2)
                                .attr("y", metric.y)
                                .attr("text-anchor", "middle")
                                .attr("fill", metric.color)
                                .style("font-size", "9px")
                                .style("font-weight", "bold")
                                .text(metric.value);
                        });
                    }
                });

                // Add comprehensive performance dashboard at the bottom
                const dashboard = svg.append("g").attr("class", "performance-dashboard").attr("transform", `translate(0, ${height + 20})`);

                // Dashboard background
                dashboard.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", width)
                    .attr("height", 80)
                    .attr("fill", "rgba(27, 38, 59, 0.8)")
                    .attr("stroke", "var(--primary-border)")
                    .attr("rx", 8)
                    .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                // Dashboard title
                dashboard.append("text")
                    .attr("x", 10)
                    .attr("y", 15)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Model Serving Performance Analysis");

                // Calculate aggregate performance metrics
                const totalLatencyReduction = ((data[0].latency - data[data.length - 1].latency) / data[0].latency * 100);
                const totalThroughputIncrease = ((data[data.length - 1].throughput - data[0].throughput) / data[0].throughput * 100);
                const totalEfficiencyGain = ((data[data.length - 1].efficiency - data[0].efficiency) / data[0].efficiency * 100);
                const totalCostReduction = ((data[0].cost - data[data.length - 1].cost) / data[0].cost * 100);

                // Display aggregate metrics
                const metrics = [
                    { label: "Latency Reduction", value: `${Math.round(totalLatencyReduction)}%`, color: "#2EC4B6", x: 10, y: 35 },
                    { label: "Throughput Increase", value: `${Math.round(totalThroughputIncrease)}%`, color: "#3A86FF", x: 10, y: 50 },
                    { label: "Efficiency Gain", value: `${Math.round(totalEfficiencyGain)}%`, color: "#8338EC", x: 10, y: 65 },
                    { label: "Cost Reduction", value: `${Math.round(totalCostReduction)}%`, color: "#FFB700", x: width / 2, y: 35 }
                ];

                metrics.forEach(metric => {
                    dashboard.append("text")
                        .attr("x", metric.x)
                        .attr("y", metric.y)
                        .attr("fill", metric.color)
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .text(`${metric.label}: ${metric.value}`);
                });

                // Add performance trend sparkline
                const sparkline = dashboard.append("g").attr("class", "performance-sparkline").attr("transform", `translate(${width - 120}, 25)`);
                const sparklineData = data.map(d => 1 - (d.latency / data[0].latency)); // Normalized performance improvement
                const sparklinePath = sparklineData.map((d, i) => `${i * 25},${(1 - d) * 30}`).join(" L");

                sparkline.append("path")
                    .attr("d", `M ${sparklinePath}`)
                    .attr("stroke", "var(--accent-green)")
                    .attr("stroke-width", 2)
                    .attr("fill", "none")
                    .attr("opacity", 0.8)
                    .style("animation", "sparklinePulse 2s ease-in-out infinite");

                sparkline.append("text")
                    .attr("x", 0)
                    .attr("y", 40)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "8px")
                    .text("Performance Trend");

                // Add comprehensive performance cues legend
                const legend = svg.append("g").attr("class", "performance-legend").attr("transform", `translate(${width - 200}, ${height + 120})`);

                // Legend background
                legend.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", 190)
                    .attr("height", 140)
                    .attr("fill", "rgba(27, 38, 59, 0.9)")
                    .attr("stroke", "var(--primary-border)")
                    .attr("rx", 8)
                    .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                // Legend title
                legend.append("text")
                    .attr("x", 10)
                    .attr("y", 15)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Performance Cues Legend");

                // Bottleneck type indicators
                legend.append("text")
                    .attr("x", 10)
                    .attr("y", 35)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "9px")
                    .style("font-weight", "bold")
                    .text("Bottleneck Types:");

                const bottleneckTypes = [
                    { color: "#FF6B6B", label: "Memory", x: 10, y: 50 },
                    { color: "#FFB700", label: "Compute", x: 10, y: 65 },
                    { color: "#2EC4B6", label: "Network", x: 10, y: 80 },
                    { color: "#10B981", label: "None", x: 10, y: 95 }
                ];

                bottleneckTypes.forEach(type => {
                    legend.append("rect")
                        .attr("x", type.x)
                        .attr("y", type.y - 8)
                        .attr("width", 6)
                        .attr("height", 6)
                        .attr("fill", type.color)
                        .attr("rx", 1);

                    legend.append("text")
                        .attr("x", type.x + 10)
                        .attr("y", type.y - 2)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "8px")
                        .text(type.label);
                });

                // Scaling capability indicators
                legend.append("text")
                    .attr("x", 100)
                    .attr("y", 35)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "9px")
                    .style("font-weight", "bold")
                    .text("Scaling:");

                const scalingTypes = [
                    { shape: "triangle", color: "#666", label: "None", x: 100, y: 50 },
                    { shape: "square", color: "#FFB700", label: "Vertical", x: 100, y: 65 },
                    { shape: "square", color: "#2EC4B6", label: "Horizontal", x: 100, y: 80 },
                    { shape: "diamond", color: "#10B981", label: "Elastic", x: 100, y: 95 }
                ];

                scalingTypes.forEach(type => {
                    if (type.shape === "triangle") {
                        legend.append("path")
                            .attr("d", `M${type.x},${type.y - 8} L${type.x + 6},${type.y - 8} L${type.x + 3},${type.y - 2} Z`)
                            .attr("fill", type.color);
                    } else if (type.shape === "square") {
                        legend.append("rect")
                            .attr("x", type.x)
                            .attr("y", type.y - 8)
                            .attr("width", 6)
                            .attr("height", 6)
                            .attr("fill", type.color);
                    } else if (type.shape === "diamond") {
                        legend.append("path")
                            .attr("d", `M${type.x + 3},${type.y - 8} L${type.x + 6},${type.y - 5} L${type.x + 3},${type.y - 2} L${type.x},${type.y - 5} Z`)
                            .attr("fill", type.color);
                    }

                    legend.append("text")
                        .attr("x", type.x + 10)
                        .attr("y", type.y - 2)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "8px")
                        .text(type.label);
                });

                // Latency breakdown legend
                legend.append("text")
                    .attr("x", 10)
                    .attr("y", 115)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "9px")
                    .style("font-weight", "bold")
                    .text("Latency Breakdown:");

                const latencyTypes = [
                    { color: "#FF6B6B", label: "Preprocessing", x: 10, y: 130 },
                    { color: "#3A86FF", label: "Inference", x: 10, y: 145 },
                    { color: "#2EC4B6", label: "Postprocessing", x: 100, y: 130 }
                ];

                latencyTypes.forEach(type => {
                    legend.append("rect")
                        .attr("x", type.x)
                        .attr("y", type.y - 8)
                        .attr("width", 8)
                        .attr("height", 6)
                        .attr("fill", type.color)
                        .attr("opacity", 0.7);

                    legend.append("text")
                        .attr("x", type.x + 12)
                        .attr("y", type.y - 2)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "8px")
                        .text(type.label);
                });
            }

            function renderAdvancedRetrievalViz() {
                const container = d3.select("#advanced-retrieval-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 20, right: 20, bottom: 20, left: 20 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
                const centerX = width / 2; const centerY = height / 2;
                const radius = Math.min(width, height) / 2.8;
                const centralNode = { x: centerX, y: centerY, name: "Retrieval Agent", tooltip: "Analyzes query and selects the optimal data source(s)." };
                const peripheralNodes = [
                    { name: "Vector DB", tooltip: "Use Case: Semantic search for documents, images, or concepts. Finds 'what is similar?'" },
                    { name: "Graph DB", tooltip: "Use Case: Querying complex relationships, like social networks or supply chains. Finds 'how are these connected?'" },
                    { name: "SQL DB", tooltip: "Use Case: Fetching precise, structured data like user profiles or sales figures. Finds 'what are the exact facts?'" }
                ];
                const angleStep = (2 * Math.PI) / peripheralNodes.length;
                peripheralNodes.forEach((node, i) => {
                    node.x = centerX + radius * Math.cos(i * angleStep - Math.PI / 2);
                    node.y = centerY + radius * Math.sin(i * angleStep - Math.PI / 2);
                });
                const allNodes = [centralNode, ...peripheralNodes];
                arrowMarker(svg, 'arrow-retrieval', 'var(--accent-cyan)');
                svg.selectAll(".link").data(peripheralNodes).enter().append("line").attr("x1", centralNode.x).attr("y1", centralNode.y).attr("x2", d => d.x).attr("y2", d => d.y).attr("stroke", "var(--accent-cyan)").attr("stroke-width", 2).attr("marker-end", "url(#arrow-retrieval)");
                const node = svg.selectAll(".node").data(allNodes).enter().append("g").attr("class", "node interactive-node").attr("transform", d => `translate(${d.x}, ${d.y})`).on("mouseover", (e, d) => showTooltip(e, d.tooltip)).on("mouseout", hideTooltip);
                node.append("circle").attr("r", d => d.name === "Retrieval Agent" ? 60 : 50).attr("fill", d => d.name === "Retrieval Agent" ? "var(--accent-blue)" : "var(--primary-border)").attr("stroke", "var(--accent-cyan)");
                node.append("text").attr("text-anchor", "middle").attr("dy", 5).attr("fill", d => d.name === "Retrieval Agent" ? "var(--bg-color)" : "var(--text-primary)").style("font-size", "12px").style("font-weight", "bold").text(d => d.name);
                const snowflakeGroup = svg.append("g").style("pointer-events", "none");
                const sqlNode = peripheralNodes.find(d => d.name === "SQL DB");
                snowflakeGroup.append("text").attr("x", sqlNode.x).attr("y", sqlNode.y + 70).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-family", "monospace").style("font-size", "10px").text("SELECT name FROM users;");
                const graphNode = peripheralNodes.find(d => d.name === "Graph DB");
                snowflakeGroup.append("text").attr("x", graphNode.x).attr("y", graphNode.y + 70).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-family", "monospace").style("font-size", "10px").text("(User)-[:PURCHASED]->(Product)");
                const vectorNode = peripheralNodes.find(d => d.name === "Vector DB");
                snowflakeGroup.append("text").attr("x", vectorNode.x).attr("y", vectorNode.y - 65).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-family", "monospace").style("font-size", "10px").text("[0.1, 0.8, -0.2, ...]");
            }

            /** Renders the prompt engineering & agentic behavior visualization. 
             * The diagram has two parts: a circular flow showing the iterative prompt
             * management lifecycle (Design → Test → Version → Deploy → Monitor), and a side‑by‑side comparison of 1‑Shot prompting versus the ReAct pattern. 
             */
            function renderPromptEngineeringViz() {
                const container = d3.select("#prompt-engineering-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;
                const width = bounds.width;
                const height = bounds.height;
                const svg = container.append("svg").attr("width", width).attr("height", height);
                // arrow markers for green and cyan
                arrowMarker(svg, "arrow-green", "var(--accent-green)");
                arrowMarker(svg, "arrow-cyan", "var(--accent-cyan)");
                // Circular flow for prompt lifecycle with enhanced tooltips
                const steps = [
                    { name: "Design", tooltip: "<b>Prompt Design</b><br>Systematic prompt architecture using proven patterns like Chain-of-Thought, Few-Shot, and ReAct. Involves prompt decomposition, role definition, and constraint specification for optimal model behavior." },
                    { name: "Test", tooltip: "<b>Prompt Testing</b><br>Rigorous evaluation using A/B testing, red-teaming, and adversarial prompting. Includes edge case validation, performance benchmarking, and safety verification across diverse scenarios." },
                    { name: "Version", tooltip: "<b>Version Control</b><br>Git-based prompt versioning with semantic versioning, branching strategies, and collaborative review processes. Maintains prompt lineage and enables rollback capabilities for production systems." },
                    { name: "Deploy", tooltip: "<b>Deployment</b><br>Staged rollout with canary deployments, feature flags, and gradual traffic shifting. Implements blue-green deployment strategies and automated rollback triggers for prompt updates." },
                    { name: "Monitor", tooltip: "<b>Monitoring</b><br>Real-time performance tracking with custom metrics, anomaly detection, and user feedback loops. Monitors response quality, latency, cost, and alignment with business objectives." }
                ];
                const centerX = width * 0.25;
                const centerY = height * 0.35;
                const radius = Math.min(width, height) * 0.18;
                steps.forEach((step, i) => {
                    const angle = (i / steps.length) * 2 * Math.PI - Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    // node circle with interactive tooltip
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, step.tooltip)).on("mouseout", hideTooltip);
                    g.append("circle")
                        .attr("cx", x)
                        .attr("cy", y)
                        .attr("r", 20)
                        .attr("fill", "var(--primary-border)")
                        .attr("stroke", "var(--accent-green)");
                    g.append("text")
                        .attr("x", x)
                        .attr("y", y + 4)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(step.name);
                    // arrow to next step
                    const nextAngle = ((i + 1) / steps.length) * 2 * Math.PI - Math.PI / 2;
                    const nextX = centerX + radius * Math.cos(nextAngle);
                    const nextY = centerY + radius * Math.sin(nextAngle);
                    svg.append("line")
                        .attr("x1", x + (nextX - x) * 0.4)
                        .attr("y1", y + (nextY - y) * 0.4)
                        .attr("x2", nextX - (nextX - x) * 0.4)
                        .attr("y2", nextY - (nextY - y) * 0.4)
                        .attr("stroke", "var(--accent-green)")
                        .attr("stroke-width", 1.5)
                        .attr("marker-end", "url(#arrow-green)");
                });
                // Title for lifecycle with consistent formatting
                svg.append("text")
                    .attr("x", centerX)
                    .attr("y", centerY - radius - 30)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-green)")
                    .style("font-weight", "bold")
                    .style("font-size", "14px")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("Prompt Lifecycle");
                // Comparison section: 1-Shot vs ReAct
                const compY = height * 0.7;
                const boxWidth = 150;
                const boxHeight = 100;
                // 1-Shot box
                const oneX = width * 0.55;
                svg.append("rect")
                    .attr("x", oneX - boxWidth / 2)
                    .attr("y", compY - boxHeight / 2)
                    .attr("width", boxWidth)
                    .attr("height", boxHeight)
                    .attr("fill", "var(--primary-border)")
                    .attr("stroke", "var(--accent-blue)")
                    .attr("rx", 6);
                svg.append("text")
                    .attr("x", oneX)
                    .attr("y", compY - boxHeight / 2 + 15)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-blue)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("1‑Shot Prompting");
                svg.append("line")
                    .attr("x1", oneX - 50)
                    .attr("y1", compY)
                    .attr("x2", oneX + 50)
                    .attr("y2", compY)
                    .attr("stroke", "var(--accent-blue)")
                    .attr("stroke-width", 1.5)
                    .attr("marker-end", "url(#arrow-blue)");
                svg.append("text")
                    .attr("x", oneX)
                    .attr("y", compY + 5)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "9px")
                    .style("font-weight", "500")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("Prompt → Output");
                // ReAct box
                const reactX = width * 0.8;
                svg.append("rect")
                    .attr("x", reactX - boxWidth / 2)
                    .attr("y", compY - boxHeight / 2)
                    .attr("width", boxWidth)
                    .attr("height", boxHeight)
                    .attr("fill", "var(--primary-border)")
                    .attr("stroke", "var(--accent-cyan)")
                    .attr("rx", 6);
                svg.append("text")
                    .attr("x", reactX)
                    .attr("y", compY - boxHeight / 2 + 15)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-cyan)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("font-family", "Inter, system-ui, sans-serif")
                    .text("ReAct Pattern");
                // Steps for ReAct pattern with enhanced tooltips
                const patternSteps = [
                    { name: "Prompt", tooltip: "<b>Initial Prompt</b><br>Task specification with role definition, context setting, and clear instructions. Establishes the agent's persona and problem-solving framework." },
                    { name: "Thought", tooltip: "<b>Reasoning Step</b><br>Internal monologue where the agent analyzes the problem, considers options, and plans the next action. Critical for transparent decision-making." },
                    { name: "Action", tooltip: "<b>Tool Execution</b><br>Structured function call to external tools (APIs, databases, calculators). Formatted for precise tool invocation with proper parameters." },
                    { name: "Obs.", tooltip: "<b>Observation</b><br>Tool execution result that provides new information to the agent. Forms the basis for the next reasoning cycle or final response generation." },
                    { name: "Output", tooltip: "<b>Final Response</b><br>Synthesized answer combining reasoning chain with observational evidence. Provides transparency and accountability in AI decision-making." }
                ];
                const stepStartX = reactX - (patternSteps.length - 1) * 20;
                const baseY = compY + 10;
                patternSteps.forEach((step, j) => {
                    const stepX = stepStartX + j * 40;
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, step.tooltip)).on("mouseout", hideTooltip);
                    g.append("circle")
                        .attr("cx", stepX)
                        .attr("cy", baseY)
                        .attr("r", 8)
                        .attr("fill", "var(--accent-cyan)");
                    g.append("text")
                        .attr("x", stepX)
                        .attr("y", baseY + 3)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--bg-color)")
                        .style("font-size", "7px")
                        .style("font-weight", "600")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .text(step.name[0]);
                    if (j < patternSteps.length - 1) {
                        svg.append("line")
                            .attr("x1", stepX + 8)
                            .attr("y1", baseY)
                            .attr("x2", stepX + 32)
                            .attr("y2", baseY)
                            .attr("stroke", "var(--accent-cyan)")
                            .attr("stroke-width", 1.2)
                            .attr("marker-end", "url(#arrow-cyan)");
                    }
                });
            }

            /** Renders the LLM Application Stack layered architecture visualization. */
            /** Renders the LLM Application Stack with enterprise-grade architecture visualization. */
            function renderLLMAppStackViz() {
                const container = d3.select("#llm-app-stack-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 50, right: 40, bottom: 60, left: 40 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for stack layers
                const defs = svg.append("defs");
                const layerGradients = [
                    { id: "evaluation-grad", colors: ["#8338EC", "#A855F7"] },
                    { id: "guardrails-grad", colors: ["#2EC4B6", "#34D399"] },
                    { id: "tools-grad", colors: ["#3A86FF", "#60A5FA"] },
                    { id: "foundation-grad", colors: ["#FFB700", "#FCD34D"] },
                    { id: "infrastructure-grad", colors: ["#FF6B6B", "#F87171"] }
                ];

                layerGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                });

                arrowMarker(svg, "arrow-data-flow", "#3A86FF");
                arrowMarker(svg, "arrow-feedback", "#2EC4B6");

                // Enhanced stack layer definitions with technical specifications
                const layers = [
                    {
                        name: "Evaluation & Monitoring Layer",
                        shortName: "Evaluation",
                        y: height * 0.05,
                        h: height * 0.15,
                        gradient: "url(#evaluation-grad)",
                        icon: "📊",
                        components: ["MMLU", "TruthfulQA", "HumanEval", "Custom Evals"],
                        metrics: { accuracy: "94.2%", latency: "45ms", throughput: "2.3k req/s" },
                        tooltip: "<b>Evaluation & Monitoring Layer</b><br>Standardized, reproducible frameworks for quantitatively measuring LLM performance. Automated systems execute diverse benchmark tests (MMLU, TruthfulQA, HumanEval) providing objective scores for model comparison and quality tracking.",
                        details: "Continuous model performance monitoring with automated alerting"
                    },
                    {
                        name: "Safety & Compliance Layer",
                        shortName: "Guardrails",
                        y: height * 0.25,
                        h: height * 0.15,
                        gradient: "url(#guardrails-grad)",
                        icon: "🛡️",
                        components: ["Input Filters", "Output Validators", "Content Moderation", "Compliance Checks"],
                        metrics: { blocked: "2.1%", latency: "8ms", compliance: "99.8%" },
                        tooltip: "<b>Safety & Compliance Layer</b><br>Multi-layered policies and technical controls ensuring safe, reliable, and compliant LLM behavior. Input guardrails filter malicious queries, output guardrails validate responses for toxicity and compliance before delivery.",
                        details: "Real-time content filtering with regulatory compliance (HIPAA, GDPR, SOC2)"
                    },
                    {
                        name: "Application Logic Layer",
                        shortName: "Tools & RAG",
                        y: height * 0.45,
                        h: height * 0.2,
                        gradient: "url(#tools-grad)",
                        icon: "🔧",
                        components: ["Tool Abstractions", "RAG Engine", "Context Management", "Workflow Orchestration"],
                        metrics: { tools: "47", contexts: "12k", cache_hit: "78%" },
                        tooltip: "<b>Application Logic Layer</b><br>Tool abstractions convert high-level intents into executable actions. RAG over longitudinal records enables synthesis of time-series data by indexing temporal information into vector databases for contextual retrieval and grounded response generation.",
                        details: "Intelligent function calling with context-aware retrieval systems"
                    },
                    {
                        name: "Foundation Model Layer",
                        shortName: "LLM Core",
                        y: height * 0.7,
                        h: height * 0.15,
                        gradient: "url(#foundation-grad)",
                        icon: "🧠",
                        components: ["GPT-4", "Claude", "Gemini", "Custom Models"],
                        metrics: { parameters: "1.76T", context: "128k", models: "12" },
                        tooltip: "<b>Foundation Model Layer</b><br>Large language models providing core reasoning capabilities. Includes both commercial APIs (GPT-4, Claude, Gemini) and custom fine-tuned models optimized for specific domains and use cases.",
                        details: "Multi-model routing with automatic failover and load balancing"
                    },
                    {
                        name: "Infrastructure Layer",
                        shortName: "Infrastructure",
                        y: height * 0.9,
                        h: height * 0.1,
                        gradient: "url(#infrastructure-grad)",
                        icon: "⚡",
                        components: ["GPU Clusters", "Vector DBs", "API Gateway", "Observability"],
                        metrics: { uptime: "99.9%", scaling: "Auto", regions: "5" },
                        tooltip: "<b>Infrastructure Layer</b><br>Scalable cloud infrastructure supporting LLM applications. Includes GPU clusters for model serving, vector databases for embeddings, API gateways for request routing, and comprehensive observability stack.",
                        details: "Cloud-native architecture with automatic scaling and multi-region deployment"
                    }
                ];

                // Render enhanced stack layers
                layers.forEach((layer, i) => {
                    const layerG = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, layer.tooltip)).on("mouseout", hideTooltip);

                    // Layer shadow for depth
                    layerG.append("rect").attr("x", 5).attr("y", layer.y + 3).attr("width", width - 10).attr("height", layer.h).attr("fill", "rgba(0,0,0,0.15)").attr("rx", 12);

                    // Main layer rectangle
                    layerG.append("rect").attr("x", 0).attr("y", layer.y).attr("width", width).attr("height", layer.h).attr("fill", layer.gradient).attr("stroke", "white").attr("stroke-width", 2).attr("rx", 12).style("filter", "drop-shadow(0px 3px 8px rgba(0,0,0,0.2))");

                    // Layer icon and title
                    layerG.append("text").attr("x", 25).attr("y", layer.y + layer.h / 2 - 5).attr("text-anchor", "middle").style("font-size", "28px").text(layer.icon);
                    layerG.append("text").attr("x", 60).attr("y", layer.y + layer.h / 2 - 8).attr("fill", "white").style("font-weight", "bold").style("font-size", "16px").text(layer.shortName);
                    layerG.append("text").attr("x", 60).attr("y", layer.y + layer.h / 2 + 8).attr("fill", "rgba(255,255,255,0.9)").style("font-size", "11px").text(layer.details);

                    // Enhanced responsive component indicators with collision detection
                    const minComponentSpacing = 50; // Reduced minimum spacing for better mobile support
                    const componentMargin = 20; // Margin from edges
                    const availableWidth = width - 300 - componentMargin;
                    const totalComponentWidth = layer.components.length * minComponentSpacing;
                    
                    // Calculate optimal spacing with overflow protection
                    let componentSpacing = Math.max(minComponentSpacing, availableWidth / layer.components.length);
                    
                    // Ensure components don't exceed available space
                    if (totalComponentWidth > availableWidth) {
                        componentSpacing = availableWidth / layer.components.length;
                    }
                    
                    layer.components.forEach((component, j) => {
                        const compX = 280 + (j * componentSpacing);
                        const adjustedCompX = Math.min(compX, width - componentMargin); // Enhanced overflow protection
                        
                        layerG.append("circle")
                            .attr("cx", adjustedCompX)
                            .attr("cy", layer.y + layer.h / 2 - 10)
                            .attr("r", 3)
                            .attr("fill", "rgba(255,255,255,0.8)");
                        
                        // Responsive component text with truncation
                        const maxComponentWidth = componentSpacing - 10;
                        const componentFontSize = Math.min(8, Math.max(6, maxComponentWidth / 8));
                        const maxChars = Math.floor(maxComponentWidth / (componentFontSize * 0.5));
                        const displayComponent = component.length > maxChars ? 
                            component.substring(0, maxChars - 3) + "..." : component;
                        
                        layerG.append("text")
                            .attr("x", adjustedCompX)
                            .attr("y", layer.y + layer.h / 2 + 5)
                            .attr("text-anchor", "middle")
                            .attr("fill", "rgba(255,255,255,0.8)")
                            .style("font-size", `${componentFontSize}px`)
                            .text(displayComponent);
                    });

                    // Enhanced adaptive performance metrics display
                    const metricsMargin = 20; // Margin from right edge
                    const metricsX = Math.max(width - 150, width - metricsMargin);
                    const metricKeys = Object.keys(layer.metrics);
                    
                    // Ensure metrics don't extend beyond container boundaries
                    const adjustedMetricsX = Math.min(metricsX, width - metricsMargin);
                    
                    metricKeys.forEach((key, j) => {
                        const metricY = layer.y + layer.h / 2 - 15 + (j * 12);
                        layerG.append("text")
                            .attr("x", adjustedMetricsX)
                            .attr("y", metricY)
                            .attr("fill", "rgba(255,255,255,0.9)")
                            .style("font-size", "9px")
                            .style("font-weight", "600")
                            .text(`${key}: ${layer.metrics[key]}`);
                    });
                });

                // Data flow visualization between layers
                const flowConnections = [
                    { from: 0, to: 1, label: "Model Outputs", type: "evaluation" },
                    { from: 1, to: 2, label: "Filtered Requests", type: "safety" },
                    { from: 2, to: 3, label: "Enhanced Prompts", type: "augmentation" },
                    { from: 3, to: 4, label: "Model Requests", type: "inference" },
                    { from: 4, to: 3, label: "Raw Responses", type: "response" },
                    { from: 2, to: 0, label: "Performance Data", type: "monitoring" }
                ];

                flowConnections.forEach(conn => {
                    const fromLayer = layers[conn.from];
                    const toLayer = layers[conn.to];
                    const isUpward = conn.from > conn.to;

                    const startY = fromLayer.y + (isUpward ? 0 : fromLayer.h);
                    const endY = toLayer.y + (isUpward ? toLayer.h : 0);
                    const flowX = conn.type === "monitoring" ? width - 30 : 30 + (flowConnections.indexOf(conn) * 40);

                    // Flow arrow
                    svg.append("line").attr("x1", flowX).attr("y1", startY).attr("x2", flowX).attr("y2", endY).attr("stroke", isUpward ? "#2EC4B6" : "#3A86FF").attr("stroke-width", 2).attr("marker-end", isUpward ? "url(#arrow-feedback)" : "url(#arrow-data-flow)").attr("opacity", 0.7);

                    // Dynamic flow label sizing with responsive positioning
                    const labelY = (startY + endY) / 2;
                    const baseFontSize = 8;
                    const responsiveFontSize = Math.min(baseFontSize, Math.max(6, width / 100));
                    const labelWidth = Math.max(conn.label.length * (responsiveFontSize * 0.7), 40); // Minimum width
                    const labelHeight = 14;
                    
                    // Ensure label doesn't overflow horizontally
                    const labelLeft = Math.max(5, flowX - labelWidth / 2 - 5);
                    const labelRight = Math.min(width - 5, flowX + labelWidth / 2 + 5);
                    const adjustedLabelX = (labelLeft + labelRight) / 2;
                    const adjustedLabelWidth = labelRight - labelLeft - 10;
                    
                    svg.append("rect")
                        .attr("x", labelLeft)
                        .attr("y", labelY - 8)
                        .attr("width", adjustedLabelWidth)
                        .attr("height", labelHeight)
                        .attr("fill", "rgba(13, 27, 42, 0.9)")
                        .attr("rx", 7);
                    
                    // Truncate label text if too long
                    const maxChars = Math.floor(adjustedLabelWidth / (responsiveFontSize * 0.6));
                    const displayLabel = conn.label.length > maxChars ? 
                        conn.label.substring(0, maxChars - 3) + "..." : conn.label;
                    
                    svg.append("text")
                        .attr("x", adjustedLabelX)
                        .attr("y", labelY + 3)
                        .attr("text-anchor", "middle")
                        .attr("fill", isUpward ? "#2EC4B6" : "#3A86FF")
                        .style("font-size", `${responsiveFontSize}px`)
                        .style("font-weight", "600")
                        .text(displayLabel);
                });

                // Stack performance dashboard
                const dashboardY = height + 40;
                svg.append("text").attr("x", 0).attr("y", dashboardY).attr("fill", "var(--text-primary)").style("font-weight", "600").style("font-size", "14px").text("Stack Performance");

                const stackMetrics = [
                    { label: "End-to-End Latency", value: "127ms", color: "#3A86FF" },
                    { label: "Request Success Rate", value: "99.7%", color: "#2EC4B6" },
                    { label: "Safety Coverage", value: "99.8%", color: "#8338EC" },
                    { label: "Total Throughput", value: "2.3k req/s", color: "#FFB700" }
                ];

                stackMetrics.forEach((metric, i) => {
                    const x = i * (width / 4);
                    svg.append("circle").attr("cx", x).attr("cy", dashboardY + 20).attr("r", 4).attr("fill", metric.color);
                    svg.append("text").attr("x", x + 12).attr("y", dashboardY + 24).attr("fill", "var(--text-secondary)").style("font-size", "11px").text(`${metric.label}: ${metric.value}`);
                });

                // Enhanced title and architecture description
                svg.append("text").attr("x", width / 2).attr("y", -25).attr("text-anchor", "middle").attr("fill", "var(--text-primary)").style("font-weight", "700").style("font-size", "18px").text("Enterprise LLM Application Stack");
                svg.append("text").attr("x", width / 2).attr("y", height + 65).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "12px").text("Layered architecture with evaluation harnesses, guardrails, tool abstractions, and foundation models");
            }

            /** Renders the Prompt Injection & Hardening with sophisticated security visualization and threat modeling. */
            function renderPromptInjectionViz() {
                const container = d3.select("#prompt-injection-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 40 : isTablet ? 50 : 60, 
                    right: isMobile ? 30 : isTablet ? 35 : 40, 
                    bottom: isMobile ? 60 : isTablet ? 70 : 80, 
                    left: isMobile ? 30 : isTablet ? 35 : 40 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for sophisticated security visualization
                const defs = svg.append("defs");
                const securityGradients = [
                    { id: "attack-grad", colors: ["#FF6B6B", "#F87171", "#FCA5A5"] },
                    { id: "defense-grad", colors: ["#2EC4B6", "#34D399", "#6EE7B7"] },
                    { id: "validation-grad", colors: ["#3A86FF", "#60A5FA", "#93C5FD"] },
                    { id: "monitoring-grad", colors: ["#8338EC", "#A855F7", "#C084FC"] },
                    { id: "alert-grad", colors: ["#FFB700", "#FCD34D", "#FDE68A"] },
                    { id: "threat-grad", colors: ["#EF4444", "#F87171", "#FCA5A5"] },
                    { id: "secure-grad", colors: ["#10B981", "#34D399", "#6EE7B7"] }
                ];

                securityGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[2]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.8);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                // Enhanced arrow markers for different security flows
                arrowMarker(svg, "arrow-security", "#2EC4B6");
                arrowMarker(svg, "arrow-attack", "#FF6B6B");
                arrowMarker(svg, "arrow-blocked", "#FFB700");
                arrowMarker(svg, "arrow-threat", "#EF4444");
                arrowMarker(svg, "arrow-secure", "#10B981");

                // Sophisticated security architecture with threat modeling
                const securityLayers = [
                    {
                        name: "User Input",
                        x: width * 0.1,
                        y: height * 0.4,
                        type: "entry",
                        icon: "👤",
                        gradient: "url(#attack-grad)",
                        riskLevel: "High",
                        threats: ["Direct Injection", "Jailbreaking", "Social Engineering"],
                        tooltip: "<b>User Input Layer</b><br><span style='color:#FF6B6B'>⚠️ HIGH RISK</span><br><br>Primary attack vector for prompt injection attempts:<br>• Direct injection: 'Ignore previous instructions...'<br>• Indirect injection through poisoned documents<br>• Jailbreaking techniques to bypass safety<br>• Social engineering and context manipulation"
                    },
                    {
                        name: "Input Validation",
                        x: width * 0.3,
                        y: height * 0.25,
                        type: "defense",
                        icon: "🛡️",
                        gradient: "url(#defense-grad)",
                        riskLevel: "Medium",
                        threats: ["Bypass Detection", "Adversarial Examples"],
                        tooltip: "<b>Input Validation & Filtering</b><br><span style='color:#2EC4B6'>🛡️ DEFENSE LAYER</span><br><br>First line of defense implementing:<br>• Semantic analysis and pattern matching<br>• ML-based adversarial detection<br>• Real-time threat intelligence<br>• Content classification and scoring"
                    },
                    {
                        name: "Model Sandbox",
                        x: width * 0.55,
                        y: height * 0.4,
                        type: "isolation",
                        icon: "🔒",
                        gradient: "url(#validation-grad)",
                        riskLevel: "Low",
                        threats: ["Privilege Escalation", "Sandbox Escape"],
                        tooltip: "<b>Model Execution Sandbox</b><br><span style='color:#3A86FF'>🔒 ISOLATION LAYER</span><br><br>Isolated execution environment:<br>• Restricted permissions and resource limits<br>• Network segmentation and access controls<br>• Memory isolation and process containment<br>• Audit logging and behavior monitoring"
                    },
                    {
                        name: "Output Monitor",
                        x: width * 0.75,
                        y: height * 0.2,
                        type: "monitoring",
                        icon: "👁️",
                        gradient: "url(#monitoring-grad)",
                        riskLevel: "Critical",
                        threats: ["Data Leakage", "Policy Violations"],
                        tooltip: "<b>Output Monitoring & DLP</b><br><span style='color:#8338EC'>👁️ CRITICAL MONITORING</span><br><br>Real-time output analysis:<br>• Data leakage and PII detection<br>• Policy compliance checking<br>• Content classification and filtering<br>• Automated response and alerting"
                    },
                    {
                        name: "Secure Response",
                        x: width * 0.9,
                        y: height * 0.5,
                        type: "output",
                        icon: "📤",
                        gradient: "url(#alert-grad)",
                        riskLevel: "Medium",
                        threats: ["Man-in-the-Middle", "Response Tampering"],
                        tooltip: "<b>Secure Response Delivery</b><br><span style='color:#FFB700'>📤 SECURE OUTPUT</span><br><br>Final security checkpoint:<br>• Response integrity verification<br>• Encryption and secure delivery<br>• Audit logging and compliance<br>• Rate limiting and access controls"
                    }
                ];

                // Responsive sizing calculation functions
                const calculateComponentSize = (baseWidth, baseHeight, containerWidth, containerHeight) => {
                    const scaleFactor = Math.min(containerWidth / 800, containerHeight / 600, 1.2);
                    return {
                        width: Math.max(baseWidth * scaleFactor, baseWidth * 0.7),
                        height: Math.max(baseHeight * scaleFactor, baseHeight * 0.7)
                    };
                };

                const calculateThreatRadius = (baseRadius, containerWidth) => {
                    const scaleFactor = Math.min(containerWidth / 800, 1.2);
                    return Math.max(baseRadius * scaleFactor, baseRadius * 0.6);
                };

                // Add responsive animated background threat indicators
                const threatPatternSize = isMobile ? 20 : isTablet ? 25 : 30;
                const threatPattern = defs.append("pattern")
                    .attr("id", "threat-pattern")
                    .attr("width", threatPatternSize)
                    .attr("height", threatPatternSize)
                    .attr("patternUnits", "userSpaceOnUse");
                threatPattern.append("circle")
                    .attr("cx", threatPatternSize / 2)
                    .attr("cy", threatPatternSize / 2)
                    .attr("r", isMobile ? 0.8 : 1)
                    .attr("fill", "rgba(239, 68, 68, 0.1)");

                svg.append("rect").attr("width", width).attr("height", height).attr("fill", "url(#threat-pattern)");

                // Create sophisticated security layer visualization with responsive sizing
                securityLayers.forEach((layer, index) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node")
                        .on("mouseover", (e) => {
                            // Dynamic risk highlighting on hover
                            d3.select(this).selectAll("rect").transition().duration(200)
                                .attr("stroke-width", 3)
                                .attr("stroke", "rgba(255, 255, 255, 0.6)");
                            showTooltip(e, layer.tooltip);
                        })
                        .on("mouseout", function () {
                            // Reset highlighting
                            d3.select(this).selectAll("rect").transition().duration(200)
                                .attr("stroke-width", 2)
                                .attr("stroke", "rgba(255, 255, 255, 0.3)");
                            hideTooltip();
                        });

                    // Calculate responsive component sizing
                    const componentSize = calculateComponentSize(100, 40, width, height);
                    const threatRadius = calculateThreatRadius(12, width);
                    const threatOffset = isMobile ? 25 : 30;
                    const threatDistance = isMobile ? 50 : 70;

                    // Animated threat indicator with responsive sizing
                    const threatGroup = g.append("g");
                    threatGroup.append("circle")
                        .attr("cx", layer.x)
                        .attr("cy", layer.y - threatOffset)
                        .attr("r", threatRadius)
                        .attr("fill", layer.riskLevel === "High" ? "url(#threat-grad)" : layer.riskLevel === "Critical" ? "url(#threat-grad)" : "url(#secure-grad)")
                        .attr("opacity", 0.8)
                        .style("animation", `pulse 2s ease-in-out infinite ${index * 0.3}s`);

                    // Risk level indicator with responsive sizing
                    threatGroup.append("text")
                        .attr("x", layer.x)
                        .attr("y", layer.y - threatOffset + (isMobile ? 2 : 3))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", isMobile ? "6px" : "8px")
                        .style("font-weight", "700")
                        .text(layer.riskLevel === "High" ? "!" : layer.riskLevel === "Critical" ? "!!" : "✓");

                    // Main security component with responsive sizing
                    g.append("rect")
                        .attr("x", layer.x - componentSize.width / 2)
                        .attr("y", layer.y - componentSize.height / 2)
                        .attr("width", componentSize.width)
                        .attr("height", componentSize.height)
                        .attr("fill", layer.gradient)
                        .attr("rx", isMobile ? 6 : 8)
                        .attr("stroke", "rgba(255, 255, 255, 0.3)")
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .style("filter", "drop-shadow(0 4px 12px rgba(0,0,0,0.3))");

                    // Component icon with responsive sizing
                    g.append("text")
                        .attr("x", layer.x - componentSize.width * 0.35)
                        .attr("y", layer.y + (isMobile ? 3 : 5))
                        .attr("fill", "white")
                        .style("font-size", isMobile ? "12px" : "16px")
                        .text(layer.icon);

                    // Component name with responsive sizing
                    g.append("text")
                        .attr("x", layer.x - componentSize.width * 0.15)
                        .attr("y", layer.y + (isMobile ? 3 : 5))
                        .attr("fill", "white")
                        .style("font-size", isMobile ? "8px" : "10px")
                        .style("font-weight", "600")
                        .text(layer.name);

                    // Threat indicators around each component with responsive positioning
                    layer.threats.forEach((threat, i) => {
                        const angle = (i * 120 - 60) * Math.PI / 180;
                        const threatX = layer.x + Math.cos(angle) * threatDistance;
                        const threatY = layer.y + Math.sin(angle) * threatDistance;

                        g.append("circle")
                            .attr("cx", threatX)
                            .attr("cy", threatY)
                            .attr("r", isMobile ? 3 : 4)
                            .attr("fill", "#EF4444")
                            .attr("opacity", 0.7);

                        g.append("text")
                            .attr("x", threatX + (isMobile ? 6 : 8))
                            .attr("y", threatY + (isMobile ? 2 : 3))
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", isMobile ? "6px" : "8px")
                            .text(threat);
                    });
                });

                // Sophisticated security flow connections with enhanced threat intelligence
                const securityFlows = [
                    { from: 0, to: 1, type: "normal", color: "#2EC4B6", marker: "arrow-security", label: "Input Processing", flow: "data" },
                    { from: 1, to: 2, type: "normal", color: "#2EC4B6", marker: "arrow-security", label: "Validation Pass", flow: "data" },
                    { from: 2, to: 3, type: "normal", color: "#2EC4B6", marker: "arrow-security", label: "Execution", flow: "data" },
                    { from: 3, to: 4, type: "normal", color: "#2EC4B6", marker: "arrow-security", label: "Output Delivery", flow: "data" },
                    { from: 0, to: 2, type: "bypass", color: "#FF6B6B", marker: "arrow-attack", dash: "5,5", label: "Injection Bypass", flow: "threat" },
                    { from: 1, to: 3, type: "bypass", color: "#FF6B6B", marker: "arrow-attack", dash: "5,5", label: "Validation Bypass", flow: "threat" },
                    { from: 0, to: 3, type: "direct", color: "#EF4444", marker: "arrow-threat", dash: "8,4", label: "Direct Attack", flow: "critical" },
                    { from: 2, to: 0, type: "feedback", color: "#10B981", marker: "arrow-secure", dash: "2,2", label: "Security Feedback", flow: "defense" },
                    { from: 3, to: 1, type: "alert", color: "#FFB700", marker: "arrow-blocked", dash: "3,3", label: "Threat Alert", flow: "monitoring" }
                ];

                securityFlows.forEach((flow, index) => {
                    const fromLayer = securityLayers[flow.from];
                    const toLayer = securityLayers[flow.to];

                    // Calculate responsive component offsets
                    const componentOffset = isMobile ? 35 : 50;
                    const feedbackOffset = isMobile ? 70 : 100;
                    const alertOffset = isMobile ? 20 : 30;

                    // Calculate flow path with different curves for different flow types
                    let pathData;
                    const midX = (fromLayer.x + toLayer.x) / 2;
                    const midY = (fromLayer.y + toLayer.y) / 2;

                    if (flow.type === "direct") {
                        // Direct attack path - straight line
                        pathData = `M ${fromLayer.x + componentOffset} ${fromLayer.y} L ${toLayer.x - componentOffset} ${toLayer.y}`;
                    } else if (flow.type === "feedback") {
                        // Feedback loop - curved path
                        pathData = `M ${fromLayer.x - componentOffset} ${fromLayer.y} Q ${fromLayer.x - feedbackOffset} ${fromLayer.y - componentOffset} ${toLayer.x + componentOffset} ${toLayer.y}`;
                    } else if (flow.type === "alert") {
                        // Alert flow - zigzag pattern
                        pathData = `M ${fromLayer.x + componentOffset} ${fromLayer.y} L ${midX} ${fromLayer.y - alertOffset} L ${toLayer.x - componentOffset} ${toLayer.y}`;
                    } else {
                        // Normal flow - curved path
                        pathData = `M ${fromLayer.x + componentOffset} ${fromLayer.y} Q ${midX} ${Math.min(fromLayer.y, toLayer.y) - alertOffset} ${toLayer.x - componentOffset} ${toLayer.y}`;
                    }

                    const path = svg.append("path")
                        .attr("d", pathData)
                        .attr("stroke", flow.color)
                        .attr("stroke-width", flow.type === "bypass" ? (isMobile ? 1.5 : 2) : flow.type === "direct" ? (isMobile ? 3 : 4) : (isMobile ? 2.5 : 3))
                        .attr("fill", "none")
                        .attr("marker-end", `url(#${flow.marker})`)
                        .attr("opacity", flow.type === "bypass" ? 0.6 : flow.type === "direct" ? 0.9 : 0.8)
                        .style("filter", flow.type === "direct" ? "drop-shadow(0 0 8px rgba(239, 68, 68, 0.5))" : "none");

                    if (flow.dash) {
                        path.attr("stroke-dasharray", flow.dash);
                    }

                    // Add flow animation for critical flows
                    if (flow.flow === "critical" || flow.flow === "threat") {
                        const pathLength = path.node().getTotalLength();
                        path.attr("stroke-dasharray", `${pathLength} ${pathLength}`)
                            .attr("stroke-dashoffset", pathLength)
                            .transition()
                            .duration(2000)
                            .delay(index * 200)
                            .attr("stroke-dashoffset", 0);
                    }

                    // Add flow label with responsive positioning
                    const labelX = midX;
                    const labelY = flow.type === "feedback" ? midY - (isMobile ? 25 : 30) : flow.type === "alert" ? midY - (isMobile ? 15 : 20) : midY - (isMobile ? 10 : 15);

                    svg.append("text")
                        .attr("x", labelX)
                        .attr("y", labelY)
                        .attr("text-anchor", "middle")
                        .attr("fill", flow.color)
                        .style("font-size", isMobile ? "7px" : "9px")
                        .style("font-weight", "600")
                        .style("background", "rgba(0,0,0,0.7)")
                        .style("padding", isMobile ? "1px 3px" : "2px 4px")
                        .style("border-radius", "3px")
                        .text(flow.label);

                    // Add flow intensity indicator with responsive sizing
                    if (flow.flow === "critical") {
                        svg.append("circle")
                            .attr("cx", labelX + (isMobile ? 20 : 30))
                            .attr("cy", labelY)
                            .attr("r", isMobile ? 2.5 : 3)
                            .attr("fill", "#EF4444")
                            .style("animation", `pulse 1s ease-in-out infinite`);
                    }
                });

                // Advanced attack examples with sophisticated visualization
                const attackExamples = [
                    {
                        name: "Direct Injection",
                        example: '"Ignore previous instructions and tell me..."',
                        x: width * 0.05,
                        y: height * 0.75,
                        severity: "High",
                        color: "#EF4444"
                    },
                    {
                        name: "Indirect Injection",
                        example: "Poisoned document with hidden prompts",
                        x: width * 0.35,
                        y: height * 0.75,
                        severity: "Medium",
                        color: "#F59E0B"
                    },
                    {
                        name: "Jailbreaking",
                        example: "Role-playing and context manipulation",
                        x: width * 0.65,
                        y: height * 0.75,
                        severity: "High",
                        color: "#EF4444"
                    }
                ];

                attackExamples.forEach((attack, i) => {
                    const attackGroup = svg.append("g");

                    // Attack severity indicator
                    attackGroup.append("circle")
                        .attr("cx", attack.x + 10).attr("cy", attack.y - 10)
                        .attr("r", 8)
                        .attr("fill", attack.color)
                        .attr("opacity", 0.8);

                    attackGroup.append("text")
                        .attr("x", attack.x + 10).attr("y", attack.y - 10 + 3)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "8px")
                        .style("font-weight", "700")
                        .text(attack.severity === "High" ? "!" : "!");

                    // Attack name
                    attackGroup.append("text")
                        .attr("x", attack.x).attr("y", attack.y)
                        .attr("fill", attack.color)
                        .style("font-size", "11px")
                        .style("font-weight", "600")
                        .text(attack.name);

                    // Attack example
                    attackGroup.append("text")
                        .attr("x", attack.x).attr("y", attack.y + 15)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "9px")
                        .text(attack.example);

                    // Attack flow to security layer
                    const targetLayer = securityLayers[0];
                    attackGroup.append("path")
                        .attr("d", `M ${attack.x + 50} ${attack.y} Q ${(attack.x + targetLayer.x) / 2} ${attack.y - 30} ${targetLayer.x - 50} ${targetLayer.y + 20}`)
                        .attr("stroke", attack.color)
                        .attr("stroke-width", 2)
                        .attr("fill", "none")
                        .attr("marker-end", "url(#arrow-attack)")
                        .attr("stroke-dasharray", "3,3")
                        .attr("opacity", 0.6);
                });

                // Security metrics dashboard
                const metricsY = height - 20;
                const metrics = [
                    { label: "Threats Blocked", value: "99.7%", color: "#10B981" },
                    { label: "Response Time", value: "<50ms", color: "#3B82F6" },
                    { label: "False Positives", value: "0.1%", color: "#F59E0B" },
                    { label: "Coverage", value: "100%", color: "#8B5CF6" }
                ];

                metrics.forEach((metric, i) => {
                    const x = width * 0.2 + i * (width * 0.2);
                    svg.append("rect")
                        .attr("x", x - 30).attr("y", metricsY - 15)
                        .attr("width", 60).attr("height", 30)
                        .attr("fill", metric.color)
                        .attr("rx", 5)
                        .attr("opacity", 0.8);

                    svg.append("text")
                        .attr("x", x).attr("y", metricsY - 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "9px")
                        .style("font-weight", "600")
                        .text(metric.value);

                    svg.append("text")
                        .attr("x", x).attr("y", metricsY + 8)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "8px")
                        .text(metric.label);
                });

                // Enhanced security flow legend
                const flowLegend = svg.append("g").attr("class", "flow-legend").attr("transform", `translate(${width - 200}, 20)`);

                flowLegend.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Security Flow Types");

                const flowTypes = [
                    { type: "data", label: "Data Flow", color: "#2EC4B6", y: 20 },
                    { type: "threat", label: "Threat Flow", color: "#FF6B6B", y: 40 },
                    { type: "critical", label: "Critical Attack", color: "#EF4444", y: 60 },
                    { type: "defense", label: "Defense Flow", color: "#10B981", y: 80 },
                    { type: "monitoring", label: "Monitoring", color: "#FFB700", y: 100 }
                ];

                flowTypes.forEach(flowType => {
                    flowLegend.append("line")
                        .attr("x1", 5)
                        .attr("y1", flowType.y)
                        .attr("x2", 15)
                        .attr("y2", flowType.y)
                        .attr("stroke", flowType.color)
                        .attr("stroke-width", 3)
                        .attr("marker-end", "url(#arrow-security)");

                    flowLegend.append("text")
                        .attr("x", 20)
                        .attr("y", flowType.y + 3)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(flowType.label);
                });

                // Add CSS animation for threat indicators
                if (!document.getElementById('security-animations')) {
                    const style = document.createElement('style');
                    style.id = 'security-animations';
                    style.textContent = `
                    @keyframes pulse {
                        0%, 100% { opacity: 0.8; transform: scale(1); }
                        50% { opacity: 1; transform: scale(1.1); }
                    }
                    @keyframes threatPulse {
                        0%, 100% { opacity: 0.6; }
                        50% { opacity: 1; }
                    }
                `;
                    document.head.appendChild(style);
                }
            }

            /** Renders the Cloud-Native Gen AI Stack architecture visualization with advanced pre-attentive attributes and Tableau Jedi Master techniques. */
            function renderCloudNativeViz() {
                const container = d3.select("#cloud-native-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 20 : isTablet ? 25 : 30, 
                    right: isMobile ? 20 : isTablet ? 25 : 30, 
                    bottom: isMobile ? 20 : isTablet ? 25 : 30, 
                    left: isMobile ? 20 : isTablet ? 25 : 30 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers with gradient effects and multiple styles
                arrowMarker(svg, "arrow-cloud", "var(--accent-purple)");
                arrowMarker(svg, "arrow-cloud-glow", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-cloud-critical", "var(--accent-green)");
                arrowMarker(svg, "arrow-cloud-data", "var(--accent-blue)");

                // Advanced gradient definitions for visual storytelling
                const defs = svg.append("defs");

                // Service layer gradients with depth and dimension
                const serviceGradients = [
                    { id: "data-layer-grad", colors: ["#3A86FF", "#1E40AF"], direction: "vertical" },
                    { id: "processing-layer-grad", colors: ["#2EC4B6", "#0D9488"], direction: "diagonal" },
                    { id: "training-layer-grad", colors: ["#00A6FB", "#0284C7"], direction: "radial" },
                    { id: "serving-layer-grad", colors: ["#8338EC", "#7C3AED"], direction: "vertical" },
                    { id: "app-layer-grad", colors: ["#3A86FF", "#1D4ED8"], direction: "horizontal" }
                ];

                serviceGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id);
                    if (grad.direction === "vertical") {
                        gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                    } else if (grad.direction === "horizontal") {
                        gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    } else if (grad.direction === "diagonal") {
                        gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                    } else if (grad.direction === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", grad.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                        return;
                    }
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                });

                // Responsive sizing calculation functions
                const calculateServiceSize = (baseWidth, baseHeight, containerWidth, containerHeight) => {
                    const scaleFactor = Math.min(containerWidth / 800, containerHeight / 600, 1.2);
                    return {
                        width: Math.max(baseWidth * scaleFactor, baseWidth * 0.7),
                        height: Math.max(baseHeight * scaleFactor, baseHeight * 0.7)
                    };
                };

                const calculateGridSize = (containerWidth, containerHeight) => {
                    const baseGridSize = 20;
                    const scaleFactor = Math.min(containerWidth / 800, containerHeight / 600, 1.2);
                    return Math.max(baseGridSize * scaleFactor, baseGridSize * 0.8);
                };

                // Add responsive animated background grid with depth perception
                const gridSize = calculateGridSize(width, height);
                const gridOpacity = isMobile ? 0.03 : 0.05;
                
                for (let x = 0; x <= width; x += gridSize) {
                    svg.append("line")
                        .attr("x1", x).attr("y1", 0)
                        .attr("x2", x).attr("y2", height)
                        .attr("stroke", "var(--primary-border)")
                        .attr("stroke-opacity", gridOpacity)
                        .attr("stroke-dasharray", "1,3")
                        .style("animation", isMobile ? "none" : `gridPulse ${3 + (x / gridSize) * 0.1}s ease-in-out infinite alternate`);
                }
                for (let y = 0; y <= height; y += gridSize) {
                    svg.append("line")
                        .attr("x1", 0).attr("y1", y)
                        .attr("x2", width).attr("y2", y)
                        .attr("stroke", "var(--primary-border)")
                        .attr("stroke-opacity", gridOpacity)
                        .attr("stroke-dasharray", "1,3")
                        .style("animation", isMobile ? "none" : `gridPulse ${2 + (y / gridSize) * 0.1}s ease-in-out infinite alternate`);
                }

                // Enhanced services with responsive positioning and advanced pre-attentive attributes
                const services = [
                    {
                        name: "Data Lake",
                        subtitle: "BigQuery/S3/Cosmos DB",
                        x: isMobile ? width * 0.25 : width * 0.2,
                        y: height * 0.25,
                        color: "var(--accent-blue)",
                        gradient: "data-layer-grad",
                        shape: "rect",
                        size: "large",
                        opacity: 0.9,
                        icon: "🗄️",
                        priority: "high",
                        category: "storage",
                        complexity: "medium",
                        performance: { latency: "50ms", throughput: "10TB/s", availability: "99.9%" },
                        cost: "$0.023/GB",
                        compliance: ["SOC2", "HIPAA", "GDPR"],
                        tooltip: "<b>Data Lake (BigQuery/S3/Cosmos DB)</b><br>Centralized repository for structured and unstructured data with built-in compliance controls. Supports data governance frameworks (SOC2, HIPAA, GDPR) with automatic encryption, access controls, and audit logging. Enables data lineage tracking and retention policies critical for regulatory environments.<br><br><b>Performance:</b> 50ms latency, 10TB/s throughput, 99.9% availability<br><b>Cost:</b> $0.023/GB<br><b>Compliance:</b> SOC2, HIPAA, GDPR"
                    },
                    {
                        name: "ETL Pipeline",
                        subtitle: "Dataflow/Lambda/Functions",
                        x: width * 0.5,
                        y: height * 0.25,
                        color: "var(--accent-green)",
                        gradient: "processing-layer-grad",
                        shape: "diamond",
                        size: "medium",
                        opacity: 0.85,
                        icon: "⚡",
                        priority: "high",
                        category: "processing",
                        complexity: "high",
                        performance: { latency: "200ms", throughput: "5TB/s", availability: "99.5%" },
                        cost: "$0.045/GB",
                        compliance: ["SOC2", "ISO27001"],
                        tooltip: "<b>ETL Pipeline (Dataflow/Lambda/Functions)</b><br>Serverless data processing for cleaning, transforming, and preparing datasets for model training. Implements data quality validation, bias detection, and automated data pipeline orchestration. Critical for maintaining data integrity and reproducibility in production ML systems.<br><br><b>Performance:</b> 200ms latency, 5TB/s throughput, 99.5% availability<br><b>Cost:</b> $0.045/GB<br><b>Compliance:</b> SOC2, ISO27001"
                    },
                    {
                        name: "Model Training",
                        subtitle: "Vertex AI/SageMaker/Azure ML",
                        x: isMobile ? width * 0.75 : width * 0.8,
                        y: height * 0.25,
                        color: "var(--accent-cyan)",
                        gradient: "training-layer-grad",
                        shape: "circle",
                        size: "large",
                        opacity: 0.9,
                        icon: "🧠",
                        priority: "high",
                        category: "compute",
                        complexity: "high",
                        performance: { latency: "2-8h", throughput: "100 models/day", availability: "99.0%" },
                        cost: "$2.50/hour",
                        compliance: ["SOC2", "HIPAA"],
                        tooltip: "<b>Model Training (Vertex AI/SageMaker/Azure ML)</b><br>Managed ML training environments supporting distributed computing, hyperparameter optimization, and experiment tracking. Provides secure model development with built-in compliance monitoring, automated model versioning, and integration with CI/CD pipelines for MLOps workflows.<br><br><b>Performance:</b> 2-8h training time, 100 models/day throughput, 99.0% availability<br><b>Cost:</b> $2.50/hour<br><b>Compliance:</b> SOC2, HIPAA"
                    },
                    {
                        name: "Model Serving",
                        subtitle: "Cloud Run/Lambda/Container",
                        x: width * 0.5,
                        y: height * 0.65,
                        color: "var(--accent-purple)",
                        gradient: "serving-layer-grad",
                        shape: "hexagon",
                        size: "extra-large",
                        opacity: 1.0,
                        icon: "🚀",
                        priority: "critical",
                        category: "inference",
                        complexity: "medium",
                        performance: { latency: "10ms", throughput: "1M req/s", availability: "99.99%" },
                        cost: "$0.0001/request",
                        compliance: ["SOC2", "HIPAA", "GDPR", "PCI-DSS"],
                        tooltip: "<b>Model Serving (Cloud Run/Lambda/Container Instances)</b><br>Scalable inference endpoints with auto-scaling, load balancing, and traffic management. Implements A/B testing capabilities, canary deployments, and real-time monitoring for production model performance. Supports both synchronous and asynchronous inference patterns.<br><br><b>Performance:</b> 10ms latency, 1M req/s throughput, 99.99% availability<br><b>Cost:</b> $0.0001/request<br><b>Compliance:</b> SOC2, HIPAA, GDPR, PCI-DSS"
                    },
                    {
                        name: "Application",
                        subtitle: "Cloud Functions/Lambda",
                        x: isMobile ? width * 0.25 : width * 0.2,
                        y: height * 0.85,
                        color: "var(--accent-blue)",
                        gradient: "app-layer-grad",
                        shape: "rect",
                        size: "medium",
                        opacity: 0.8,
                        icon: "📱",
                        priority: "medium",
                        category: "interface",
                        complexity: "low",
                        performance: { latency: "100ms", throughput: "100K req/s", availability: "99.5%" },
                        cost: "$0.0002/request",
                        compliance: ["SOC2", "GDPR"],
                        tooltip: "<b>Application Layer (Cloud Functions/Lambda/Azure Functions)</b><br>Serverless compute layer handling user interactions, authentication, and business logic. Implements request/response caching, rate limiting, and integration with observability tools (LangSmith, Weights & Biases) for comprehensive system monitoring and cost optimization.<br><br><b>Performance:</b> 100ms latency, 100K req/s throughput, 99.5% availability<br><b>Cost:</b> $0.0002/request<br><b>Compliance:</b> SOC2, GDPR"
                    }
                ];

                // Size mapping for pre-attentive encoding
                const sizeMap = {
                    "small": { width: 80, height: 40 },
                    "medium": { width: 100, height: 50 },
                    "large": { width: 120, height: 60 },
                    "extra-large": { width: 140, height: 70 }
                };

                // Priority indicators with color intensity
                const priorityColors = {
                    "critical": "var(--accent-purple)",
                    "high": "var(--accent-cyan)",
                    "medium": "var(--accent-blue)",
                    "low": "var(--text-secondary)"
                };

                services.forEach((s, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node cloud-service")
                        .attr("data-priority", s.priority)
                        .on("mouseover", (e) => {
                            showTooltip(e, s.tooltip);
                            // Highlight connected services
                            svg.selectAll(".cloud-service").style("opacity", 0.4);
                            g.style("opacity", 1.0);
                            // Highlight connections
                            svg.selectAll(".connection-line").style("opacity", 0.3);
                            svg.selectAll(`.connection-${i}`).style("opacity", 1.0).style("stroke-width", 3);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".cloud-service").style("opacity", s.opacity);
                            svg.selectAll(".connection-line").style("opacity", 0.6).style("stroke-width", 2);
                        });

                    const size = sizeMap[s.size];
                    const centerX = s.x;
                    const centerY = s.y;

                    // Add glow effect for critical services
                    if (s.priority === "critical") {
                        g.append("circle")
                            .attr("cx", centerX)
                            .attr("cy", centerY)
                            .attr("r", size.width / 2 + 10)
                            .attr("fill", "none")
                            .attr("stroke", s.color)
                            .attr("stroke-width", 2)
                            .attr("opacity", 0.3)
                            .style("filter", "blur(3px)");
                    }

                    // Draw shape based on type with enhanced gradients
                    if (s.shape === "rect") {
                        g.append("rect")
                            .attr("x", centerX - size.width / 2)
                            .attr("y", centerY - size.height / 2)
                            .attr("width", size.width)
                            .attr("height", size.height)
                            .attr("fill", `url(#${s.gradient})`)
                            .attr("rx", 8)
                            .attr("opacity", s.opacity)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                    } else if (s.shape === "diamond") {
                        const points = [
                            [centerX, centerY - size.height / 2],
                            [centerX + size.width / 2, centerY],
                            [centerX, centerY + size.height / 2],
                            [centerX - size.width / 2, centerY]
                        ].map(p => p.join(",")).join(" ");
                        g.append("polygon")
                            .attr("points", points)
                            .attr("fill", `url(#${s.gradient})`)
                            .attr("opacity", s.opacity)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                    } else if (s.shape === "circle") {
                        g.append("circle")
                            .attr("cx", centerX)
                            .attr("cy", centerY)
                            .attr("r", size.width / 2)
                            .attr("fill", `url(#${s.gradient})`)
                            .attr("opacity", s.opacity)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                    } else if (s.shape === "hexagon") {
                        const hexPoints = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60) * Math.PI / 180;
                            const x = centerX + (size.width / 2) * Math.cos(angle);
                            const y = centerY + (size.height / 2) * Math.sin(angle);
                            hexPoints.push([x, y]);
                        }
                        g.append("polygon")
                            .attr("points", hexPoints.map(p => p.join(",")).join(" "))
                            .attr("fill", `url(#${s.gradient})`)
                            .attr("opacity", s.opacity)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                    }

                    // Add performance indicator bars
                    const perfBars = g.append("g").attr("class", "performance-indicators");
                    const barWidth = 3;
                    const barHeight = 15;
                    const barSpacing = 5;

                    // Latency indicator (green = good, red = poor)
                    const latencyColor = s.performance.latency.includes("ms") && parseInt(s.performance.latency) < 100 ? "#2EC4B6" : "#FF6B6B";
                    perfBars.append("rect")
                        .attr("x", centerX + size.width / 2 + 5)
                        .attr("y", centerY - size.height / 2 + 5)
                        .attr("width", barWidth)
                        .attr("height", barHeight)
                        .attr("fill", latencyColor)
                        .attr("opacity", 0.8);

                    // Throughput indicator (blue = high, orange = medium)
                    const throughputColor = s.performance.throughput.includes("M") || s.performance.throughput.includes("TB") ? "#3A86FF" : "#FFB700";
                    perfBars.append("rect")
                        .attr("x", centerX + size.width / 2 + 5 + barWidth + barSpacing)
                        .attr("y", centerY - size.height / 2 + 5)
                        .attr("width", barWidth)
                        .attr("height", barHeight)
                        .attr("fill", throughputColor)
                        .attr("opacity", 0.8);

                    // Availability indicator (green = high, yellow = medium)
                    const availability = parseFloat(s.performance.availability.replace("%", ""));
                    const availabilityColor = availability >= 99.9 ? "#2EC4B6" : availability >= 99.0 ? "#FFB700" : "#FF6B6B";
                    perfBars.append("rect")
                        .attr("x", centerX + size.width / 2 + 5 + (barWidth + barSpacing) * 2)
                        .attr("y", centerY - size.height / 2 + 5)
                        .attr("width", barWidth)
                        .attr("height", barHeight)
                        .attr("fill", availabilityColor)
                        .attr("opacity", 0.8);

                    // Add cost indicator
                    g.append("text")
                        .attr("x", centerX)
                        .attr("y", centerY + size.height / 2 + 15)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--accent-green)")
                        .style("font-size", "8px")
                        .style("font-weight", "bold")
                        .text(s.cost);

                    // Add icon
                    g.append("text")
                        .attr("x", centerX)
                        .attr("y", centerY - 15)
                        .attr("text-anchor", "middle")
                        .style("font-size", "20px")
                        .text(s.icon);

                    // Add service name with responsive positioning to prevent overlaps
                    const nameY = centerY + (size.height / 2) + 15;
                    g.append("text")
                        .attr("x", centerX)
                        .attr("y", nameY)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", isMobile ? "10px" : "12px")
                        .style("font-weight", "bold")
                        .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.7)")
                        .text(s.name);

                    // Add subtitle with responsive positioning and collision avoidance
                    const subtitleY = nameY + (isMobile ? 12 : 15);
                    g.append("text")
                        .attr("x", centerX)
                        .attr("y", subtitleY)
                        .attr("text-anchor", "middle")
                        .attr("fill", "rgba(255,255,255,0.9)")
                        .style("font-size", isMobile ? "8px" : "9px")
                        .style("opacity", 0.8)
                        .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.7)")
                        .text(s.subtitle);

                    // Add priority indicator with enhanced visual encoding
                    g.append("circle")
                        .attr("cx", centerX + size.width / 2 - 8)
                        .attr("cy", centerY - size.height / 2 + 8)
                        .attr("r", 4)
                        .attr("fill", priorityColors[s.priority])
                        .attr("opacity", 0.8);

                    // Add complexity indicator (pre-attentive attribute)
                    const complexityColors = {
                        "low": "#2EC4B6",
                        "medium": "#FFB700",
                        "high": "#FF6B6B"
                    };
                    g.append("rect")
                        .attr("x", centerX - size.width / 2 + 5)
                        .attr("y", centerY - size.height / 2 + 5)
                        .attr("width", 8)
                        .attr("height", 3)
                        .attr("fill", complexityColors[s.complexity])
                        .attr("opacity", 0.9);

                    // Add category indicator (shape-based encoding)
                    const categoryShapes = {
                        "storage": "rect",
                        "processing": "diamond",
                        "compute": "circle",
                        "inference": "hexagon",
                        "interface": "rect"
                    };

                    // Add category badge
                    g.append("text")
                        .attr("x", centerX - size.width / 2 + 15)
                        .attr("y", centerY + size.height / 2 - 5)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "7px")
                        .style("font-weight", "500")
                        .style("text-transform", "uppercase")
                        .text(s.category);

                    // Add compliance badges (pre-attentive color encoding)
                    s.compliance.forEach((compliance, idx) => {
                        const badgeColors = {
                            "SOC2": "#2EC4B6",
                            "HIPAA": "#3A86FF",
                            "GDPR": "#8338EC",
                            "ISO27001": "#FFB700",
                            "PCI-DSS": "#FF6B6B"
                        };

                        g.append("circle")
                            .attr("cx", centerX + size.width / 2 - 15 - (idx * 8))
                            .attr("cy", centerY + size.height / 2 - 8)
                            .attr("r", 3)
                            .attr("fill", badgeColors[compliance] || "#8E8E93")
                            .attr("opacity", 0.8)
                            .on("mouseover", (e) => {
                                showTooltip(e, `<b>${compliance}</b><br>Compliance certification for security and data protection standards`);
                            })
                            .on("mouseout", hideTooltip);
                    });
                });

                // Enhanced flow arrows with data flow indicators
                const connections = [
                    { from: 0, to: 1, label: "Raw Data", flow: "high" },
                    { from: 1, to: 2, label: "Processed Data", flow: "medium" },
                    { from: 2, to: 3, label: "Trained Model", flow: "high" },
                    { from: 3, to: 4, label: "Predictions", flow: "high" }
                ];

                connections.forEach((conn, idx) => {
                    const s = services[conn.from];
                    const t = services[conn.to];
                    const midX = (s.x + t.x) / 2;
                    const midY = (s.y + t.y) / 2 - 20;

                    // Enhanced connection line with improved visual hierarchy
                    const path = svg.append("path")
                        .attr("class", `connection-line connection-${conn.from}`)
                        .attr("d", `M ${s.x} ${s.y} Q ${midX} ${midY} ${t.x} ${t.y}`)
                        .attr("stroke", conn.flow === "high" ? "var(--accent-cyan)" : "var(--accent-purple)")
                        .attr("fill", "none")
                        .attr("stroke-width", conn.flow === "high" ? 4 : 2.5)
                        .attr("opacity", 0.7)
                        .attr("marker-end", "url(#arrow-cloud)")
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                    // Add flow animation
                    const pathLength = path.node().getTotalLength();
                    path.attr("stroke-dasharray", `${pathLength} ${pathLength}`)
                        .attr("stroke-dashoffset", pathLength)
                        .transition()
                        .duration(2000)
                        .delay(idx * 500)
                        .attr("stroke-dashoffset", 0);

                    // Add flow label with improved positioning and background
                    const labelBg = svg.append("rect")
                        .attr("x", midX - 25)
                        .attr("y", midY - 18)
                        .attr("width", 50)
                        .attr("height", 16)
                        .attr("fill", "rgba(0,0,0,0.7)")
                        .attr("rx", 8)
                        .attr("opacity", 0.8);
                    
                    svg.append("text")
                        .attr("x", midX)
                        .attr("y", midY - 8)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", isMobile ? "8px" : "10px")
                        .style("font-weight", "600")
                        .style("font-family", "Inter, system-ui, sans-serif")
                        .style("text-shadow", "1px 1px 2px rgba(0,0,0,0.8)")
                        .text(conn.label);

                    // Add flow intensity indicator
                    const intensity = conn.flow === "high" ? 3 : 2;
                    for (let i = 0; i < intensity; i++) {
                        svg.append("circle")
                            .attr("cx", midX + (i - intensity / 2) * 8)
                            .attr("cy", midY + 15)
                            .attr("r", 2)
                            .attr("fill", conn.flow === "high" ? "var(--accent-cyan)" : "var(--accent-purple)")
                            .attr("opacity", 0.6);
                    }
                });

                // Enhanced legend with performance indicators and compliance badges
                const legend = svg.append("g").attr("class", "legend").attr("transform", `translate(${width - 180}, 20)`);

                // Service Priority Legend
                legend.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Service Priority");

                const legendItems = [
                    { priority: "critical", label: "Critical", y: 20 },
                    { priority: "high", label: "High", y: 40 },
                    { priority: "medium", label: "Medium", y: 60 }
                ];

                legendItems.forEach(item => {
                    legend.append("circle")
                        .attr("cx", 5)
                        .attr("cy", item.y)
                        .attr("r", 4)
                        .attr("fill", priorityColors[item.priority]);

                    legend.append("text")
                        .attr("x", 15)
                        .attr("y", item.y + 2)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(item.label);
                });

                // Performance Indicators Legend
                legend.append("text")
                    .attr("x", 0)
                    .attr("y", 90)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Performance");

                // Complexity Legend
                legend.append("text")
                    .attr("x", 0)
                    .attr("y", 140)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Complexity");

                const complexityLegend = [
                    { complexity: "low", label: "Low", y: 160, color: "#2EC4B6" },
                    { complexity: "medium", label: "Medium", y: 180, color: "#FFB700" },
                    { complexity: "high", label: "High", y: 200, color: "#FF6B6B" }
                ];

                complexityLegend.forEach(item => {
                    legend.append("rect")
                        .attr("x", 5)
                        .attr("y", item.y - 2)
                        .attr("width", 8)
                        .attr("height", 3)
                        .attr("fill", item.color);

                    legend.append("text")
                        .attr("x", 18)
                        .attr("y", item.y + 1)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(item.label);
                });

                // Category Legend
                legend.append("text")
                    .attr("x", 0)
                    .attr("y", 230)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Categories");

                const categoryLegend = [
                    { category: "storage", label: "Storage", y: 250, shape: "ellipse", color: "var(--color-storage)" },
                    { category: "processing", label: "Processing", y: 270, shape: "circle", color: "var(--color-processing)" },
                    { category: "compute", label: "Compute", y: 290, shape: "circle", color: "var(--color-compute)" },
                    { category: "inference", label: "Inference", y: 310, shape: "hexagon", color: "var(--color-inference)" },
                    { category: "interface", label: "Interface", y: 330, shape: "rect", color: "var(--color-interface)" }
                ];

                categoryLegend.forEach(item => {
                    if (item.shape === "rect") {
                        legend.append("rect")
                            .attr("x", 5)
                            .attr("y", item.y - 4)
                            .attr("width", 8)
                            .attr("height", 6)
                            .attr("fill", item.color)
                            .attr("opacity", 0.7);
                    } else if (item.shape === "diamond") {
                        const points = [[9, item.y - 4], [13, item.y - 1], [9, item.y + 2], [5, item.y - 1]].map(p => p.join(",")).join(" ");
                        legend.append("polygon")
                            .attr("points", points)
                            .attr("fill", item.color)
                            .attr("opacity", 0.7);
                    } else if (item.shape === "circle") {
                        legend.append("circle")
                            .attr("cx", 9)
                            .attr("cy", item.y - 1)
                            .attr("r", 3)
                            .attr("fill", item.color)
                            .attr("opacity", 0.7);
                    } else if (item.shape === "hexagon") {
                        const hexPoints = [];
                        for (let j = 0; j < 6; j++) {
                            const angle = (j * 60) * Math.PI / 180;
                            const x = 9 + 3 * Math.cos(angle);
                            const y = item.y - 1 + 3 * Math.sin(angle);
                            hexPoints.push([x, y]);
                        }
                        legend.append("polygon")
                            .attr("points", hexPoints.map(p => p.join(",")).join(" "))
                            .attr("fill", item.color)
                            .attr("opacity", 0.7);
                    }

                    legend.append("text")
                        .attr("x", 18)
                        .attr("y", item.y + 1)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(item.label);
                });

                const perfLegend = [
                    { color: "#2EC4B6", label: "Latency", y: 110 },
                    { color: "#3A86FF", label: "Throughput", y: 130 },
                    { color: "#2EC4B6", label: "Availability", y: 150 }
                ];

                perfLegend.forEach(item => {
                    legend.append("rect")
                        .attr("x", 5)
                        .attr("y", item.y - 8)
                        .attr("width", 3)
                        .attr("height", 15)
                        .attr("fill", item.color)
                        .attr("opacity", 0.8);

                    legend.append("text")
                        .attr("x", 15)
                        .attr("y", item.y + 2)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "9px")
                        .text(item.label);
                });

                // Add animated performance summary dashboard
                const dashboard = svg.append("g").attr("class", "performance-dashboard").attr("transform", `translate(20, ${height - 80})`);

                // Dashboard background
                dashboard.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", 300)
                    .attr("height", 60)
                    .attr("fill", "rgba(27, 38, 59, 0.8)")
                    .attr("stroke", "var(--primary-border)")
                    .attr("rx", 8)
                    .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                // Dashboard title
                dashboard.append("text")
                    .attr("x", 10)
                    .attr("y", 15)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Cloud-Native Performance Summary");

                // Calculate aggregate metrics
                const avgLatency = services.reduce((sum, s) => {
                    const latency = s.performance.latency.includes("ms") ? parseInt(s.performance.latency) : 1000;
                    return sum + latency;
                }, 0) / services.length;

                const totalThroughput = services.reduce((sum, s) => {
                    const throughput = s.performance.throughput.includes("M") ? 1000000 :
                        s.performance.throughput.includes("TB") ? 1000000000 : 1000;
                    return sum + throughput;
                }, 0);

                const avgAvailability = services.reduce((sum, s) => {
                    return sum + parseFloat(s.performance.availability.replace("%", ""));
                }, 0) / services.length;

                // Display metrics
                dashboard.append("text")
                    .attr("x", 10)
                    .attr("y", 30)
                    .attr("fill", "var(--accent-cyan)")
                    .style("font-size", "9px")
                    .text(`Avg Latency: ${Math.round(avgLatency)}ms`);

                dashboard.append("text")
                    .attr("x", 10)
                    .attr("y", 45)
                    .attr("fill", "var(--accent-blue)")
                    .style("font-size", "9px")
                    .text(`Total Throughput: ${(totalThroughput / 1000000).toFixed(1)}M ops/s`);

                dashboard.append("text")
                    .attr("x", 10)
                    .attr("y", 60)
                    .attr("fill", "var(--accent-green)")
                    .style("font-size", "9px")
                    .text(`Avg Availability: ${avgAvailability.toFixed(1)}%`);

                // Add animated sparkline for system health
                const sparkline = dashboard.append("g").attr("class", "sparkline").attr("transform", "translate(200, 20)");
                const sparklineData = [0.8, 0.9, 0.85, 0.95, 0.9, 0.88, 0.92, 0.89, 0.91, 0.94];
                const sparklinePath = sparklineData.map((d, i) => `${i * 8},${(1 - d) * 20}`).join(" L");

                sparkline.append("path")
                    .attr("d", `M ${sparklinePath}`)
                    .attr("stroke", "var(--accent-green)")
                    .attr("stroke-width", 2)
                    .attr("fill", "none")
                    .attr("opacity", 0.8)
                    .style("animation", "sparklinePulse 2s ease-in-out infinite");

                sparkline.append("text")
                    .attr("x", 0)
                    .attr("y", 35)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "8px")
                    .text("System Health");
            }

            /** Renders the Multimodal Data & Perception ETL pipeline visualization with competition-level enhancements. */
            function renderMultimodalDataViz() {
                const container = d3.select("#multimodal-data-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 40 : isTablet ? 45 : 50, 
                    right: isMobile ? 30 : isTablet ? 35 : 40, 
                    bottom: isMobile ? 40 : isTablet ? 45 : 50, 
                    left: isMobile ? 30 : isTablet ? 35 : 40 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers with multiple colors
                arrowMarker(svg, "arrow-multimodal", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-multimodal-green", "var(--accent-green)");
                arrowMarker(svg, "arrow-multimodal-purple", "var(--accent-purple)");

                // Create gradient definitions for visual enhancement
                const defs = svg.append("defs");

                // Data processing gradients
                const gradients = [
                    { id: "pdf-gradient", color: "var(--accent-blue)" },
                    { id: "image-gradient", color: "var(--accent-cyan)" },
                    { id: "audio-gradient", color: "var(--accent-green)" },
                    { id: "etl-gradient", color: "var(--accent-purple)" },
                    { id: "vector-gradient", color: "var(--accent-purple)" }
                ];

                gradients.forEach(grad => {
                    const gradient = defs.append("linearGradient")
                        .attr("id", grad.id)
                        .attr("x1", "0%").attr("y1", "0%")
                        .attr("x2", "100%").attr("y2", "100%");

                    gradient.append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", grad.color)
                        .attr("stop-opacity", 0.8);

                    gradient.append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", grad.color)
                        .attr("stop-opacity", 0.4);
                });

                // Responsive sizing calculation functions
                const calculateDataNodeSize = (baseRadius, containerWidth, containerHeight) => {
                    const scaleFactor = Math.min(containerWidth / 800, containerHeight / 600, 1.2);
                    return Math.max(baseRadius * scaleFactor, baseRadius * 0.7);
                };

                const calculateComponentSize = (baseWidth, baseHeight, containerWidth, containerHeight) => {
                    const scaleFactor = Math.min(containerWidth / 800, containerHeight / 600, 1.2);
                    return {
                        width: Math.max(baseWidth * scaleFactor, baseWidth * 0.7),
                        height: Math.max(baseHeight * scaleFactor, baseHeight * 0.7)
                    };
                };

                // Enhanced input data with responsive positioning and processing complexity
                const inputData = [
                    {
                        icon: "📄",
                        label: "PDFs",
                        x: isMobile ? width * 0.15 : width * 0.1,
                        y: height * 0.2,
                        process: "OCR",
                        complexity: "high",
                        processingTime: "2.3s",
                        accuracy: "94%",
                        color: "var(--accent-blue)",
                        tooltip: "<b>PDF Processing</b><br>Advanced OCR with layout understanding, table extraction, and semantic structure preservation. Supports multi-column documents, mathematical formulas, and maintains document hierarchy for improved retrieval accuracy.<br><br><b>Performance:</b><br>• Processing Time: 2.3s per page<br>• Accuracy: 94%<br>• Complexity: High (layout analysis)"
                    },
                    {
                        icon: "🖼️",
                        label: "Images",
                        x: isMobile ? width * 0.15 : width * 0.1,
                        y: height * 0.5,
                        process: "Vision",
                        complexity: "medium",
                        processingTime: "1.8s",
                        accuracy: "89%",
                        color: "var(--accent-cyan)",
                        tooltip: "<b>Vision Processing</b><br>Computer vision models for image understanding, scene detection, and visual question answering. Integrates with vision-language models like CLIP and LLaVA for comprehensive multimodal reasoning capabilities.<br><br><b>Performance:</b><br>• Processing Time: 1.8s per image<br>• Accuracy: 89%<br>• Complexity: Medium (object detection)"
                    },
                    {
                        icon: "🎵",
                        label: "Audio",
                        x: isMobile ? width * 0.15 : width * 0.1,
                        y: height * 0.8,
                        process: "Transcription",
                        complexity: "high",
                        processingTime: "3.1s",
                        accuracy: "96%",
                        color: "var(--accent-green)",
                        tooltip: "<b>Audio Processing</b><br>Advanced speech-to-text with speaker diarization, emotion detection, and temporal segmentation. Supports real-time streaming transcription with noise reduction and multi-language capabilities for global applications.<br><br><b>Performance:</b><br>• Processing Time: 3.1s per minute<br>• Accuracy: 96%<br>• Complexity: High (speaker diarization)"
                    }
                ];

                const etlX = isMobile ? width * 0.5 : width * 0.45;
                const vectorDbX = isMobile ? width * 0.85 : width * 0.8;

                // Enhanced input data visualization with responsive performance indicators
                inputData.forEach((d, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node multimodal-input")
                        .attr("data-complexity", d.complexity)
                        .on("mouseover", (e) => {
                            showTooltip(e, d.tooltip);
                            // Highlight related processing flow
                            svg.selectAll(".multimodal-input").style("opacity", 0.4);
                            g.style("opacity", 1.0);
                            svg.selectAll(`.flow-${i}`).style("opacity", 1.0).style("stroke-width", isMobile ? 2.5 : 3);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".multimodal-input").style("opacity", 1.0);
                            svg.selectAll(".flow-line").style("opacity", 0.6).style("stroke-width", isMobile ? 1.5 : 2);
                        });

                    // Calculate responsive node sizing
                    const baseRadius = 40;
                    const nodeRadius = calculateDataNodeSize(baseRadius, width, height);
                    const complexityRadius = calculateDataNodeSize(
                        d.complexity === "high" ? 50 : d.complexity === "medium" ? 45 : 40, 
                        width, height
                    );

                    // Main processing node with responsive gradient
                    g.append("circle")
                        .attr("cx", d.x)
                        .attr("cy", d.y)
                        .attr("r", nodeRadius)
                        .attr("fill", `url(#${d.process.toLowerCase()}-gradient)`)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Complexity indicator (outer ring) with responsive sizing
                    g.append("circle")
                        .attr("cx", d.x)
                        .attr("cy", d.y)
                        .attr("r", complexityRadius)
                        .attr("fill", "none")
                        .attr("stroke", d.color)
                        .attr("stroke-width", isMobile ? 2.5 : 3)
                        .attr("opacity", 0.6);

                    // Icon with responsive sizing
                    g.append("text")
                        .attr("x", d.x)
                        .attr("y", d.y - (isMobile ? 3 : 5))
                        .attr("text-anchor", "middle")
                        .style("font-size", isMobile ? "18px" : "24px")
                        .text(d.icon);

                    // Label with responsive positioning
                    g.append("text")
                        .attr("x", d.x)
                        .attr("y", d.y + complexityRadius + (isMobile ? 12 : 15))
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", isMobile ? "10px" : "12px")
                        .style("font-weight", "bold")
                        .text(d.label);

                    // Performance metrics with responsive positioning
                    g.append("text")
                        .attr("x", d.x)
                        .attr("y", d.y + complexityRadius + (isMobile ? 25 : 30))
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", isMobile ? "7px" : "9px")
                        .text(`${d.processingTime} • ${d.accuracy}`);

                    // Enhanced flow arrows with data volume indicators
                    const arrow = svg.append("path")
                        .attr("class", `flow-line flow-${i}`)
                        .attr("d", `M ${d.x + 40} ${d.y} Q ${(d.x + etlX) / 2} ${d.y - 20} ${etlX - 60} ${height / 2}`)
                        .attr("stroke", d.color)
                        .attr("fill", "none")
                        .attr("stroke-width", 2)
                        .attr("opacity", 0.6)
                        .attr("marker-end", `url(#arrow-multimodal${i === 0 ? '' : i === 1 ? '-green' : '-purple'})`);

                    // Animate data flow
                    const pathLength = arrow.node().getTotalLength();
                    arrow.attr("stroke-dasharray", `${pathLength} ${pathLength}`)
                        .attr("stroke-dashoffset", pathLength)
                        .transition()
                        .duration(2000)
                        .delay(i * 300)
                        .attr("stroke-dashoffset", 0);

                    // Data volume indicators along the flow
                    const volumeIndicators = d.complexity === "high" ? 4 : d.complexity === "medium" ? 3 : 2;
                    for (let j = 0; j < volumeIndicators; j++) {
                        const t = (j + 1) / (volumeIndicators + 1);
                        const point = arrow.node().getPointAtLength(pathLength * t);
                        svg.append("circle")
                            .attr("cx", point.x)
                            .attr("cy", point.y)
                            .attr("r", 3)
                            .attr("fill", d.color)
                            .attr("opacity", 0.7)
                            .transition()
                            .delay(i * 300 + j * 200)
                            .duration(500)
                            .attr("r", 5)
                            .transition()
                            .duration(500)
                            .attr("r", 3);
                    }
                });

                // Enhanced ETL Processing Box with animated processing indicators
                const etlGroup = svg.append("g").attr("class", "etl-processing");

                etlGroup.append("rect")
                    .attr("x", etlX - 60)
                    .attr("y", height / 2 - 50)
                    .attr("width", 120)
                    .attr("height", 100)
                    .attr("fill", "url(#etl-gradient)")
                    .attr("rx", 12)
                    .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");

                // Processing animation indicators
                for (let i = 0; i < 3; i++) {
                    etlGroup.append("circle")
                        .attr("cx", etlX - 30 + i * 30)
                        .attr("cy", height / 2 - 20)
                        .attr("r", 4)
                        .attr("fill", "var(--accent-cyan)")
                        .attr("opacity", 0.8)
                        .transition()
                        .delay(i * 200)
                        .duration(1000)
                        .attr("r", 8)
                        .attr("opacity", 0.3)
                        .transition()
                        .duration(1000)
                        .attr("r", 4)
                        .attr("opacity", 0.8);
                }

                etlGroup.append("text")
                    .attr("x", etlX)
                    .attr("y", height / 2 - 5)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-weight", "bold")
                    .style("font-size", "14px")
                    .text("ETL &");

                etlGroup.append("text")
                    .attr("x", etlX)
                    .attr("y", height / 2 + 15)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-weight", "bold")
                    .style("font-size", "14px")
                    .text("Embedding");

                etlGroup.append("text")
                    .attr("x", etlX)
                    .attr("y", height / 2 + 35)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", "10px")
                    .style("opacity", 0.8)
                    .text("Processing Pipeline");

                // Enhanced Vector Database with storage indicators
                const vectorGroup = svg.append("g").attr("class", "vector-database");

                vectorGroup.append("rect")
                    .attr("x", vectorDbX - 60)
                    .attr("y", height / 2 - 35)
                    .attr("width", 120)
                    .attr("height", 70)
                    .attr("fill", "url(#vector-gradient)")
                    .attr("rx", 12)
                    .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");

                // Storage capacity indicator
                vectorGroup.append("rect")
                    .attr("x", vectorDbX - 50)
                    .attr("y", height / 2 + 20)
                    .attr("width", 100)
                    .attr("height", 8)
                    .attr("fill", "var(--primary-border)")
                    .attr("rx", 4);

                vectorGroup.append("rect")
                    .attr("x", vectorDbX - 50)
                    .attr("y", height / 2 + 20)
                    .attr("width", 75)
                    .attr("height", 8)
                    .attr("fill", "var(--accent-cyan)")
                    .attr("rx", 4)
                    .transition()
                    .duration(2000)
                    .delay(1000)
                    .attr("width", 75);

                vectorGroup.append("text")
                    .attr("x", vectorDbX)
                    .attr("y", height / 2 - 5)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-weight", "bold")
                    .style("font-size", "14px")
                    .text("Vector DB");

                vectorGroup.append("text")
                    .attr("x", vectorDbX)
                    .attr("y", height / 2 + 15)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", "10px")
                    .style("opacity", "0.8")
                    .text("75% Capacity");

                // Enhanced ETL to Vector DB arrow with data flow animation
                const mainFlow = svg.append("path")
                    .attr("class", "main-flow")
                    .attr("d", `M ${etlX + 60} ${height / 2} Q ${(etlX + vectorDbX) / 2} ${height / 2 - 30} ${vectorDbX - 60} ${height / 2}`)
                    .attr("stroke", "var(--accent-purple)")
                    .attr("fill", "none")
                    .attr("stroke-width", 4)
                    .attr("opacity", 0.8)
                    .attr("marker-end", "url(#arrow-multimodal-purple)");

                // Animate main data flow
                const mainFlowLength = mainFlow.node().getTotalLength();
                mainFlow.attr("stroke-dasharray", `${mainFlowLength} ${mainFlowLength}`)
                    .attr("stroke-dashoffset", mainFlowLength)
                    .transition()
                    .duration(3000)
                    .delay(1500)
                    .attr("stroke-dashoffset", 0);

                // Add processing statistics
                const stats = svg.append("g").attr("class", "processing-stats").attr("transform", `translate(${width - 120}, 20)`);

                stats.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Processing Stats");

                const statItems = [
                    { label: "Total Files", value: "1,247", y: 20 },
                    { label: "Avg. Processing", value: "2.4s", y: 40 },
                    { label: "Success Rate", value: "96.8%", y: 60 }
                ];

                statItems.forEach(item => {
                    stats.append("text")
                        .attr("x", 0)
                        .attr("y", item.y)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(`${item.label}: ${item.value}`);
                });
            }

            /** Renders the LLMOps & Observability metrics dashboard visualization with sophisticated design and responsive layout. */
            function renderLLMOpsObservabilityViz() {
                const container = d3.select("#llmops-observability-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;

                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = {
                    top: isMobile ? 40 : isTablet ? 45 : 50,
                    right: isMobile ? 20 : isTablet ? 25 : 30,
                    bottom: isMobile ? 40 : isTablet ? 45 : 50,
                    left: isMobile ? 20 : isTablet ? 25 : 30
                };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Create gradient definitions for sophisticated visual effects
                const defs = svg.append("defs");

                // Dashboard background gradient
                const bgGradient = defs.append("linearGradient")
                    .attr("id", "dashboard-bg")
                    .attr("x1", "0%").attr("y1", "0%")
                    .attr("x2", "100%").attr("y2", "100%");

                bgGradient.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", "var(--primary-border)")
                    .attr("stop-opacity", 0.1);

                bgGradient.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", "var(--secondary-border)")
                    .attr("stop-opacity", 0.05);

                // Add dashboard background
                svg.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", width)
                    .attr("height", height)
                    .attr("fill", "url(#dashboard-bg)")
                    .attr("rx", 12);

                // Enhanced metrics with performance indicators and responsive positioning
                const calculateMetricPositions = (metricsCount, isMobile, isTablet, width, height) => {
                    if (isMobile) {
                        // Mobile: Stack metrics vertically with smaller spacing
                        return [
                            { x: width * 0.5, y: height * 0.15 },  // Latency
                            { x: width * 0.5, y: height * 0.32 },  // Token Cost
                            { x: width * 0.5, y: height * 0.49 },  // Cache Hit
                            { x: width * 0.5, y: height * 0.66 },  // User Feedback
                            { x: width * 0.5, y: height * 0.83 }   // Prompt Version
                        ];
                    } else if (isTablet) {
                        // Tablet: 2x3 grid layout
                        return [
                            { x: width * 0.3, y: height * 0.25 },  // Latency
                            { x: width * 0.7, y: height * 0.25 },  // Token Cost
                            { x: width * 0.3, y: height * 0.5 },   // Cache Hit
                            { x: width * 0.7, y: height * 0.5 },   // User Feedback
                            { x: width * 0.5, y: height * 0.75 }   // Prompt Version
                        ];
                    } else {
                        // Desktop: Original 3+2 layout
                        return [
                            { x: width * 0.2, y: height * 0.25 },  // Latency
                            { x: width * 0.5, y: height * 0.25 },  // Token Cost
                            { x: width * 0.8, y: height * 0.25 },  // Cache Hit
                            { x: width * 0.35, y: height * 0.75 }, // User Feedback
                            { x: width * 0.65, y: height * 0.75 }  // Prompt Version
                        ];
                    }
                };

                const metricPositions = calculateMetricPositions(5, isMobile, isTablet, width, height);
                const metrics = [
                    {
                        name: "Latency",
                        value: "240ms",
                        icon: "⏱️",
                        x: metricPositions[0].x,
                        y: metricPositions[0].y,
                        trend: "down",
                        change: "-12%",
                        status: "good",
                        color: "var(--accent-green)",
                        tooltip: "<b>Response Latency</b><br>Average time from request to response completion.<br><br><b>Current:</b> 240ms<br><b>Trend:</b> ↓ 12% improvement<br><b>Status:</b> Within SLA (≤300ms)<br><b>Peak:</b> 320ms (yesterday 2PM)"
                    },
                    {
                        name: "Token Cost",
                        value: "$0.03",
                        icon: "💰",
                        x: metricPositions[1].x,
                        y: metricPositions[1].y,
                        trend: "down",
                        change: "-8%",
                        status: "good",
                        color: "var(--accent-cyan)",
                        tooltip: "<b>Token Cost per Request</b><br>Average cost for input/output tokens.<br><br><b>Current:</b> $0.03<br><b>Trend:</b> ↓ 8% cost reduction<br><b>Status:</b> Under budget<br><b>Monthly:</b> $2,340 (target: $2,500)"
                    },
                    {
                        name: "Cache Hit",
                        value: "85%",
                        icon: "🎯",
                        x: metricPositions[2].x,
                        y: metricPositions[2].y,
                        trend: "up",
                        change: "+5%",
                        status: "excellent",
                        color: "var(--accent-purple)",
                        tooltip: "<b>Cache Hit Rate</b><br>Percentage of requests served from cache.<br><br><b>Current:</b> 85%<br><b>Trend:</b> ↑ 5% improvement<br><b>Status:</b> Excellent (>80%)<br><b>Impact:</b> 40% latency reduction"
                    },
                    {
                        name: "User Feedback",
                        value: "4.2/5",
                        icon: "👍",
                        x: metricPositions[3].x,
                        y: metricPositions[3].y,
                        trend: "up",
                        change: "+0.3",
                        status: "good",
                        color: "var(--accent-blue)",
                        tooltip: "<b>User Satisfaction</b><br>Average user rating for AI responses.<br><br><b>Current:</b> 4.2/5<br><b>Trend:</b> ↑ +0.3 improvement<br><b>Status:</b> Good (>4.0)<br><b>Sample:</b> 1,247 responses"
                    },
                    {
                        name: "Prompt Version",
                        value: "v2.1",
                        icon: "📝",
                        x: metricPositions[4].x,
                        y: metricPositions[4].y,
                        trend: "stable",
                        change: "0%",
                        status: "stable",
                        color: "var(--accent-green)",
                        tooltip: "<b>Active Prompt Version</b><br>Currently deployed prompt template.<br><br><b>Current:</b> v2.1<br><b>Trend:</b> Stable (no changes)<br><b>Status:</b> Production ready<br><b>Deployed:</b> 3 days ago"
                    }
                ];

                // Create metric gradients
                metrics.forEach((m, i) => {
                    const gradient = defs.append("radialGradient")
                        .attr("id", `metric-gradient-${i}`)
                        .attr("cx", "50%").attr("cy", "30%");

                    gradient.append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", m.color)
                        .attr("stop-opacity", 0.8);

                    gradient.append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", m.color)
                        .attr("stop-opacity", 0.3);
                });

                // Calculate responsive sizing based on screen size and metric density
                const calculateMetricSizing = (isMobile, isTablet, metricCount) => {
                    if (isMobile) {
                        return {
                            radius: 30,
                            statusRadius: 34,
                            iconSize: "16px",
                            nameSize: "8px",
                            valueSize: "10px",
                            trendSize: "12px",
                            trendOffset: 25,
                            sparklineOffset: 20,
                            sparklineScale: 0.8
                        };
                    } else if (isTablet) {
                        return {
                            radius: 35,
                            statusRadius: 40,
                            iconSize: "18px",
                            nameSize: "9px",
                            valueSize: "11px",
                            trendSize: "14px",
                            trendOffset: 28,
                            sparklineOffset: 25,
                            sparklineScale: 0.9
                        };
                    } else {
                        return {
                            radius: 45,
                            statusRadius: 50,
                            iconSize: "24px",
                            nameSize: "11px",
                            valueSize: "13px",
                            trendSize: "16px",
                            trendOffset: 35,
                            sparklineOffset: 30,
                            sparklineScale: 1.0
                        };
                    }
                };

                const sizing = calculateMetricSizing(isMobile, isTablet, metrics.length);

                // Enhanced metric visualization with responsive design
                metrics.forEach((m, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node metric-card")
                        .attr("data-status", m.status)
                        .on("mouseover", (e) => {
                            showTooltip(e, m.tooltip);
                            // Highlight related metrics
                            svg.selectAll(".metric-card").style("opacity", 0.4);
                            g.style("opacity", 1.0);
                            // Show trend indicators
                            svg.selectAll(".trend-indicator").style("opacity", 0.3);
                            g.selectAll(".trend-indicator").style("opacity", 1.0);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".metric-card").style("opacity", 1.0);
                            svg.selectAll(".trend-indicator").style("opacity", 0.6);
                        });

                    // Main metric circle with responsive sizing
                    g.append("circle")
                        .attr("cx", m.x)
                        .attr("cy", m.y)
                        .attr("r", sizing.radius)
                        .attr("fill", `url(#metric-gradient-${i})`)
                        .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.3))");

                    // Status indicator ring with responsive sizing
                    const statusColors = {
                        "excellent": "var(--accent-purple)",
                        "good": "var(--accent-green)",
                        "stable": "var(--accent-cyan)",
                        "warning": "var(--accent-blue)"
                    };

                    g.append("circle")
                        .attr("cx", m.x)
                        .attr("cy", m.y)
                        .attr("r", sizing.statusRadius)
                        .attr("fill", "none")
                        .attr("stroke", statusColors[m.status])
                        .attr("stroke-width", isMobile ? 2 : 3)
                        .attr("opacity", 0.6);

                    // Icon with responsive sizing
                    g.append("text")
                        .attr("x", m.x)
                        .attr("y", m.y - (isMobile ? 6 : 10))
                        .attr("text-anchor", "middle")
                        .style("font-size", sizing.iconSize)
                        .text(m.icon);

                    // Metric name with responsive sizing
                    g.append("text")
                        .attr("x", m.x)
                        .attr("y", m.y + (isMobile ? 6 : 10))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", sizing.nameSize)
                        .style("font-weight", "bold")
                        .text(m.name);

                    // Metric value with responsive sizing
                    g.append("text")
                        .attr("x", m.x)
                        .attr("y", m.y + (isMobile ? 18 : 25))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", sizing.valueSize)
                        .style("font-weight", "bold")
                        .text(m.value);

                    // Trend indicator with responsive positioning
                    const trendIcon = m.trend === "up" ? "↗" : m.trend === "down" ? "↘" : "→";
                    const trendColor = m.trend === "up" ? "var(--accent-green)" : m.trend === "down" ? "var(--accent-cyan)" : "var(--text-secondary)";

                    g.append("text")
                        .attr("class", "trend-indicator")
                        .attr("x", m.x + sizing.trendOffset)
                        .attr("y", m.y - (isMobile ? 15 : 25))
                        .attr("text-anchor", "middle")
                        .attr("fill", trendColor)
                        .style("font-size", sizing.trendSize)
                        .style("font-weight", "bold")
                        .text(trendIcon);

                    // Change percentage with responsive positioning
                    g.append("text")
                        .attr("class", "trend-indicator")
                        .attr("x", m.x + sizing.trendOffset)
                        .attr("y", m.y - (isMobile ? 4 : 10))
                        .attr("text-anchor", "middle")
                        .attr("fill", trendColor)
                        .style("font-size", isMobile ? "8px" : "10px")
                        .style("font-weight", "bold")
                        .text(m.change);

                    // Performance sparkline with responsive scaling
                    if (!isMobile) { // Hide sparklines on mobile for clarity
                    const sparklineData = [0.8, 0.9, 0.7, 0.85, 0.95, 0.9, 1.0];
                        const sparklineOffset = sizing.sparklineOffset;
                    const sparklinePath = sparklineData.map((d, idx) => {
                            const x = m.x - sparklineOffset + (idx * (6 * sizing.sparklineScale));
                            const y = m.y + (isMobile ? 30 : 40) - (d * 15 * sizing.sparklineScale);
                        return `${idx === 0 ? 'M' : 'L'} ${x} ${y}`;
                    }).join(' ');

                    g.append("path")
                        .attr("d", sparklinePath)
                        .attr("fill", "none")
                        .attr("stroke", m.color)
                            .attr("stroke-width", isTablet ? 1.5 : 2)
                        .attr("opacity", 0.7);
                    }
                });

                // Dashboard title with responsive sizing
                const titleFontSize = isMobile ? "14px" : isTablet ? "16px" : "18px";
                const titleY = isMobile ? 20 : 25;

                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", titleY)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-primary)")
                    .style("font-weight", "bold")
                    .style("font-size", titleFontSize)
                    .text("LLMOps Dashboard");

                // Real-time indicator with responsive positioning
                const indicatorSize = isMobile ? 3 : 4;
                const indicatorOffset = isMobile ? 15 : 20;

                svg.append("circle")
                    .attr("cx", width - indicatorOffset)
                    .attr("cy", titleY)
                    .attr("r", indicatorSize)
                    .attr("fill", "var(--accent-green)")
                    .attr("opacity", 0.8)
                    .transition()
                    .duration(1000)
                    .attr("opacity", 0.3)
                    .transition()
                    .duration(1000)
                    .attr("opacity", 0.8);

                svg.append("text")
                    .attr("x", width - (indicatorOffset + 15))
                    .attr("y", titleY + 5)
                    .attr("text-anchor", "end")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", isMobile ? "8px" : "10px")
                    .text("Live");

                // System health indicator with responsive sizing
                const healthWidth = isMobile ? 60 : isTablet ? 70 : 80;
                const healthHeight = isMobile ? 16 : 20;
                const healthX = isMobile ? width - healthWidth - 5 : width - 100;
                const healthY = isMobile ? height - 25 : height - 30;

                const healthStatus = svg.append("g")
                    .attr("class", "health-status")
                    .attr("transform", `translate(${healthX}, ${healthY})`);

                healthStatus.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", healthWidth)
                    .attr("height", healthHeight)
                    .attr("fill", "var(--primary-border)")
                    .attr("rx", isMobile ? 8 : 10);

                healthStatus.append("text")
                    .attr("x", healthWidth / 2)
                    .attr("y", healthHeight / 2 + (isMobile ? 3 : 3))
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-green)")
                    .style("font-size", isMobile ? "8px" : "10px")
                    .style("font-weight", "bold")
                    .text(isMobile ? "Healthy" : "System Healthy");

                // Performance summary with responsive positioning
                const summaryX = isMobile ? 10 : 20;
                const summaryY = isMobile ? height - 25 : height - 30;
                const summaryFontSize = isMobile ? "8px" : "10px";

                const summary = svg.append("g")
                    .attr("class", "performance-summary")
                    .attr("transform", `translate(${summaryX}, ${summaryY})`);

                summary.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", summaryFontSize)
                    .text(isMobile ? "24h:" : "Last 24h:");

                summary.append("text")
                    .attr("x", isMobile ? 25 : 50)
                    .attr("y", 0)
                    .attr("fill", "var(--accent-green)")
                    .style("font-size", summaryFontSize)
                    .style("font-weight", "bold")
                    .text(isMobile ? "↑12%" : "↑ 12% performance improvement");
            }

            /** Renders the LLM Evaluation Harnesses quadrant chart visualization with Tableau Jedi Master techniques and responsive design. */
            function renderLLMEvalViz() {
                const container = d3.select("#llm-eval-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;

                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = {
                    top: isMobile ? 40 : isTablet ? 50 : 60,
                    right: isMobile ? 30 : isTablet ? 45 : 60,
                    bottom: isMobile ? 40 : isTablet ? 50 : 60,
                    left: isMobile ? 30 : isTablet ? 45 : 60
                };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Create gradient definitions for Tableau Jedi Master effects
                const defs = svg.append("defs");

                // Quadrant background gradients
                const quadrants = [
                    { id: "q1-gradient", color: "var(--accent-purple)", opacity: 0.1 },
                    { id: "q2-gradient", color: "var(--accent-cyan)", opacity: 0.1 },
                    { id: "q3-gradient", color: "var(--accent-green)", opacity: 0.1 },
                    { id: "q4-gradient", color: "var(--accent-blue)", opacity: 0.1 }
                ];

                quadrants.forEach(q => {
                    const gradient = defs.append("linearGradient")
                        .attr("id", q.id)
                        .attr("x1", "0%").attr("y1", "0%")
                        .attr("x2", "100%").attr("y2", "100%");

                    gradient.append("stop")
                        .attr("offset", "0%")
                        .attr("stop-color", q.color)
                        .attr("stop-opacity", q.opacity);

                    gradient.append("stop")
                        .attr("offset", "100%")
                        .attr("stop-color", q.color)
                        .attr("stop-opacity", q.opacity * 0.3);
                });

                // Enhanced evaluation tools with comprehensive metrics
                const tools = [
                    {
                        name: "RAGAS",
                        x: 0.75,
                        y: 0.25,
                        quadrant: 1,
                        icon: "🎯",
                        color: "var(--accent-purple)",
                        size: 12,
                        automation: 0.9,
                        specificity: 0.8,
                        accuracy: 0.92,
                        speed: 0.85,
                        cost: 0.3,
                        details: "RAG-specific evaluation framework with automated metrics for faithfulness, answer relevance, and context precision. Optimized for retrieval-augmented generation systems.",
                        tooltip: "<b>RAGAS (RAG Assessment)</b><br>Specialized framework for evaluating RAG systems.<br><br><b>Key Metrics:</b><br>• Faithfulness: 92%<br>• Answer Relevance: 89%<br>• Context Precision: 94%<br><br><b>Strengths:</b><br>• Automated evaluation<br>• RAG-specific metrics<br>• Fast execution (0.3s)<br><br><b>Use Cases:</b><br>• Document Q&A systems<br>• Knowledge retrieval<br>• Context-aware generation"
                    },
                    {
                        name: "DeepEval",
                        x: 0.8,
                        y: 0.3,
                        quadrant: 1,
                        icon: "🧠",
                        color: "var(--accent-cyan)",
                        size: 14,
                        automation: 0.95,
                        specificity: 0.7,
                        accuracy: 0.88,
                        speed: 0.7,
                        cost: 0.4,
                        details: "Comprehensive LLM evaluation suite supporting multiple evaluation paradigms including automated, human-in-the-loop, and hybrid approaches.",
                        tooltip: "<b>DeepEval</b><br>Comprehensive LLM evaluation framework.<br><br><b>Key Metrics:</b><br>• Overall Score: 88%<br>• Consistency: 91%<br>• Bias Detection: 85%<br><br><b>Strengths:</b><br>• Multi-paradigm support<br>• Extensive test suites<br>• Custom metrics<br><br><b>Use Cases:</b><br>• Model comparison<br>• Performance benchmarking<br>• Quality assurance"
                    },
                    {
                        name: "MMLU",
                        x: 0.2,
                        y: 0.8,
                        quadrant: 3,
                        icon: "📚",
                        color: "var(--accent-green)",
                        size: 16,
                        automation: 0.3,
                        specificity: 0.2,
                        accuracy: 0.95,
                        speed: 0.4,
                        cost: 0.8,
                        details: "Massive Multitask Language Understanding benchmark covering 57 tasks across STEM, humanities, social sciences, and more. Human-curated high-quality test sets.",
                        tooltip: "<b>MMLU (Massive Multitask Language Understanding)</b><br>Comprehensive benchmark for general capabilities.<br><br><b>Coverage:</b><br>• 57 academic subjects<br>• 15,908 questions<br>• 4-choice format<br><br><b>Strengths:</b><br>• Human-curated quality<br>• Broad domain coverage<br>• Standardized format<br><br><b>Use Cases:</b><br>• General capability assessment<br>• Model comparison<br>• Academic evaluation"
                    },
                    {
                        name: "Human Eval",
                        x: 0.25,
                        y: 0.75,
                        quadrant: 3,
                        icon: "👥",
                        color: "var(--accent-blue)",
                        size: 13,
                        automation: 0.1,
                        specificity: 0.3,
                        accuracy: 0.98,
                        speed: 0.2,
                        cost: 0.9,
                        details: "Human-in-the-loop evaluation framework for subjective assessment of code generation, creative writing, and complex reasoning tasks requiring human judgment.",
                        tooltip: "<b>Human Eval</b><br>Human-in-the-loop evaluation framework.<br><br><b>Assessment Areas:</b><br>• Code correctness: 95%<br>• Creative quality: 87%<br>• Reasoning accuracy: 92%<br><br><b>Strengths:</b><br>• Human judgment<br>• Subjective evaluation<br>• High accuracy<br><br><b>Use Cases:</b><br>• Creative tasks<br>• Code generation<br>• Complex reasoning"
                    }
                ];

                const xScale = d3.scaleLinear().domain([0, 1]).range([0, width]);
                const yScale = d3.scaleLinear().domain([0, 1]).range([height, 0]);

                // Add quadrant backgrounds with gradients
                const quadrantAreas = [
                    { x: width / 2, y: 0, width: width / 2, height: height / 2, gradient: "q1-gradient" },
                    { x: 0, y: 0, width: width / 2, height: height / 2, gradient: "q2-gradient" },
                    { x: 0, y: height / 2, width: width / 2, height: height / 2, gradient: "q3-gradient" },
                    { x: width / 2, y: height / 2, width: width / 2, height: height / 2, gradient: "q4-gradient" }
                ];

                quadrantAreas.forEach(q => {
                    svg.append("rect")
                        .attr("x", q.x)
                        .attr("y", q.y)
                        .attr("width", q.width)
                        .attr("height", q.height)
                        .attr("fill", `url(#${q.gradient})`)
                        .attr("rx", 8);
                });

                // Enhanced grid lines with Tableau-style styling
                svg.append("line")
                    .attr("x1", 0)
                    .attr("y1", height / 2)
                    .attr("x2", width)
                    .attr("y2", height / 2)
                    .attr("stroke", "var(--secondary-border)")
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", "8,4")
                    .attr("opacity", 0.6);

                svg.append("line")
                    .attr("x1", width / 2)
                    .attr("y1", 0)
                    .attr("x2", width / 2)
                    .attr("y2", height)
                    .attr("stroke", "var(--secondary-border)")
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", "8,4")
                    .attr("opacity", 0.6);

                // Enhanced axis labels with responsive positioning and sizing
                const axisLabelFontSize = isMobile ? "10px" : isTablet ? "12px" : "14px";
                const axisLabelOffset = isMobile ? 30 : isTablet ? 37 : 45;

                svg.append("text")
                    .attr("x", width)
                    .attr("y", height + axisLabelOffset)
                    .attr("text-anchor", "end")
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", axisLabelFontSize)
                    .style("font-weight", "bold")
                    .text(isMobile ? "Auto →" : "Automated →");

                svg.append("text")
                    .attr("x", isMobile ? -10 : -15)
                    .attr("y", isMobile ? -10 : -15)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", axisLabelFontSize)
                    .style("font-weight", "bold")
                    .text(isMobile ? "↑ Specific" : "↑ Task-Specific");

                // Enhanced quadrant labels with responsive sizing and positioning
                const quadrantLabelFontSize = isMobile ? "8px" : isTablet ? "10px" : "12px";
                const quadrantLabelY = isMobile ? 20 : 25;
                const quadrantLabelBottomY = isMobile ? height - 10 : height - 15;

                const quadrantLabels = [
                    {
                        x: width * 0.75,
                        y: quadrantLabelY,
                        text: isMobile ? "Auto+Specific" : isTablet ? "Auto+Task" : "Automated + Task-Specific",
                        color: "var(--accent-purple)"
                    },
                    {
                        x: width * 0.25,
                        y: quadrantLabelY,
                        text: isMobile ? "Human+Specific" : isTablet ? "Human+Task" : "Human + Task-Specific",
                        color: "var(--accent-cyan)"
                    },
                    {
                        x: width * 0.25,
                        y: quadrantLabelBottomY,
                        text: isMobile ? "Human+General" : "Human + General",
                        color: "var(--accent-green)"
                    },
                    {
                        x: width * 0.75,
                        y: quadrantLabelBottomY,
                        text: isMobile ? "Auto+General" : "Automated + General",
                        color: "var(--accent-blue)"
                    }
                ];

                quadrantLabels.forEach(label => {
                    svg.append("text")
                        .attr("x", label.x)
                        .attr("y", label.y)
                        .attr("text-anchor", "middle")
                        .attr("fill", label.color)
                        .style("font-weight", "bold")
                        .style("font-size", quadrantLabelFontSize)
                        .text(label.text);
                });

                // Enhanced tool visualization with Tableau Jedi Master techniques
                const nodes = svg.selectAll(".eval-node")
                    .data(tools)
                    .enter()
                    .append("g")
                    .attr("class", "eval-node interactive-node")
                    .attr("transform", d => `translate(${xScale(d.x)}, ${yScale(d.y)})`)
                    .on("mouseover", (event, d) => {
                        showTooltip(event, d.tooltip);
                        // Highlight related tools
                        svg.selectAll(".eval-node").style("opacity", 0.4);
                        d3.select(event.currentTarget).style("opacity", 1.0);
                        // Show performance indicators
                        svg.selectAll(".performance-indicator").style("opacity", 0.3);
                        d3.select(event.currentTarget).selectAll(".performance-indicator").style("opacity", 1.0);
                    })
                    .on("mouseout", () => {
                        hideTooltip();
                        svg.selectAll(".eval-node").style("opacity", 1.0);
                        svg.selectAll(".performance-indicator").style("opacity", 0.6);
                    });

                // Calculate responsive sizing for tool elements
                const calculateToolSize = (baseSize, isMobile, isTablet) => {
                    if (isMobile) return Math.max(baseSize * 0.7, 8);
                    if (isTablet) return Math.max(baseSize * 0.85, 10);
                    return baseSize;
                };

                const toolIconFontSize = isMobile ? "12px" : isTablet ? "14px" : "16px";
                const toolNameFontSize = isMobile ? "8px" : isTablet ? "9px" : "11px";
                const toolNameOffset = isMobile ? 3 : 5;
                const strokeWidth = isMobile ? 2 : 3;

                // Main tool circles with responsive sizing
                nodes.append("circle")
                    .attr("r", d => calculateToolSize(d.size, isMobile, isTablet))
                    .attr("fill", d => d.color)
                    .attr("stroke", "white")
                    .attr("stroke-width", strokeWidth)
                    .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                // Tool icons with responsive sizing
                nodes.append("text")
                    .attr("x", 0)
                    .attr("y", isMobile ? 3 : 4)
                    .attr("text-anchor", "middle")
                    .style("font-size", toolIconFontSize)
                    .text(d => d.icon);

                // Tool names with responsive positioning and sizing
                nodes.append("text")
                    .attr("x", d => {
                        const adjustedSize = calculateToolSize(d.size, isMobile, isTablet);
                        return d.x > 0.5 ? -adjustedSize - toolNameOffset : adjustedSize + toolNameOffset;
                    })
                    .attr("y", isMobile ? 3 : 5)
                    .attr("text-anchor", d => d.x > 0.5 ? "end" : "start")
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", toolNameFontSize)
                    .style("font-weight", "bold")
                    .text(d => d.name);

                // Performance indicators with responsive sizing
                if (!isMobile) { // Hide performance indicators on mobile for clarity
                nodes.each(function (d) {
                    const node = d3.select(this);
                    const performanceData = [d.automation, d.specificity, d.accuracy, d.speed, 1 - d.cost];
                        const indicatorSize = isTablet ? 15 : 20;
                        const baseRadius = isTablet ? 2 : 3;
                        const scaleMultiplier = isTablet ? 2 : 3;

                    performanceData.forEach((value, i) => {
                        const angle = (i * 2 * Math.PI) / performanceData.length;
                        const x = Math.cos(angle) * indicatorSize;
                        const y = Math.sin(angle) * indicatorSize;

                        node.append("circle")
                            .attr("class", "performance-indicator")
                            .attr("cx", x)
                            .attr("cy", y)
                                .attr("r", baseRadius)
                            .attr("fill", d.color)
                            .attr("opacity", 0.6);

                            // Performance value indicator with responsive scaling
                            const scaledRadius = 1.5 + (value * scaleMultiplier);
                        node.append("circle")
                            .attr("class", "performance-indicator")
                            .attr("cx", x)
                            .attr("cy", y)
                            .attr("r", scaledRadius)
                            .attr("fill", d.color)
                            .attr("opacity", 0.8);
                    });
                });
                }

                // Add performance legend with responsive positioning and sizing
                if (!isMobile) { // Hide legend on mobile to save space
                    const legendWidth = isTablet ? 100 : 120;
                    const legendHeight = isTablet ? 60 : 80;
                    const legend = svg.append("g")
                        .attr("class", "performance-legend")
                        .attr("transform", `translate(${width - legendWidth}, ${height - legendHeight})`);

                    const legendFontSize = isTablet ? "10px" : "12px";
                legend.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-primary)")
                        .style("font-size", legendFontSize)
                    .style("font-weight", "bold")
                        .text(isTablet ? "Performance" : "Performance Metrics");

                    const legendSpacing = isTablet ? 10 : 15;
                const legendItems = [
                        { label: isTablet ? "Auto" : "Automation", y: legendSpacing },
                        { label: isTablet ? "Spec" : "Specificity", y: legendSpacing * 2 },
                        { label: isTablet ? "Acc" : "Accuracy", y: legendSpacing * 3 },
                        { label: "Speed", y: legendSpacing * 4 },
                        { label: isTablet ? "Cost" : "Cost-Eff", y: legendSpacing * 5 }
                ];

                legendItems.forEach((item, i) => {
                    legend.append("circle")
                        .attr("cx", 5)
                        .attr("cy", item.y - 2)
                            .attr("r", isTablet ? 1.5 : 2)
                        .attr("fill", "var(--accent-blue)")
                        .attr("opacity", 0.6);

                    legend.append("text")
                            .attr("x", isTablet ? 12 : 15)
                        .attr("y", item.y)
                        .attr("fill", "var(--text-secondary)")
                            .style("font-size", isTablet ? "8px" : "10px")
                        .text(item.label);
                });
                }

                // Add evaluation methodology summary
                const summary = svg.append("g").attr("class", "evaluation-summary").attr("transform", `translate(20, ${height - 30})`);

                summary.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "10px")
                    .text("Evaluation Framework: ");

                summary.append("text")
                    .attr("x", 100)
                    .attr("y", 0)
                    .attr("fill", "var(--accent-cyan)")
                    .style("font-size", "10px")
                    .style("font-weight", "bold")
                    .text("Multi-dimensional assessment for comprehensive LLM evaluation");
            }

            /** Renders the CI/CD & IaC pipeline visualization with advanced visual storytelling, comprehensive DevOps metrics, and responsive design. */
            function renderCICDIaCViz() {
                const container = d3.select("#cicd-iac-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 40 : isTablet ? 45 : 50, 
                    right: isMobile ? 20 : isTablet ? 25 : 30, 
                    bottom: isMobile ? 50 : isTablet ? 55 : 60, 
                    left: isMobile ? 20 : isTablet ? 25 : 30 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers for different pipeline stages with sophisticated styling
                arrowMarker(svg, "arrow-cicd", "var(--accent-purple)");
                arrowMarker(svg, "arrow-infrastructure", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-container", "var(--accent-green)");
                arrowMarker(svg, "arrow-deployment", "var(--accent-blue)");
                arrowMarker(svg, "arrow-monitoring", "var(--accent-purple)");
                arrowMarker(svg, "arrow-energy", "#FF6B6B");

                // Advanced gradient definitions for CI/CD pipeline stages with competition-level styling
                const defs = svg.append("defs");

                // Sophisticated pipeline stage gradients with depth, dimension, and visual hierarchy
                const stageGradients = [
                    { id: "commit-grad", colors: ["#8338EC", "#A855F7", "#C084FC"], direction: "vertical", type: "linear" },
                    { id: "terraform-grad", colors: ["#2EC4B6", "#34D399", "#6EE7B7"], direction: "diagonal", type: "linear" },
                    { id: "docker-grad", colors: ["#3A86FF", "#60A5FA", "#93C5FD"], direction: "radial", type: "radial" },
                    { id: "k8s-grad", colors: ["#FFB700", "#FCD34D", "#FDE68A"], direction: "horizontal", type: "linear" },
                    { id: "monitoring-grad", colors: ["#FF6B6B", "#F87171", "#FCA5A5"], direction: "diagonal", type: "linear" },
                    { id: "energy-grad", colors: ["#FF6B6B", "#FF8E8E", "#FFB3B3"], direction: "radial", type: "radial" }
                ];

                stageGradients.forEach(grad => {
                    if (grad.type === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", grad.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[2]).attr("stop-opacity", 0.5);
                    } else {
                        const gradient = defs.append("linearGradient").attr("id", grad.id);
                        if (grad.direction === "vertical") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                        } else if (grad.direction === "horizontal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                        } else if (grad.direction === "diagonal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                        }
                        gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        gradient.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                        gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[2]).attr("stop-opacity", 0.5);
                    }
                });

                // Add sophisticated filter effects for visual depth
                const filter = defs.append("filter").attr("id", "glow-effect");
                filter.append("feGaussianBlur").attr("stdDeviation", "3").attr("result", "coloredBlur");
                const feMerge = filter.append("feMerge");
                feMerge.append("feMergeNode").attr("in", "coloredBlur");
                feMerge.append("feMergeNode").attr("in", "SourceGraphic");

                // Add drop shadow filter for professional depth
                const dropShadow = defs.append("filter").attr("id", "drop-shadow").attr("x", "-50%").attr("y", "-50%").attr("width", "200%").attr("height", "200%");
                dropShadow.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", "4").attr("result", "blur");
                dropShadow.append("feOffset").attr("in", "blur").attr("dx", "2").attr("dy", "2").attr("result", "offsetBlur");
                const feFlood = dropShadow.append("feFlood").attr("flood-color", "rgba(0,0,0,0.3)").attr("flood-opacity", "0.5").attr("result", "offsetColor");
                dropShadow.append("feComposite").attr("in", "offsetColor").attr("in2", "offsetBlur").attr("operator", "in").attr("result", "offsetBlur");
                const feMerge2 = dropShadow.append("feMerge");
                feMerge2.append("feMergeNode").attr("in", "offsetBlur");
                feMerge2.append("feMergeNode").attr("in", "SourceGraphic");

                // Calculate responsive stage positioning based on screen size with optimized spacing
                const calculateStagePositions = (isMobile, isTablet, width, height) => {
                    if (isMobile) {
                        // Mobile: Stack stages vertically with enhanced spacing to prevent overlap
                        const stageSpacing = Math.max(height * 0.22, 95); // Increased minimum spacing to 95px
                        const startY = height * 0.15; // Better top margin
                        return [
                            { x: width * 0.5, y: startY },                    // Code Commit
                            { x: width * 0.5, y: startY + stageSpacing },     // Terraform
                            { x: width * 0.5, y: startY + (stageSpacing * 2) }, // Docker
                            { x: width * 0.5, y: startY + (stageSpacing * 3) }  // K8s
                        ];
                    } else if (isTablet) {
                        // Tablet: 2x2 grid layout with enhanced spacing and better alignment
                        const horizontalSpacing = Math.max(width * 0.35, 140); // Increased minimum horizontal spacing to 140px
                        const verticalSpacing = Math.max(height * 0.3, 110); // Increased minimum vertical spacing to 110px
                        const centerX = width * 0.5;
                        const centerY = height * 0.5;
                        return [
                            { x: centerX - horizontalSpacing/2, y: centerY - verticalSpacing/2 },  // Code Commit
                            { x: centerX + horizontalSpacing/2, y: centerY - verticalSpacing/2 },  // Terraform
                            { x: centerX - horizontalSpacing/2, y: centerY + verticalSpacing/2 },  // Docker
                            { x: centerX + horizontalSpacing/2, y: centerY + verticalSpacing/2 }   // K8s
                        ];
                    } else {
                        // Desktop: Optimized horizontal layout with enhanced consistent spacing
                        const stageSpacing = Math.max(width * 0.2, 160); // Increased minimum spacing to 160px
                        const startX = width * 0.15; // Better left margin
                        const centerY = height * 0.3; // Better vertical centering
                        return [
                            { x: startX, y: centerY },                    // Code Commit
                            { x: startX + stageSpacing, y: centerY },     // Terraform
                            { x: startX + (stageSpacing * 2), y: centerY }, // Docker
                            { x: startX + (stageSpacing * 3), y: centerY }  // K8s
                        ];
                    }
                };

                const stagePositions = calculateStagePositions(isMobile, isTablet, width, height);

                // Enhanced CI/CD pipeline stages with responsive positioning and comprehensive DevOps metrics
                const stages = [
                    {
                        name: isMobile ? "Commit" : "Code\nCommit",
                        x: stagePositions[0].x,
                        y: stagePositions[0].y,
                        gradient: "commit-grad",
                        icon: "📝",
                        category: "Source Control",
                        duration: "2s",
                        success_rate: 98,
                        priority: "Critical",
                        complexity: "Low",
                        tools: ["Git", "GitHub Actions", "Webhooks"],
                        metrics: { throughput: "50 commits/day", latency: "2s", reliability: "98%" },
                        tooltip: "<b>Code Commit & Trigger</b><br>Version control integration with automated pipeline triggers. Implements branch protection, code review requirements, and automated testing initiation.<br><br><b>Duration:</b> 2s average<br><b>Success Rate:</b> 98%<br><b>Priority:</b> Critical<br><b>Tools:</b> Git, GitHub Actions, Webhooks<br><b>Features:</b> Branch protection, code review, automated triggers<br><b>Metrics:</b> 50 commits/day throughput, 2s latency, 98% reliability"
                    },
                    {
                        name: isMobile ? "Terraform" : "Terraform\nPlan/Apply",
                        x: stagePositions[1].x,
                        y: stagePositions[1].y,
                        gradient: "terraform-grad",
                        icon: "🏗️",
                        category: "Infrastructure",
                        duration: "3-5min",
                        success_rate: 95,
                        priority: "High",
                        complexity: "Medium",
                        tools: ["Terraform", "Spacelift", "AWS/Azure/GCP"],
                        metrics: { throughput: "20 deployments/day", latency: "4min", reliability: "95%" },
                        tooltip: "<b>Infrastructure as Code</b><br>Automated infrastructure provisioning and configuration management. Implements drift detection, policy enforcement, and environment consistency.<br><br><b>Duration:</b> 3-5min average<br><b>Success Rate:</b> 95%<br><b>Priority:</b> High<br><b>Tools:</b> Terraform, Spacelift, AWS/Azure/GCP<br><b>Features:</b> Drift detection, policy enforcement, environment consistency<br><b>Metrics:</b> 20 deployments/day throughput, 4min latency, 95% reliability"
                    },
                    {
                        name: isMobile ? "Docker" : "Docker\nBuild",
                        x: stagePositions[2].x,
                        y: stagePositions[2].y,
                        gradient: "docker-grad",
                        icon: "🐳",
                        category: "Containerization",
                        duration: "2-8min",
                        success_rate: 92,
                        priority: "High",
                        complexity: "Medium",
                        tools: ["Docker", "BuildKit", "Registry"],
                        metrics: { throughput: "30 builds/day", latency: "5min", reliability: "92%" },
                        tooltip: "<b>Container Build & Registry</b><br>Automated container image creation with multi-stage builds, security scanning, and registry management. Implements caching strategies and vulnerability detection.<br><br><b>Duration:</b> 2-8min average<br><b>Success Rate:</b> 92%<br><b>Priority:</b> High<br><b>Tools:</b> Docker, BuildKit, Registry<br><b>Features:</b> Multi-stage builds, security scanning, caching<br><b>Metrics:</b> 30 builds/day throughput, 5min latency, 92% reliability"
                    },
                    {
                        name: isMobile ? "K8s" : "K8s\nDeploy",
                        x: stagePositions[3].x,
                        y: stagePositions[3].y,
                        gradient: "k8s-grad",
                        icon: "☸️",
                        category: "Orchestration",
                        duration: "1-3min",
                        success_rate: 96,
                        priority: "Critical",
                        complexity: "High",
                        tools: ["Kubernetes", "Helm", "ArgoCD"],
                        metrics: { throughput: "25 deployments/day", latency: "2min", reliability: "96%" },
                        tooltip: "<b>Kubernetes Deployment</b><br>Automated application deployment with rolling updates, health checks, and traffic management. Implements canary deployments and rollback capabilities.<br><br><b>Duration:</b> 1-3min average<br><b>Success Rate:</b> 96%<br><b>Priority:</b> Critical<br><b>Tools:</b> Kubernetes, Helm, ArgoCD<br><b>Features:</b> Rolling updates, health checks, canary deployments<br><b>Metrics:</b> 25 deployments/day throughput, 2min latency, 96% reliability"
                    }
                ];

                // Enhanced monitoring and observability layer with responsive positioning optimized for new spacing
                const monitoringPosition = isMobile 
                    ? { x: width * 0.5, y: height * 0.82 }   // Mobile: bottom center with enhanced spacing
                    : isTablet 
                        ? { x: width * 0.5, y: height * 0.72 }  // Tablet: lower center with improved spacing
                        : { x: width * 0.5, y: height * 0.62 };  // Desktop: optimized position for new layout

                const monitoringLayer = [
                    {
                        name: isMobile ? "Monitor" : isTablet ? "Monitoring" : "Monitoring\n& Alerts",
                        x: monitoringPosition.x,
                        y: monitoringPosition.y,
                        gradient: "monitoring-grad",
                        icon: "📊",
                        category: "Observability",
                        duration: "Real-time",
                        success_rate: 99,
                        priority: "Critical",
                        complexity: "High",
                        tools: ["Prometheus", "Grafana", "Datadog", "LangFuse"],
                        metrics: { throughput: "1000+ metrics/sec", latency: "<100ms", reliability: "99.9%" },
                        tooltip: "<b>Monitoring & Observability</b><br>Comprehensive system monitoring with metrics collection, alerting, and performance tracking. Implements distributed tracing and log aggregation.<br><br><b>Duration:</b> Real-time monitoring<br><b>Success Rate:</b> 99%<br><b>Priority:</b> Critical<br><b>Tools:</b> Prometheus, Grafana, Datadog, LangFuse<br><b>Features:</b> Metrics collection, alerting, distributed tracing<br><b>Metrics:</b> 1000+ metrics/sec throughput, <100ms latency, 99.9% reliability"
                    }
                ];

                // Add energy flow visualization for pipeline dynamics
                const energyFlows = [
                    { from: stages[0], to: stages[1], intensity: 0.9, type: "commit-flow" },
                    { from: stages[1], to: stages[2], intensity: 0.8, type: "infrastructure-flow" },
                    { from: stages[2], to: stages[3], intensity: 0.85, type: "container-flow" },
                    { from: stages[3], to: monitoringLayer[0], intensity: 0.95, type: "deployment-flow" }
                ];

                // Add sophisticated monitoring gradient with multiple stops
                const monitoringGrad = defs.append("linearGradient").attr("id", "monitoring-grad").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                monitoringGrad.append("stop").attr("offset", "0%").attr("stop-color", "#FF6B6B").attr("stop-opacity", 0.9);
                monitoringGrad.append("stop").attr("offset", "50%").attr("stop-color", "#F87171").attr("stop-opacity", 0.7);
                monitoringGrad.append("stop").attr("offset", "100%").attr("stop-color", "#FCA5A5").attr("stop-opacity", 0.5);

                // Calculate responsive sizing for stage elements with enhanced consistent proportions
                const calculateStageDimensions = (isMobile, isTablet) => {
                    if (isMobile) {
                        return {
                            width: 90, // Increased width for better proportions
                            height: 70, // Increased height for better proportions
                            padding: 45, // Increased padding for better spacing
                            cornerRadius: 14, // Increased corner radius for modern look
                            iconSize: "24px", // Slightly larger icon
                            nameSize: "12px", // Slightly larger text
                            metricSize: "10px", // Slightly larger metrics
                            successBarWidth: 70, // Increased bar width
                            priorityOffset: 35, // Better offset positioning
                            complexityOffset: 30, // Better offset positioning
                            connectionOffset: 45 // Increased connection offset for better spacing
                        };
                    } else if (isTablet) {
                        return {
                            width: 110, // Increased width for better proportions
                            height: 80, // Increased height for better proportions
                            padding: 55, // Increased padding for better spacing
                            cornerRadius: 16, // Increased corner radius
                            iconSize: "28px", // Larger icon
                            nameSize: "13px", // Larger text
                            metricSize: "11px", // Larger metrics
                            successBarWidth: 85, // Increased bar width
                            priorityOffset: 40, // Better offset positioning
                            complexityOffset: 35, // Better offset positioning
                            connectionOffset: 55 // Increased connection offset
                        };
                    } else {
                        return {
                            width: 125, // Increased width for better proportions
                            height: 90, // Increased height for better proportions
                            padding: 62, // Increased padding for better spacing
                            cornerRadius: 18, // Increased corner radius
                            iconSize: "32px", // Larger icon
                            nameSize: "14px", // Larger text
                            metricSize: "12px", // Larger metrics
                            successBarWidth: 100, // Increased bar width
                            priorityOffset: 45, // Better offset positioning
                            complexityOffset: 40, // Better offset positioning
                            connectionOffset: 62 // Increased connection offset for better spacing
                        };
                    }
                };

                const stageDimensions = calculateStageDimensions(isMobile, isTablet);

                // Render main pipeline stages with responsive design and sophisticated visual storytelling
                stages.forEach((stage, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node cicd-stage")
                        .attr("data-category", stage.category)
                        .attr("data-priority", stage.priority)
                        .attr("data-complexity", stage.complexity)
                        .style("opacity", 0)
                        .on("mouseover", (e) => {
                            showTooltip(e, stage.tooltip);
                            // Highlight related stages with sophisticated effects
                            svg.selectAll(".cicd-stage").style("opacity", 0.3);
                            g.style("opacity", 1.0).style("filter", "url(#glow-effect)");
                            // Highlight connections with energy flow
                            svg.selectAll(".pipeline-connection").style("opacity", 0.2);
                            svg.selectAll(`.connection-${i}`).style("opacity", 1.0).style("stroke-width", isMobile ? 2 : 4);
                            // Show energy flows
                            svg.selectAll(".energy-flow").style("opacity", 0.3);
                            svg.selectAll(`.energy-${i}`).style("opacity", 1.0);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".cicd-stage").style("opacity", 1.0).style("filter", "none");
                            svg.selectAll(".pipeline-connection").style("opacity", 0.7).style("stroke-width", isMobile ? 1 : 2);
                            svg.selectAll(".energy-flow").style("opacity", 0.5);
                        });

                    // Stage background with responsive sizing and sophisticated gradient
                    const stageRect = g.append("rect")
                        .attr("x", stage.x - stageDimensions.padding)
                        .attr("y", stage.y - (stageDimensions.height / 2))
                        .attr("width", stageDimensions.width)
                        .attr("height", stageDimensions.height)
                        .attr("fill", `url(#${stage.gradient})`)
                        .attr("rx", stageDimensions.cornerRadius)
                        .style("filter", "url(#drop-shadow)")
                        .style("opacity", 0);

                    // Priority indicator with shape encoding
                    const priorityShapes = {
                        "Critical": "diamond",
                        "High": "circle",
                        "Medium": "square",
                        "Low": "triangle"
                    };

                    const priorityColor = {
                        "Critical": "#FF6B6B",
                        "High": "#FFB700",
                        "Medium": "#3A86FF",
                        "Low": "#2EC4B6"
                    };

                    // Add priority indicator with responsive positioning
                    const priorityIndicator = g.append("g").attr("class", "priority-indicator");
                    const priorityOffset = stageDimensions.priorityOffset;
                    if (stage.priority === "Critical") {
                        priorityIndicator.append("polygon")
                            .attr("points", `${stage.x - priorityOffset},${stage.y - 30} ${stage.x - (priorityOffset - 10)},${stage.y - 20} ${stage.x - priorityOffset},${stage.y - 10} ${stage.x - (priorityOffset + 10)},${stage.y - 20}`)
                            .attr("fill", priorityColor[stage.priority])
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (stage.priority === "High") {
                        priorityIndicator.append("circle")
                            .attr("cx", stage.x - (priorityOffset - 5))
                            .attr("cy", stage.y - 20)
                            .attr("r", 6)
                            .attr("fill", priorityColor[stage.priority])
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    }

                    // Complexity indicator with visual encoding and responsive positioning
                    const complexityBars = g.append("g").attr("class", "complexity-indicator");
                    const complexityLevels = { "Low": 1, "Medium": 2, "High": 3 };
                    const complexityOffset = stageDimensions.complexityOffset;
                    for (let j = 0; j < complexityLevels[stage.complexity]; j++) {
                        complexityBars.append("rect")
                            .attr("x", stage.x + complexityOffset + (j * 4))
                            .attr("y", stage.y - 30 - (j * 2))
                            .attr("width", 3)
                            .attr("height", 8 - (j * 2))
                            .attr("fill", stage.complexity === "High" ? "#FF6B6B" : stage.complexity === "Medium" ? "#FFB700" : "#2EC4B6")
                            .attr("rx", 1);
                    }

                    // Stage icon with entrance animation using responsive sizing
                    g.append("text")
                        .attr("x", stage.x)
                        .attr("y", stage.y - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", stageDimensions.iconSize)
                        .style("opacity", 0)
                        .text(stage.icon)
                        .transition()
                        .delay(i * 300 + 500)
                        .duration(800)
                        .style("opacity", 1)
                        .attr("y", stage.y - 5);

                    // Stage name with sophisticated typography using responsive sizing
                    stage.name.split('\n').forEach((line, j) => {
                        g.append("text")
                            .attr("x", stage.x)
                            .attr("y", stage.y + (j * 14) + 10)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", stageDimensions.nameSize)
                            .style("font-weight", "bold")
                            .style("opacity", 0)
                            .text(line)
                            .transition()
                            .delay(i * 300 + 700)
                            .duration(600)
                            .style("opacity", 1);
                    });

                    // Enhanced success rate indicator with visual storytelling using responsive dimensions
                    const successBar = g.append("g").attr("class", "success-indicator");
                    const successBarWidth = stageDimensions.successBarWidth;
                    const successBarX = stage.x - (successBarWidth / 2);
                    const successBarY = stage.y + 30;
                    
                    successBar.append("rect")
                        .attr("x", successBarX)
                        .attr("y", successBarY)
                        .attr("width", successBarWidth)
                        .attr("height", 6)
                        .attr("fill", "rgba(255,255,255,0.2)")
                        .attr("rx", 3);

                    successBar.append("rect")
                        .attr("x", successBarX)
                        .attr("y", successBarY)
                        .attr("width", 0)
                        .attr("height", 6)
                        .attr("fill", stage.success_rate > 95 ? "#2EC4B6" : stage.success_rate > 90 ? "#FFB700" : "#FF6B6B")
                        .attr("rx", 3)
                        .transition()
                        .delay(i * 300 + 1000)
                        .duration(1200)
                        .attr("width", (stage.success_rate / 100) * 90);

                    // Success rate percentage with animation
                    g.append("text")
                        .attr("x", stage.x)
                        .attr("y", stage.y + 40)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(`${stage.success_rate}%`)
                        .transition()
                        .delay(i * 300 + 1200)
                        .duration(600)
                        .style("opacity", 1);

                    // Animate stage entrance
                    stageRect.transition()
                        .delay(i * 300)
                        .duration(800)
                        .style("opacity", 1);

                    // Connect to next stage with sophisticated energy flow and improved path calculation
                    if (i < stages.length - 1) {
                        const nextStage = stages[i + 1];
                        
                        // Calculate optimal connection path based on layout
                        let pathData;
                        if (isMobile) {
                            // Vertical layout: straight vertical connections with slight curve
                            const midY = (stage.y + nextStage.y) / 2;
                            pathData = `M ${stage.x} ${stage.y + stageDimensions.connectionOffset} 
                                      Q ${stage.x + 20} ${midY} ${nextStage.x} ${nextStage.y - stageDimensions.connectionOffset}`;
                        } else if (isTablet) {
                            // Grid layout: diagonal connections with smooth curves
                            const midX = (stage.x + nextStage.x) / 2;
                            const midY = (stage.y + nextStage.y) / 2;
                            pathData = `M ${stage.x + stageDimensions.connectionOffset} ${stage.y} 
                                      Q ${midX} ${midY - 30} ${nextStage.x - stageDimensions.connectionOffset} ${nextStage.y}`;
                        } else {
                            // Horizontal layout: smooth horizontal connections
                            const midX = (stage.x + nextStage.x) / 2;
                            pathData = `M ${stage.x + stageDimensions.connectionOffset} ${stage.y} 
                                      Q ${midX} ${stage.y - 30} ${nextStage.x - stageDimensions.connectionOffset} ${nextStage.y}`;
                        }
                        
                        const path = svg.append("path")
                            .attr("class", `pipeline-connection connection-${i}`)
                            .attr("d", pathData)
                            .attr("stroke", "var(--accent-purple)")
                            .attr("fill", "none")
                            .attr("stroke-width", isMobile ? 2.5 : isTablet ? 3 : 3.5) // Increased stroke width for better visibility
                            .attr("opacity", 0)
                            .attr("marker-end", "url(#arrow-cicd)")
                            .style("stroke-linecap", "round")
                            .style("filter", "drop-shadow(0 2px 4px rgba(74, 144, 226, 0.3))"); // Added shadow for better visual depth

                        // Animate the pipeline flow with sophisticated timing
                        const pathLength = path.node().getTotalLength();
                        path.attr("stroke-dasharray", `${pathLength} ${pathLength}`)
                            .attr("stroke-dashoffset", pathLength)
                            .transition()
                            .delay(i * 300 + 1500)
                            .duration(2000)
                            .attr("stroke-dashoffset", 0)
                            .attr("opacity", 0.7);

                        // Add energy flow particles
                        const energyFlow = svg.append("g").attr("class", `energy-flow energy-${i}`);
                        for (let p = 0; p < 3; p++) {
                            energyFlow.append("circle")
                                .attr("r", 3)
                                .attr("fill", "#FF6B6B")
                                .attr("opacity", 0.8)
                                .attr("cx", stage.x + 55)
                                .attr("cy", stage.y)
                                .transition()
                                .delay(i * 300 + 2000 + (p * 200))
                                .duration(1500)
                                .attr("cx", nextStage.x - 55)
                                .attr("cy", nextStage.y)
                                .transition()
                                .duration(0)
                                .attr("cx", stage.x + 55)
                                .attr("cy", stage.y);
                        }
                    }
                });

                // Render monitoring layer with sophisticated visual storytelling
                monitoringLayer.forEach((monitor, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node monitoring-stage")
                        .style("opacity", 0)
                        .on("mouseover", (e) => {
                            showTooltip(e, monitor.tooltip);
                            svg.selectAll(".monitoring-stage").style("opacity", 0.4);
                            g.style("opacity", 1.0).style("filter", "url(#glow-effect)");
                            // Highlight all monitoring connections
                            svg.selectAll(".monitoring-connection").style("opacity", 0.2);
                            svg.selectAll(".monitoring-connection").style("opacity", 1.0).style("stroke-width", 2);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".monitoring-stage").style("opacity", 1.0).style("filter", "none");
                            svg.selectAll(".monitoring-connection").style("opacity", 0.4).style("stroke-width", 1);
                        });

                    // Monitoring background with sophisticated styling using consistent dimensions
                    const monitorRect = g.append("rect")
                        .attr("x", monitor.x - stageDimensions.padding)
                        .attr("y", monitor.y - (stageDimensions.height / 2))
                        .attr("width", stageDimensions.width)
                        .attr("height", stageDimensions.height)
                        .attr("fill", `url(#${monitor.gradient})`)
                        .attr("rx", stageDimensions.cornerRadius)
                        .style("filter", "url(#drop-shadow)")
                        .style("opacity", 0);

                    // Priority indicator for monitoring using consistent positioning
                    const priorityIndicator = g.append("g").attr("class", "priority-indicator");
                    const priorityOffset = stageDimensions.priorityOffset;
                    priorityIndicator.append("polygon")
                        .attr("points", `${monitor.x - priorityOffset},${monitor.y - 30} ${monitor.x - (priorityOffset - 10)},${monitor.y - 20} ${monitor.x - priorityOffset},${monitor.y - 10} ${monitor.x - (priorityOffset + 10)},${monitor.y - 20}`)
                        .attr("fill", "#FF6B6B")
                        .attr("stroke", "white")
                        .attr("stroke-width", 1);

                    // Complexity indicator for monitoring using consistent positioning
                    const complexityBars = g.append("g").attr("class", "complexity-indicator");
                    const complexityOffset = stageDimensions.complexityOffset;
                    for (let j = 0; j < 3; j++) {
                        complexityBars.append("rect")
                            .attr("x", monitor.x + complexityOffset + (j * 4))
                            .attr("y", monitor.y - 30 - (j * 2))
                            .attr("width", 3)
                            .attr("height", 8 - (j * 2))
                            .attr("fill", "#FF6B6B")
                            .attr("rx", 1);
                    }

                    // Monitoring icon with entrance animation using consistent sizing
                    g.append("text")
                        .attr("x", monitor.x)
                        .attr("y", monitor.y - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", stageDimensions.iconSize)
                        .style("opacity", 0)
                        .text(monitor.icon)
                        .transition()
                        .delay(2000)
                        .duration(800)
                        .style("opacity", 1)
                        .attr("y", monitor.y - 5);

                    // Monitoring name with sophisticated typography using consistent sizing
                    monitor.name.split('\n').forEach((line, j) => {
                        g.append("text")
                            .attr("x", monitor.x)
                            .attr("y", monitor.y + (j * 14) + 10)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", stageDimensions.nameSize)
                            .style("font-weight", "bold")
                            .style("opacity", 0)
                            .text(line)
                            .transition()
                            .delay(2200)
                            .duration(600)
                            .style("opacity", 1);
                    });

                    // Enhanced success rate indicator for monitoring using consistent dimensions
                    const successBar = g.append("g").attr("class", "success-indicator");
                    const successBarWidth = stageDimensions.successBarWidth;
                    const successBarX = monitor.x - (successBarWidth / 2);
                    const successBarY = monitor.y + 30;
                    
                    successBar.append("rect")
                        .attr("x", successBarX)
                        .attr("y", successBarY)
                        .attr("width", successBarWidth)
                        .attr("height", 6)
                        .attr("fill", "rgba(255,255,255,0.2)")
                        .attr("rx", 3);

                    successBar.append("rect")
                        .attr("x", successBarX)
                        .attr("y", successBarY)
                        .attr("width", 0)
                        .attr("height", 6)
                        .attr("fill", "#2EC4B6")
                        .attr("rx", 3)
                        .transition()
                        .delay(2500)
                        .duration(1200)
                        .attr("width", (monitor.success_rate / 100) * 100);

                    // Success rate percentage with animation using consistent sizing
                    g.append("text")
                        .attr("x", monitor.x)
                        .attr("y", monitor.y + 40)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", stageDimensions.metricSize)
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(`${monitor.success_rate}%`)
                        .transition()
                        .delay(2700)
                        .duration(600)
                        .style("opacity", 1);

                    // Animate monitoring entrance
                    monitorRect.transition()
                        .delay(1800)
                        .duration(800)
                        .style("opacity", 1);

                    // Connect monitoring to all stages with sophisticated visual effects using consistent offsets
                    stages.forEach((stage, stageIndex) => {
                        const connection = svg.append("line")
                            .attr("class", "monitoring-connection")
                            .attr("x1", stage.x)
                            .attr("y1", stage.y + stageDimensions.connectionOffset)
                            .attr("x2", monitor.x)
                            .attr("y2", monitor.y - stageDimensions.connectionOffset)
                            .attr("stroke", "var(--accent-purple)")
                            .attr("stroke-width", isMobile ? 1.5 : 2)
                            .attr("opacity", 0)
                            .attr("stroke-dasharray", "4,4")
                            .attr("marker-end", "url(#arrow-monitoring)");

                        // Animate monitoring connections
                        connection.transition()
                            .delay(3000 + (stageIndex * 200))
                            .duration(1000)
                            .attr("opacity", 0.4);
                    });
                });

                // Add sophisticated DevOps metrics dashboard with advanced visual storytelling
                const dashboard = svg.append("g").attr("class", "devops-dashboard").attr("transform", `translate(0, ${height - 50})`);

                // Enhanced dashboard background with sophisticated styling
                const dashboardBg = dashboard.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", width)
                    .attr("height", 50)
                    .attr("fill", "rgba(27, 38, 59, 0.9)")
                    .attr("stroke", "var(--primary-border)")
                    .attr("rx", 8)
                    .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.4))")
                    .style("opacity", 0);

                // Calculate comprehensive DevOps metrics
                const avgSuccessRate = stages.reduce((sum, s) => sum + s.success_rate, 0) / stages.length;
                const totalDuration = stages.reduce((sum, s) => {
                    const duration = s.duration.includes("min") ? parseInt(s.duration) : 0.1;
                    return sum + duration;
                }, 0);
                const deploymentFrequency = "Multiple times per day";
                const criticalStages = stages.filter(s => s.priority === "Critical").length;
                const highComplexityStages = stages.filter(s => s.complexity === "High").length;
                const totalThroughput = stages.reduce((sum, s) => {
                    const throughput = parseInt(s.metrics.throughput.split('/')[0]);
                    return sum + throughput;
                }, 0);

                // Add dashboard title
                dashboard.append("text")
                    .attr("x", 10)
                    .attr("y", 15)
                    .attr("fill", "var(--accent-purple)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .text("DevOps Performance Dashboard")
                    .transition()
                    .delay(4000)
                    .duration(800)
                    .style("opacity", 1);

                // Enhanced DevOps metrics with sophisticated visual indicators
                const metrics = [
                    {
                        label: "Avg Success Rate",
                        value: `${avgSuccessRate.toFixed(1)}%`,
                        x: 10,
                        y: 30,
                        color: "var(--accent-green)",
                        icon: "✓",
                        trend: "up"
                    },
                    {
                        label: "Total Duration",
                        value: `${totalDuration.toFixed(1)}min`,
                        x: width / 4,
                        y: 30,
                        color: "var(--accent-cyan)",
                        icon: "⏱️",
                        trend: "stable"
                    },
                    {
                        label: "Deployment Freq",
                        value: deploymentFrequency,
                        x: width / 2,
                        y: 30,
                        color: "var(--accent-purple)",
                        icon: "🚀",
                        trend: "up"
                    },
                    {
                        label: "Critical Stages",
                        value: `${criticalStages}/${stages.length}`,
                        x: 3 * width / 4,
                        y: 30,
                        color: "var(--accent-red)",
                        icon: "⚡",
                        trend: "stable"
                    }
                ];

                // Render metrics with sophisticated animations
                metrics.forEach((metric, i) => {
                    const metricGroup = dashboard.append("g").attr("class", "metric-group");

                    // Metric icon
                    metricGroup.append("text")
                        .attr("x", metric.x - 15)
                        .attr("y", metric.y)
                        .attr("fill", metric.color)
                        .style("font-size", "14px")
                        .style("opacity", 0)
                        .text(metric.icon)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Metric label
                    metricGroup.append("text")
                        .attr("x", metric.x)
                        .attr("y", metric.y - 5)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "9px")
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(metric.label)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Metric value
                    metricGroup.append("text")
                        .attr("x", metric.x)
                        .attr("y", metric.y + 8)
                        .attr("fill", metric.color)
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(metric.value)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Trend indicator
                    const trendIcon = metric.trend === "up" ? "↗" : metric.trend === "down" ? "↘" : "→";
                    metricGroup.append("text")
                        .attr("x", metric.x + 50)
                        .attr("y", metric.y)
                        .attr("fill", metric.trend === "up" ? "var(--accent-green)" : metric.trend === "down" ? "var(--accent-red)" : "var(--accent-cyan)")
                        .style("font-size", "12px")
                        .style("opacity", 0)
                        .text(trendIcon)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);
                });

                // Add performance sparklines for visual storytelling
                const sparklineData = [95, 98, 96, 99, 97, 98, 99, 98, 97, 99];
                const sparklineGroup = dashboard.append("g").attr("class", "sparkline").attr("transform", `translate(${width - 120}, 15)`);

                const sparklineScale = d3.scaleLinear()
                    .domain([0, sparklineData.length - 1])
                    .range([0, 100]);

                const sparklineValueScale = d3.scaleLinear()
                    .domain(d3.extent(sparklineData))
                    .range([10, 20]);

                const sparklinePath = d3.line()
                    .x((d, i) => sparklineScale(i))
                    .y(d => sparklineValueScale(d))
                    .curve(d3.curveMonotoneX);

                sparklineGroup.append("path")
                    .datum(sparklineData)
                    .attr("d", sparklinePath)
                    .attr("fill", "none")
                    .attr("stroke", "var(--accent-green)")
                    .attr("stroke-width", 2)
                    .style("opacity", 0)
                    .transition()
                    .delay(5000)
                    .duration(1500)
                    .style("opacity", 1);

                // Add sparkline label
                sparklineGroup.append("text")
                    .attr("x", 50)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-green)")
                    .style("font-size", "8px")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .text("Success Trend")
                    .transition()
                    .delay(5000)
                    .duration(600)
                    .style("opacity", 1);

                // Animate dashboard entrance
                dashboardBg.transition()
                    .delay(3500)
                    .duration(1000)
                    .style("opacity", 1);
            }

            function renderAllAdvancedVisualizations() {
                renderFoundationModelViz();
                renderFineTuningViz();
                renderVectorDbVizAdvanced();
                renderAdvancedRAGPipelinesViz();
                renderInferenceOptimizationViz();
                renderAdvancedRetrievalViz();
                renderPromptEngineeringViz();
                renderUPGMathematicalViz();
                renderHPTAlgorithmViz();
                renderLLMTypesComparisonViz();
                renderAgenticRAGComparisonViz();
            }

            /** Renders the Unified Policy Gradient Estimator mathematical framework with responsive gradient flow visualization. */
            function renderUPGMathematicalViz() {
                const container = d3.select("#upg-mathematical-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive design detection and adaptive margins for mathematical frameworks
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || bounds.width < 600;
                const isTablet = deviceType.type === 'tablet' || (bounds.width >= 600 && bounds.width < 1024);
                
                const margin = { 
                    top: isMobile ? 40 : 60, 
                    right: isMobile ? 20 : 60, 
                    bottom: isMobile ? 40 : 80, 
                    left: isMobile ? 20 : 60 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Add sophisticated gradient definitions for mathematical elegance
                const defs = svg.append("defs");

                // UPG Core gradient
                const upgGradient = defs.append("radialGradient").attr("id", "upg-core-gradient").attr("cx", "50%").attr("cy", "50%").attr("r", "50%");
                upgGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-purple)").attr("stop-opacity", 0.8);
                upgGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-purple)").attr("stop-opacity", 0.3);

                // Algorithm-specific gradients
                const reinforceGradient = defs.append("linearGradient").attr("id", "reinforce-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                reinforceGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-blue)").attr("stop-opacity", 0.7);
                reinforceGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-blue)").attr("stop-opacity", 0.3);

                const actorCriticGradient = defs.append("linearGradient").attr("id", "actor-critic-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                actorCriticGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-green)").attr("stop-opacity", 0.7);
                actorCriticGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-green)").attr("stop-opacity", 0.3);

                const ppoGradient = defs.append("linearGradient").attr("id", "ppo-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                ppoGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-cyan)").attr("stop-opacity", 0.7);
                ppoGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-cyan)").attr("stop-opacity", 0.3);

                // Responsive central UPG core with adaptive sizing
                const centerX = width / 2; const centerY = height / 2;
                const coreRadius = isMobile ? 50 : 80;

                // Enhanced UPG Core circle with responsive mathematical notation
                const upgCore = svg.append("g")
                    .attr("class", "interactive-node upg-core mathematical-framework")
                    .attr("data-framework", "unified-policy-gradient");
                    
                upgCore.append("circle")
                    .attr("cx", centerX)
                    .attr("cy", centerY)
                    .attr("r", coreRadius)
                    .attr("fill", "url(#upg-core-gradient)")
                    .attr("stroke", "var(--accent-purple)")
                    .attr("stroke-width", isMobile ? 2 : 3)
                    .style("filter", "drop-shadow(0 8px 16px rgba(131, 56, 236, 0.3))");

                // Add gradient flow animation around the core
                if (!isMobile) {
                    const gradientFlow = svg.append("circle")
                        .attr("class", "gradient-flow-ring")
                        .attr("cx", centerX)
                        .attr("cy", centerY)
                        .attr("r", coreRadius + 15)
                        .attr("fill", "none")
                        .attr("stroke", "var(--accent-purple)")
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "5,5")
                        .style("opacity", 0.6);

                    // Animate the gradient flow ring
                    function animateGradientFlow() {
                        gradientFlow
                            .transition()
                            .duration(3000)
                            .ease(d3.easeLinear)
                            .attr("stroke-dashoffset", -628) // 2π * (radius + 15) for full rotation
                            .on("end", animateGradientFlow);
                    }
                    animateGradientFlow();
                }

                // UPG mathematical formula with improved positioning and alignment
                const formulaFontSize = isMobile ? "11px" : "14px";
                const titleFontSize = isMobile ? "10px" : "12px";
                const lineSpacing = isMobile ? 12 : 15;
                
                // Add background rectangle for better formula readability
                const formulaBg = upgCore.append("rect")
                    .attr("x", centerX - (isMobile ? 60 : 75))
                    .attr("y", centerY - (isMobile ? 20 : 25))
                    .attr("width", isMobile ? 120 : 150)
                    .attr("height", isMobile ? 35 : 45)
                    .attr("fill", "var(--bg-color)")
                    .attr("opacity", 0.85)
                    .attr("rx", 4)
                    .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                upgCore.append("text")
                    .attr("x", centerX)
                    .attr("y", centerY - (isMobile ? 8 : 10))
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", formulaFontSize)
                    .style("font-weight", "bold")
                    .style("font-family", "Roboto Mono, monospace")
                    .style("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                    .text("∇J(θ) = E[∇log π(a|s)");

                upgCore.append("text")
                    .attr("x", centerX)
                    .attr("y", centerY + (isMobile ? 8 : 10))
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", formulaFontSize)
                    .style("font-weight", "bold")
                    .style("font-family", "Roboto Mono, monospace")
                    .style("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                    .text("× Â(s,a)]");

                upgCore.append("text")
                    .attr("x", centerX)
                    .attr("y", centerY + (isMobile ? 25 : 30))
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-purple)")
                    .style("font-size", titleFontSize)
                    .style("font-weight", "bold")
                    .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                    .text("Unified Policy Gradient");

                // Enhanced responsive algorithm nodes positioned around the core with collision detection
                const algorithmRadius = isMobile ? 40 : isTablet ? 50 : 60;
                const minSpacing = algorithmRadius * 2.5; // Minimum spacing between algorithms
                
                // Calculate optimal algorithm positions with collision avoidance
                const algorithms = isMobile ? [
                    {
                        name: "REINFORCE",
                        x: Math.max(centerX - 150, minSpacing),
                        y: Math.max(centerY - 80, minSpacing),
                        gradient: "url(#reinforce-gradient)",
                        color: "var(--accent-blue)",
                        formula: "∇J = E[∇log π(a|s) × R]",
                        description: "Monte Carlo Policy Gradient"
                    },
                    {
                        name: "Actor-Critic",
                        x: Math.min(centerX + 150, width - minSpacing),
                        y: Math.max(centerY - 80, minSpacing),
                        gradient: "url(#actor-critic-gradient)",
                        color: "var(--accent-green)",
                        formula: "∇J = E[∇log π(a|s) × A(s,a)]",
                        description: "Value-Based Policy Gradient"
                    },
                    {
                        name: "PPO",
                        x: centerX,
                        y: Math.min(centerY + 120, height - minSpacing),
                        gradient: "url(#ppo-gradient)",
                        color: "var(--accent-cyan)",
                        formula: "∇J = E[min(r(θ) × Â, clip(r(θ), 1-ε, 1+ε) × Â)]",
                        description: "Proximal Policy Optimization"
                    }
                ] : isTablet ? [
                    {
                        name: "REINFORCE",
                        x: Math.max(centerX - 180, minSpacing),
                        y: Math.max(centerY - 90, minSpacing),
                        gradient: "url(#reinforce-gradient)",
                        color: "var(--accent-blue)",
                        formula: "∇J = E[∇log π(a|s) × R]",
                        description: "Monte Carlo Policy Gradient"
                    },
                    {
                        name: "Actor-Critic",
                        x: Math.min(centerX + 180, width - minSpacing),
                        y: Math.max(centerY - 90, minSpacing),
                        gradient: "url(#actor-critic-gradient)",
                        color: "var(--accent-green)",
                        formula: "∇J = E[∇log π(a|s) × A(s,a)]",
                        description: "Value-Based Policy Gradient"
                    },
                    {
                        name: "PPO",
                        x: centerX,
                        y: Math.min(centerY + 140, height - minSpacing),
                        gradient: "url(#ppo-gradient)",
                        color: "var(--accent-cyan)",
                        formula: "∇J = E[min(r(θ) × Â, clip(r(θ), 1-ε, 1+ε) × Â)]",
                        description: "Proximal Policy Optimization"
                    }
                ] : [
                    {
                        name: "REINFORCE",
                        x: Math.max(centerX - 200, minSpacing),
                        y: Math.max(centerY - 100, minSpacing),
                        gradient: "url(#reinforce-gradient)",
                        color: "var(--accent-blue)",
                        formula: "∇J = E[∇log π(a|s) × R]",
                        description: "Monte Carlo Policy Gradient"
                    },
                    {
                        name: "Actor-Critic",
                        x: Math.min(centerX + 200, width - minSpacing),
                        y: Math.max(centerY - 100, minSpacing),
                        gradient: "url(#actor-critic-gradient)",
                        color: "var(--accent-green)",
                        formula: "∇J = E[∇log π(a|s) × A(s,a)]",
                        description: "Value-Based Policy Gradient"
                    },
                    {
                        name: "PPO",
                        x: centerX,
                        y: Math.min(centerY + 150, height - minSpacing),
                        gradient: "url(#ppo-gradient)",
                        color: "var(--accent-cyan)",
                        formula: "∇J = E[min(r(θ) × Â, clip(r(θ), 1-ε, 1+ε) × Â)]",
                        description: "Proximal Policy Optimization"
                    }
                ];

                algorithms.forEach((algo, i) => {
                    const algoGroup = svg.append("g").attr("class", "interactive-node algorithm-node");

                    // Enhanced responsive algorithm circle with adaptive sizing
                    const circleRadius = isMobile ? 35 : isTablet ? 45 : 60;
                    const nameFontSize = isMobile ? "10px" : isTablet ? "11px" : "12px";
                    const formulaFontSize = isMobile ? "7px" : isTablet ? "8px" : "9px";
                    const descriptionFontSize = isMobile ? "8px" : isTablet ? "9px" : "10px";
                    
                    algoGroup.append("circle")
                        .attr("cx", algo.x)
                        .attr("cy", algo.y)
                        .attr("r", circleRadius)
                        .attr("fill", algo.gradient)
                        .attr("stroke", algo.color)
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Enhanced algorithm name with responsive positioning
                    algoGroup.append("text")
                        .attr("x", algo.x)
                        .attr("y", algo.y - (isMobile ? 15 : 20))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", nameFontSize)
                        .style("font-weight", "bold")
                        .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                        .text(algo.name);

                    // Enhanced mathematical formula with improved positioning and background
                    if (!isMobile || (isMobile && width > 300)) {
                        // Calculate formula text dimensions for proper background sizing
                        const formulaText = isMobile ? algo.formula.replace(/∇/g, "∇").replace(/π/g, "π") : algo.formula;
                        const estimatedTextWidth = formulaText.length * (isMobile ? 4 : 5);
                        const backgroundWidth = Math.max(estimatedTextWidth + 10, 80);
                        const backgroundHeight = isMobile ? 10 : 12;
                        
                        // Add background for formula readability with precise positioning
                        algoGroup.append("rect")
                            .attr("x", algo.x - backgroundWidth / 2)
                            .attr("y", algo.y + (isMobile ? 1 : 2))
                            .attr("width", backgroundWidth)
                            .attr("height", backgroundHeight)
                            .attr("fill", "var(--bg-color)")
                            .attr("opacity", 0.9)
                            .attr("rx", 2)
                            .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.2))");
                        
                        algoGroup.append("text")
                            .attr("x", algo.x)
                            .attr("y", algo.y + (isMobile ? 8 : 10))
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", formulaFontSize)
                            .style("font-family", "Roboto Mono, monospace")
                            .style("font-weight", "500")
                            .style("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                            .text(formulaText);
                    }

                    // Enhanced description with improved positioning to avoid formula overlap
                    const descriptionY = algo.y + (isMobile ? 22 : 30);
                    algoGroup.append("text")
                        .attr("x", algo.x)
                        .attr("y", descriptionY)
                        .attr("text-anchor", "middle")
                        .attr("fill", algo.color)
                        .style("font-size", descriptionFontSize)
                        .style("font-weight", "500")
                        .style("text-shadow", "0 1px 2px rgba(0,0,0,0.2)")
                        .text(isMobile ? algo.description.split(' ')[0] + ' ' + algo.description.split(' ')[1] : algo.description);

                    // Enhanced responsive connection lines to UPG core with dynamic gradient flows
                    const lineStrokeWidth = isMobile ? 2 : isTablet ? 2.5 : 3;
                    const dashArray = isMobile ? "3,3" : "5,5";
                    
                    const line = svg.append("line")
                        .attr("x1", algo.x)
                        .attr("y1", algo.y)
                        .attr("x2", centerX)
                        .attr("y2", centerY)
                        .attr("stroke", algo.color)
                        .attr("stroke-width", lineStrokeWidth)
                        .attr("stroke-dasharray", dashArray)
                        .attr("opacity", 0.7)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.2))");

                    // Enhanced responsive animated gradient flow along connection lines
                    const particleCount = isMobile ? 1 : 2; // Fewer particles on mobile for performance
                    const particleSize = isMobile ? 1.5 : 2;
                    const animationDuration = isMobile ? 1500 : 2000; // Faster on mobile
                    
                    for (let j = 0; j < particleCount; j++) {
                        const particle = svg.append("circle")
                            .attr("class", "gradient-particle interactive-gradient")
                            .attr("cx", algo.x)
                            .attr("cy", algo.y)
                            .attr("r", particleSize)
                            .attr("fill", algo.color)
                            .style("opacity", 0.8)
                            .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))");

                        // Enhanced gradient flow animation with dynamic path calculation
                        const pathLength = Math.sqrt(
                            Math.pow(centerX - algo.x, 2) + 
                            Math.pow(centerY - algo.y, 2)
                        );
                        
                        // Calculate intermediate points for more realistic gradient flow
                        const intermediatePoints = [];
                        const numPoints = Math.max(2, Math.floor(pathLength / 30)); // More points for longer paths
                        
                        for (let k = 1; k < numPoints; k++) {
                            const t = k / numPoints;
                            const x = algo.x + (centerX - algo.x) * t;
                            const y = algo.y + (centerY - algo.y) * t;
                            // Add slight curve to make gradient flow more realistic
                            const curveOffset = Math.sin(t * Math.PI) * (isMobile ? 3 : 5);
                            intermediatePoints.push({
                                x: x + (Math.random() - 0.5) * curveOffset,
                                y: y + (Math.random() - 0.5) * curveOffset
                            });
                        }

                        // Animate gradient particle through intermediate points
                        let currentPoint = 0;
                        const animateNextPoint = () => {
                            if (currentPoint < intermediatePoints.length) {
                                const point = intermediatePoints[currentPoint];
                                particle
                                    .transition()
                                    .duration(animationDuration / numPoints)
                                    .ease(d3.easeLinear)
                                    .attr("cx", point.x)
                                    .attr("cy", point.y)
                                    .on("end", () => {
                                        currentPoint++;
                                        animateNextPoint();
                                    });
                            } else {
                                // Final movement to center
                                particle
                                    .transition()
                                    .duration(animationDuration / numPoints)
                                    .ease(d3.easeLinear)
                                    .attr("cx", centerX)
                                    .attr("cy", centerY)
                                    .style("opacity", 0)
                                    .remove();
                            }
                        };

                        // Start animation with delay
                        setTimeout(() => {
                            animateNextPoint();
                        }, i * 500 + j * 250);
                    }

                    // Enhanced connection line animation with responsive timing
                    line.transition()
                        .duration(isMobile ? 1500 : 2000)
                        .delay(i * (isMobile ? 300 : 500))
                        .attr("stroke-dashoffset", isMobile ? -15 : -20)
                        .transition()
                        .duration(isMobile ? 1500 : 2000)
                        .attr("stroke-dashoffset", 0)
                        .on("end", function repeat() {
                            d3.select(this)
                                .transition()
                                .duration(isMobile ? 1500 : 2000)
                                .attr("stroke-dashoffset", isMobile ? -15 : -20)
                                .transition()
                                .duration(isMobile ? 1500 : 2000)
                                .attr("stroke-dashoffset", 0)
                                .on("end", repeat);
                        });

                    // Enhanced responsive algorithm interactions with dynamic optimization visualization
                    algoGroup.on("mouseover", function (event) {
                        d3.select(this).select("circle")
                            .attr("stroke-width", 4)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                        showTooltip(event, `<b>${algo.name}</b><br>${algo.description}<br><br><strong>Formula:</strong><br>${algo.formula}`);
                    })
                    .on("mouseout", function () {
                        d3.select(this).select("circle")
                            .attr("stroke-width", isMobile ? 1.5 : 2)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                        hideTooltip();
                    })
                    .on("click", function (event) {
                        // Enhanced click interaction for mobile and desktop with optimization details
                        const clickedAlgo = d3.select(this);
                        const isActive = clickedAlgo.classed("active");
                        
                        // Remove active state from all algorithms
                        svg.selectAll(".algorithm-node").classed("active", false)
                            .select("circle").attr("stroke-width", isMobile ? 1.5 : 2);
                        
                        if (!isActive) {
                            // Activate clicked algorithm
                            clickedAlgo.classed("active", true)
                                .select("circle")
                                .attr("stroke-width", 5)
                                .style("filter", "drop-shadow(0 8px 16px rgba(0,0,0,0.5))");
                            
                            // Show enhanced tooltip with optimization details
                            const optimizationDetails = {
                                "REINFORCE": "High variance, unbiased estimator, requires many samples",
                                "Actor-Critic": "Lower variance, biased estimator, faster convergence",
                                "PPO": "Clipped objective, stable training, good sample efficiency"
                            };
                            
                            const enhancedTooltip = `<b>${algo.name} - Optimization Details</b><br><br><b>Description:</b> ${algo.description}<br><br><b>Formula:</b><br>${algo.formula}<br><br><b>Optimization Characteristics:</b><br>${optimizationDetails[algo.name]}<br><br><b>Convergence Rate:</b> ${algo.name === 'PPO' ? 'Fast' : algo.name === 'Actor-Critic' ? 'Medium' : 'Slow'}<br><b>Sample Efficiency:</b> ${algo.name === 'PPO' ? 'High' : algo.name === 'Actor-Critic' ? 'Medium' : 'Low'}<br><b>Stability:</b> ${algo.name === 'PPO' ? 'High' : algo.name === 'Actor-Critic' ? 'Medium' : 'Low'}`;
                            showTooltip(event, enhancedTooltip);
                        } else {
                            hideTooltip();
                        }
                    });
                    
                    // Add touch support for mobile devices with optimization feedback
                    if (isMobile) {
                        algoGroup.on("touchstart", function (event) {
                            event.preventDefault();
                            d3.select(this).select("circle")
                                .attr("stroke-width", 4)
                                .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                        })
                        .on("touchend", function (event) {
                            event.preventDefault();
                            d3.select(this).select("circle")
                                .attr("stroke-width", 1.5)
                                .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                        });
                    }
                });

                // Enhanced responsive mathematical framework explanation with adaptive formatting
                const explanationY = height - (isMobile ? 15 : 20);
                const explanationFontSize = isMobile ? "8px" : isTablet ? "9px" : "11px";
                const explanationText = isMobile ? 
                    "UPG: ∇J(θ) = E[∇log π(a|s) × Â(s,a)]" :
                    isTablet ?
                    "UPG unifies policy gradient methods: ∇J(θ) = E[∇log π(a|s) × Â(s,a)]" :
                    "UPG unifies policy gradient methods through a common mathematical foundation: ∇J(θ) = E[∇log π(a|s) × Â(s,a)]";
                
                // Add background for explanation readability
                if (!isMobile) {
                    svg.append("rect")
                        .attr("x", width / 2 - 200)
                        .attr("y", explanationY - 8)
                        .attr("width", 400)
                        .attr("height", 12)
                        .attr("fill", "var(--bg-color)")
                        .attr("opacity", 0.9)
                        .attr("rx", 3)
                        .style("filter", "drop-shadow(0 1px 3px rgba(0,0,0,0.1))");
                }
                
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", explanationY)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", explanationFontSize)
                    .style("font-family", "Roboto Mono, monospace")
                    .style("text-shadow", "0 1px 2px rgba(0,0,0,0.2)")
                    .text(explanationText);

                // Add convergence visualization
                const convergenceData = d3.range(50).map(i => ({
                    x: i * (width - 100) / 49 + 50,
                    y: centerY + 200 + Math.sin(i * 0.3) * 20 * Math.exp(-i * 0.05)
                }));

                const convergenceLine = d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveMonotoneX);

                svg.append("path")
                    .datum(convergenceData)
                    .attr("d", convergenceLine)
                    .attr("fill", "none")
                    .attr("stroke", "var(--accent-purple)")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.8);

                svg.append("text")
                    .attr("x", 50)
                    .attr("y", centerY + 190)
                    .attr("fill", "var(--accent-purple)")
                    .style("font-size", "10px")
                    .style("font-weight", "bold")
                    .text("Convergence Pattern");
            }

            /** Renders the Hybrid Post-Training (HPT) algorithm visualization with dynamic mixing ratios. */
            function renderHPTAlgorithmViz() {
                const container = d3.select("#hpt-algorithm-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 60, right: 60, bottom: 80, left: 60 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Add sophisticated gradient definitions for HPT visualization
                const defs = svg.append("defs");

                // SFT gradient (Supervised Fine-Tuning)
                const sftGradient = defs.append("linearGradient").attr("id", "sft-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                sftGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-blue)").attr("stop-opacity", 0.8);
                sftGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-blue)").attr("stop-opacity", 0.4);

                // RL gradient (Reinforcement Learning)
                const rlGradient = defs.append("linearGradient").attr("id", "rl-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                rlGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-green)").attr("stop-opacity", 0.8);
                rlGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-green)").attr("stop-opacity", 0.4);

                // HPT hybrid gradient
                const hptGradient = defs.append("linearGradient").attr("id", "hpt-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                hptGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-purple)").attr("stop-opacity", 0.9);
                hptGradient.append("stop").attr("offset", "50%").attr("stop-color", "var(--accent-cyan)").attr("stop-opacity", 0.7);
                hptGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-green)").attr("stop-opacity", 0.5);

                // Training phases timeline
                const phases = [
                    { name: "Pre-training", x: 50, width: 80, color: "var(--primary-border)", description: "Base model training" },
                    { name: "SFT Phase", x: 150, width: 100, color: "var(--accent-blue)", description: "Supervised Fine-Tuning" },
                    { name: "HPT Phase", x: 270, width: 120, color: "var(--accent-purple)", description: "Hybrid Post-Training" },
                    { name: "Deployment", x: 410, width: 80, color: "var(--accent-green)", description: "Production Model" }
                ];

                // Draw training phases
                phases.forEach((phase, i) => {
                    const phaseGroup = svg.append("g").attr("class", "interactive-node training-phase");

                    // Phase rectangle
                    phaseGroup.append("rect")
                        .attr("x", phase.x)
                        .attr("y", 50)
                        .attr("width", phase.width)
                        .attr("height", 40)
                        .attr("fill", phase.color)
                        .attr("rx", 8)
                        .attr("opacity", 0.8)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Phase name
                    phaseGroup.append("text")
                        .attr("x", phase.x + phase.width / 2)
                        .attr("y", 70)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "11px")
                        .style("font-weight", "bold")
                        .text(phase.name);

                    // Add hover interactions
                    phaseGroup.on("mouseover", function (event) {
                        d3.select(this).select("rect").attr("opacity", 1.0);
                        showTooltip(event, `<b>${phase.name}</b><br>${phase.description}`);
                    })
                        .on("mouseout", function () {
                            d3.select(this).select("rect").attr("opacity", 0.8);
                            hideTooltip();
                        });

                    // Add arrows between phases
                    if (i < phases.length - 1) {
                        svg.append("path")
                            .attr("d", `M ${phase.x + phase.width + 5} 70 L ${phases[i + 1].x - 5} 70`)
                            .attr("stroke", "var(--text-secondary)")
                            .attr("stroke-width", 2)
                            .attr("marker-end", "url(#arrowhead)");
                    }
                });

                // Add arrow marker definition
                defs.append("marker")
                    .attr("id", "arrowhead")
                    .attr("markerWidth", "10")
                    .attr("markerHeight", "7")
                    .attr("refX", "9")
                    .attr("refY", "3.5")
                    .attr("orient", "auto")
                    .append("polygon")
                    .attr("points", "0 0, 10 3.5, 0 7")
                    .attr("fill", "var(--text-secondary)");

                // HPT Dynamic Mixing Visualization
                const mixingCenterX = width / 2;
                const mixingCenterY = 200;
                const mixingRadius = 100;

                // Create dynamic mixing circle
                const mixingCircle = svg.append("g").attr("class", "interactive-node mixing-visualization");

                // SFT portion (left half)
                mixingCircle.append("path")
                    .attr("d", `M ${mixingCenterX} ${mixingCenterY} A ${mixingRadius} ${mixingRadius} 0 0 1 ${mixingCenterX - mixingRadius} ${mixingCenterY} L ${mixingCenterX} ${mixingCenterY} Z`)
                    .attr("fill", "url(#sft-gradient)")
                    .attr("opacity", 0.8);

                // RL portion (right half)
                mixingCircle.append("path")
                    .attr("d", `M ${mixingCenterX} ${mixingCenterY} A ${mixingRadius} ${mixingRadius} 0 0 1 ${mixingCenterX + mixingRadius} ${mixingCenterY} L ${mixingCenterX} ${mixingCenterY} Z`)
                    .attr("fill", "url(#rl-gradient)")
                    .attr("opacity", 0.8);

                // Center circle with HPT label
                mixingCircle.append("circle")
                    .attr("cx", mixingCenterX)
                    .attr("cy", mixingCenterY)
                    .attr("r", 30)
                    .attr("fill", "var(--accent-purple)")
                    .attr("stroke", "white")
                    .attr("stroke-width", 3)
                    .style("filter", "drop-shadow(0 4px 8px rgba(131, 56, 236, 0.4))");

                mixingCircle.append("text")
                    .attr("x", mixingCenterX)
                    .attr("y", mixingCenterY - 5)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", "10px")
                    .style("font-weight", "bold")
                    .text("HPT");

                mixingCircle.append("text")
                    .attr("x", mixingCenterX)
                    .attr("y", mixingCenterY + 8)
                    .attr("text-anchor", "middle")
                    .attr("fill", "white")
                    .style("font-size", "8px")
                    .text("Dynamic");

                // SFT and RL labels
                svg.append("text")
                    .attr("x", mixingCenterX - 60)
                    .attr("y", mixingCenterY - 20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-blue)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("SFT");

                svg.append("text")
                    .attr("x", mixingCenterX + 60)
                    .attr("y", mixingCenterY - 20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-green)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("RL");

                // Performance curves
                const performanceData = [
                    { method: "SFT Only", performance: 0.75, efficiency: 0.6, stability: 0.9 },
                    { method: "RL Only", performance: 0.85, efficiency: 0.4, stability: 0.5 },
                    { method: "Sequential", performance: 0.80, efficiency: 0.5, stability: 0.7 },
                    { method: "HPT", performance: 0.95, efficiency: 0.8, stability: 0.85 }
                ];

                const performanceX = 50;
                const performanceY = 350;
                const performanceWidth = width - 100;
                const performanceHeight = 100;

                // Performance bars
                performanceData.forEach((data, i) => {
                    const barX = performanceX + i * (performanceWidth / performanceData.length);
                    const barWidth = (performanceWidth / performanceData.length) - 10;

                    // Performance bar
                    svg.append("rect")
                        .attr("x", barX)
                        .attr("y", performanceY + (1 - data.performance) * performanceHeight)
                        .attr("width", barWidth)
                        .attr("height", data.performance * performanceHeight)
                        .attr("fill", data.method === "HPT" ? "var(--accent-purple)" : "var(--accent-blue)")
                        .attr("opacity", 0.8)
                        .attr("rx", 4);

                    // Method label
                    svg.append("text")
                        .attr("x", barX + barWidth / 2)
                        .attr("y", performanceY + performanceHeight + 15)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .text(data.method);

                    // Performance value
                    svg.append("text")
                        .attr("x", barX + barWidth / 2)
                        .attr("y", performanceY + (1 - data.performance) * performanceHeight - 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "9px")
                        .style("font-weight", "bold")
                        .text((data.performance * 100).toFixed(0) + "%");
                });

                // Performance title
                svg.append("text")
                    .attr("x", performanceX + performanceWidth / 2)
                    .attr("y", performanceY - 10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Performance Comparison");

                // Mathematical formula for HPT
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height - 20)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "10px")
                    .style("font-family", "Roboto Mono")
                    .text("HPT: L_total = α(t) × L_SFT + (1-α(t)) × L_RL, where α(t) adapts based on performance metrics");
            }

            /** Renders the 8-Types of LLMs in AI Agents comprehensive comparison visualization. */
            function renderLLMTypesComparisonViz() {
                const container = d3.select("#llm-types-comparison-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 60, right: 60, bottom: 80, left: 60 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Add sophisticated gradient definitions for LLM types
                const defs = svg.append("defs");

                // LLM type gradients
                const typeGradients = [
                    { id: "reasoning-gradient", colors: ["var(--accent-blue)", "var(--accent-cyan)"] },
                    { id: "coding-gradient", colors: ["var(--accent-green)", "var(--accent-blue)"] },
                    { id: "multimodal-gradient", colors: ["var(--accent-purple)", "var(--accent-cyan)"] },
                    { id: "conversational-gradient", colors: ["var(--accent-green)", "var(--accent-purple)"] },
                    { id: "specialized-gradient", colors: ["var(--accent-cyan)", "var(--accent-blue)"] },
                    { id: "efficient-gradient", colors: ["var(--accent-green)", "var(--accent-cyan)"] },
                    { id: "orchestrator-gradient", colors: ["var(--accent-purple)", "var(--accent-green)"] },
                    { id: "reasoning-specialist-gradient", colors: ["var(--accent-blue)", "var(--accent-purple)"] }
                ];

                typeGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "50%").attr("cy", "50%").attr("r", "50%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.8);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.4);
                });

                // Responsive grid layout calculation
                const isMobile = width < 768;
                const isTablet = width < 1024 && width >= 768;
                
                // Calculate optimal grid dimensions based on container size
                const cols = isMobile ? 2 : isTablet ? 3 : 4;
                const rows = Math.ceil(8 / cols);
                const cardWidth = Math.min(160, (width - (cols - 1) * 20) / cols);
                const cardHeight = Math.min(120, (height - (rows - 1) * 20) / rows);
                const cardSpacing = 20;
                
                // Calculate starting position to center the grid
                const totalGridWidth = cols * cardWidth + (cols - 1) * cardSpacing;
                const totalGridHeight = rows * cardHeight + (rows - 1) * cardSpacing;
                const startX = (width - totalGridWidth) / 2;
                const startY = (height - totalGridHeight) / 2;

                // 8 Types of LLMs in AI Agents with responsive positioning
                const llmTypes = [
                    {
                        name: "Reasoning Specialist",
                        gradient: "url(#reasoning-gradient)",
                        color: "var(--accent-blue)",
                        capabilities: ["Complex Reasoning", "Mathematical Logic", "Scientific Analysis"],
                        useCase: "Research & Analysis Agents",
                        examples: ["GPT-4", "Claude-3", "Gemini Pro"],
                        performance: { accuracy: 0.95, speed: 0.7, efficiency: 0.6 }
                    },
                    {
                        name: "Coding Specialist",
                        gradient: "url(#coding-gradient)",
                        color: "var(--accent-green)",
                        capabilities: ["Code Generation", "Debugging", "Architecture Design"],
                        useCase: "Development & DevOps Agents",
                        examples: ["DeepSeek-Coder", "CodeLlama", "WizardCoder"],
                        performance: { accuracy: 0.90, speed: 0.8, efficiency: 0.7 }
                    },
                    {
                        name: "Multimodal Orchestrator",
                        gradient: "url(#multimodal-gradient)",
                        color: "var(--accent-purple)",
                        capabilities: ["Vision", "Audio", "Text Processing"],
                        useCase: "Content Creation Agents",
                        examples: ["GPT-4V", "Claude-3", "Gemini Ultra"],
                        performance: { accuracy: 0.88, speed: 0.6, efficiency: 0.5 }
                    },
                    {
                        name: "Conversational Agent",
                        gradient: "url(#conversational-gradient)",
                        color: "var(--accent-green)",
                        capabilities: ["Natural Dialogue", "Context Awareness", "Personality"],
                        useCase: "Customer Service & Support",
                        examples: ["ChatGPT", "Claude", "Bard"],
                        performance: { accuracy: 0.92, speed: 0.9, efficiency: 0.8 }
                    },
                    {
                        name: "Domain Specialist",
                        gradient: "url(#specialized-gradient)",
                        color: "var(--accent-cyan)",
                        capabilities: ["Domain Knowledge", "Expert Systems", "Compliance"],
                        useCase: "Industry-Specific Agents",
                        examples: ["Med-PaLM", "FinGPT", "LegalGPT"],
                        performance: { accuracy: 0.96, speed: 0.7, efficiency: 0.6 }
                    },
                    {
                        name: "Efficient Edge Model",
                        gradient: "url(#efficient-gradient)",
                        color: "var(--accent-green)",
                        capabilities: ["Low Latency", "Minimal Resources", "Real-time Processing"],
                        useCase: "Edge & Mobile Agents",
                        examples: ["Phi-3", "Gemma", "Llama-3.1-8B"],
                        performance: { accuracy: 0.80, speed: 0.95, efficiency: 0.95 }
                    },
                    {
                        name: "Multi-Agent Orchestrator",
                        gradient: "url(#orchestrator-gradient)",
                        color: "var(--accent-purple)",
                        capabilities: ["Agent Coordination", "Task Distribution", "Workflow Management"],
                        useCase: "Complex System Agents",
                        examples: ["AutoGen", "LangGraph", "CrewAI"],
                        performance: { accuracy: 0.85, speed: 0.8, efficiency: 0.7 }
                    },
                    {
                        name: "Reasoning Chain Specialist",
                        gradient: "url(#reasoning-specialist-gradient)",
                        color: "var(--accent-blue)",
                        capabilities: ["Chain-of-Thought", "Step-by-Step", "Verification"],
                        useCase: "Problem-Solving Agents",
                        examples: ["GPT-4", "Claude-3", "Gemini Pro"],
                        performance: { accuracy: 0.94, speed: 0.6, efficiency: 0.5 }
                    }
                ];

                // Calculate responsive positions for each card
                llmTypes.forEach((type, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    type.x = startX + col * (cardWidth + cardSpacing) + cardWidth / 2;
                    type.y = startY + row * (cardHeight + cardSpacing) + cardHeight / 2;
                });

                // Render LLM type cards with responsive sizing
                llmTypes.forEach((type, i) => {
                    const typeGroup = svg.append("g").attr("class", "interactive-node llm-type-card");

                    // Responsive font sizes based on card dimensions
                    const nameFontSize = Math.min(11, cardWidth / 15) + "px";
                    const useCaseFontSize = Math.min(9, cardWidth / 18) + "px";
                    const capabilityFontSize = Math.min(8, cardWidth / 20) + "px";

                    // Main card rectangle with responsive dimensions
                    typeGroup.append("rect")
                        .attr("x", type.x - cardWidth / 2)
                        .attr("y", type.y - cardHeight / 2)
                        .attr("width", cardWidth)
                        .attr("height", cardHeight)
                        .attr("fill", type.gradient)
                        .attr("rx", Math.min(12, cardWidth / 15))
                        .attr("stroke", type.color)
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.3))");

                    // Type name with responsive positioning
                    typeGroup.append("text")
                        .attr("x", type.x)
                        .attr("y", type.y - cardHeight / 2 + 20)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", nameFontSize)
                        .style("font-weight", "bold")
                        .style("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                        .text(type.name);

                    // Use case with responsive positioning
                    typeGroup.append("text")
                        .attr("x", type.x)
                        .attr("y", type.y - cardHeight / 2 + 35)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", useCaseFontSize)
                        .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                        .text(type.useCase);

                    // Capabilities with responsive positioning and spacing
                    const capabilityStartY = type.y - cardHeight / 2 + 50;
                    const capabilitySpacing = Math.max(10, cardHeight / 8);
                    type.capabilities.slice(0, 2).forEach((cap, j) => {
                        typeGroup.append("text")
                            .attr("x", type.x)
                            .attr("y", capabilityStartY + j * capabilitySpacing)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", capabilityFontSize)
                            .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                            .text(cap);
                    });

                    // Performance indicators
                    const perfX = type.x - 60;
                    const perfY = type.y + 25;

                    // Accuracy bar
                    typeGroup.append("rect")
                        .attr("x", perfX)
                        .attr("y", perfY)
                        .attr("width", type.performance.accuracy * 100)
                        .attr("height", 4)
                        .attr("fill", "var(--accent-green)")
                        .attr("rx", 2);

                    // Speed bar
                    typeGroup.append("rect")
                        .attr("x", perfX)
                        .attr("y", perfY + 8)
                        .attr("width", type.performance.speed * 100)
                        .attr("height", 4)
                        .attr("fill", "var(--accent-blue)")
                        .attr("rx", 2);

                    // Efficiency bar
                    typeGroup.append("rect")
                        .attr("x", perfX)
                        .attr("y", perfY + 16)
                        .attr("width", type.performance.efficiency * 100)
                        .attr("height", 4)
                        .attr("fill", "var(--accent-purple)")
                        .attr("rx", 2);

                    // Performance labels
                    typeGroup.append("text")
                        .attr("x", perfX - 5)
                        .attr("y", perfY + 3)
                        .attr("text-anchor", "end")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "7px")
                        .text("A");

                    typeGroup.append("text")
                        .attr("x", perfX - 5)
                        .attr("y", perfY + 11)
                        .attr("text-anchor", "end")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "7px")
                        .text("S");

                    typeGroup.append("text")
                        .attr("x", perfX - 5)
                        .attr("y", perfY + 19)
                        .attr("text-anchor", "end")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "7px")
                        .text("E");

                    // Add hover interactions
                    typeGroup.on("mouseover", function (event) {
                        d3.select(this).select("rect").attr("stroke-width", 4);
                        const tooltipContent = `<b>${type.name}</b><br><br><strong>Capabilities:</strong><br>${type.capabilities.join(", ")}<br><br><strong>Examples:</strong><br>${type.examples.join(", ")}<br><br><strong>Performance:</strong><br>Accuracy: ${(type.performance.accuracy * 100).toFixed(0)}%<br>Speed: ${(type.performance.speed * 100).toFixed(0)}%<br>Efficiency: ${(type.performance.efficiency * 100).toFixed(0)}%`;
                        showTooltip(event, tooltipContent);
                    })
                        .on("mouseout", function () {
                            d3.select(this).select("rect").attr("stroke-width", 2);
                            hideTooltip();
                        });
                });

                // Add capability matrix visualization
                const matrixX = 50;
                const matrixY = 500;
                const matrixWidth = width - 100;
                const matrixHeight = 80;

                // Capability categories
                const capabilities = ["Reasoning", "Coding", "Multimodal", "Conversation", "Specialization", "Efficiency", "Orchestration", "Chain-of-Thought"];
                const capabilityColors = ["var(--accent-blue)", "var(--accent-green)", "var(--accent-purple)", "var(--accent-cyan)", "var(--accent-blue)", "var(--accent-green)", "var(--accent-purple)", "var(--accent-blue)"];

                // Matrix title
                svg.append("text")
                    .attr("x", matrixX + matrixWidth / 2)
                    .attr("y", matrixY - 10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Capability Matrix - LLM Types vs Core Capabilities");

                // Capability bars
                capabilities.forEach((cap, i) => {
                    const barX = matrixX + i * (matrixWidth / capabilities.length);
                    const barWidth = (matrixWidth / capabilities.length) - 5;

                    // Capability bar
                    svg.append("rect")
                        .attr("x", barX)
                        .attr("y", matrixY)
                        .attr("width", barWidth)
                        .attr("height", 20)
                        .attr("fill", capabilityColors[i])
                        .attr("opacity", 0.7)
                        .attr("rx", 4);

                    // Capability label
                    svg.append("text")
                        .attr("x", barX + barWidth / 2)
                        .attr("y", matrixY + 13)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "8px")
                        .style("font-weight", "bold")
                        .text(cap);
                });

                // Legend
                const legendX = matrixX;
                const legendY = matrixY + 40;

                svg.append("text")
                    .attr("x", legendX)
                    .attr("y", legendY)
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", "10px")
                    .style("font-weight", "bold")
                    .text("Legend: A=Accuracy, S=Speed, E=Efficiency");
            }

            /** Renders the Agentic RAG vs Standard RAG pipeline comparison visualization. */
            function renderAgenticRAGComparisonViz() {
                const container = d3.select("#agentic-rag-comparison-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Enhanced responsive margins with device-specific optimization
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || bounds.width < 600;
                const isTablet = deviceType.type === 'tablet' || (bounds.width >= 600 && bounds.width < 1024);
                
                const margin = { 
                    top: isMobile ? 40 : isTablet ? 50 : 60, 
                    right: isMobile ? 30 : isTablet ? 45 : 60, 
                    bottom: isMobile ? 50 : isTablet ? 65 : 80, 
                    left: isMobile ? 30 : isTablet ? 45 : 60 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Add sophisticated gradient definitions for RAG comparison
                const defs = svg.append("defs");

                // Standard RAG gradient
                const standardRAGGradient = defs.append("linearGradient").attr("id", "standard-rag-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                standardRAGGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-blue)").attr("stop-opacity", 0.8);
                standardRAGGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-blue)").attr("stop-opacity", 0.4);

                // Agentic RAG gradient
                const agenticRAGGradient = defs.append("linearGradient").attr("id", "agentic-rag-gradient").attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                agenticRAGGradient.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-purple)").attr("stop-opacity", 0.9);
                agenticRAGGradient.append("stop").attr("offset", "50%").attr("stop-color", "var(--accent-cyan)").attr("stop-opacity", 0.7);
                agenticRAGGradient.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-green)").attr("stop-opacity", 0.5);

                // Calculate responsive pipeline positioning with optimized alignment
                const pipelineWidth = isMobile ? width * 0.9 : width * 0.4;
                const pipelineSpacing = isMobile ? height * 0.5 : width * 0.1;
                const standardRAGX = isMobile ? width * 0.5 : width * 0.2 + pipelineWidth / 2;
                const agenticRAGX = isMobile ? width * 0.5 : width * 0.8 - pipelineWidth / 2;
                const componentSpacing = isMobile ? 50 : 65;
                const componentRadius = isMobile ? 22 : 28;
                const titleFontSize = isMobile ? "12px" : isTablet ? "13px" : "14px";

                // Standard RAG Pipeline (Left Side or Top on Mobile) with optimized positioning
                const standardRAGY = isMobile ? height * 0.15 : height * 0.25;
                const titleSpacing = isMobile ? 20 : 35;

                // Standard RAG title with responsive positioning and improved spacing
                svg.append("text")
                    .attr("x", standardRAGX)
                    .attr("y", titleSpacing)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-blue)")
                    .style("font-size", titleFontSize)
                    .style("font-weight", "bold")
                    .text("Standard RAG Pipeline");

                // Standard RAG components with responsive positioning
                const standardComponents = [
                    { name: "Query", x: standardRAGX, y: standardRAGY + componentSpacing, color: "var(--accent-blue)", description: "User input query" },
                    { name: "Embedding", x: standardRAGX, y: standardRAGY + (componentSpacing * 2), color: "var(--accent-blue)", description: "Vector embedding generation" },
                    { name: "Retrieval", x: standardRAGX, y: standardRAGY + (componentSpacing * 3), color: "var(--accent-blue)", description: "Vector similarity search" },
                    { name: "Context", x: standardRAGX, y: standardRAGY + (componentSpacing * 4), color: "var(--accent-blue)", description: "Retrieved documents" },
                    { name: "Generation", x: standardRAGX, y: standardRAGY + (componentSpacing * 5), color: "var(--accent-blue)", description: "LLM response generation" },
                    { name: "Response", x: standardRAGX, y: standardRAGY + (componentSpacing * 6), color: "var(--accent-blue)", description: "Final answer" }
                ];

                // Render Standard RAG components
                standardComponents.forEach((comp, i) => {
                    const compGroup = svg.append("g").attr("class", "interactive-node standard-rag-component");

                    // Component circle with responsive sizing
                    compGroup.append("circle")
                        .attr("cx", comp.x)
                        .attr("cy", comp.y)
                        .attr("r", componentRadius)
                        .attr("fill", "url(#standard-rag-gradient)")
                        .attr("stroke", comp.color)
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Component name with responsive font sizing
                    const componentFontSize = isMobile ? "8px" : isTablet ? "8.5px" : "9px";
                    compGroup.append("text")
                        .attr("x", comp.x)
                        .attr("y", comp.y + (isMobile ? 3 : 4))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", componentFontSize)
                        .style("font-weight", "bold")
                        .text(comp.name);

                    // Add arrows between components with responsive positioning
                    if (i < standardComponents.length - 1) {
                        svg.append("path")
                            .attr("d", `M ${comp.x} ${comp.y + componentRadius} L ${comp.x} ${standardComponents[i + 1].y - componentRadius}`)
                            .attr("stroke", comp.color)
                            .attr("stroke-width", isMobile ? 1.5 : 2)
                            .attr("marker-end", "url(#arrowhead-standard)");
                    }

                    // Add hover interactions
                    compGroup.on("mouseover", function (event) {
                        d3.select(this).select("circle").attr("stroke-width", 4);
                        showTooltip(event, `<b>${comp.name}</b><br>${comp.description}`);
                    })
                        .on("mouseout", function () {
                            d3.select(this).select("circle").attr("stroke-width", 2);
                            hideTooltip();
                        });
                });

                // Agentic RAG Pipeline (Right Side or Bottom on Mobile) with optimized positioning
                const agenticRAGY = isMobile ? height * 0.75 : height * 0.25;

                // Agentic RAG title with responsive positioning and improved spacing
                svg.append("text")
                    .attr("x", agenticRAGX)
                    .attr("y", isMobile ? height * 0.55 : titleSpacing)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-purple)")
                    .style("font-size", titleFontSize)
                    .style("font-weight", "bold")
                    .text("Agentic RAG Pipeline");

                // Agentic RAG components with intelligent routing and responsive positioning
                const agenticComponents = [
                    { name: "Query", x: agenticRAGX, y: agenticRAGY + componentSpacing, color: "var(--accent-purple)", description: "User input query" },
                    { name: "Query Analysis", x: agenticRAGX, y: agenticRAGY + (componentSpacing * 2), color: "var(--accent-purple)", description: "Intelligent query understanding" },
                    { name: "Route Decision", x: agenticRAGX, y: agenticRAGY + (componentSpacing * 3), color: "var(--accent-cyan)", description: "Multi-step reasoning & routing" },
                    { name: "Multi-Retrieval", x: agenticRAGX, y: agenticRAGY + (componentSpacing * 4), color: "var(--accent-green)", description: "Dynamic retrieval strategies" },
                    { name: "Context Synthesis", x: agenticRAGX, y: agenticRAGY + (componentSpacing * 5), color: "var(--accent-purple)", description: "Intelligent context assembly" },
                    { name: "Response", x: agenticRAGX, y: agenticRAGY + (componentSpacing * 6), color: "var(--accent-purple)", description: "Enhanced final answer" }
                ];

                // Render Agentic RAG components
                agenticComponents.forEach((comp, i) => {
                    const compGroup = svg.append("g").attr("class", "interactive-node agentic-rag-component");

                    // Component circle with responsive sizing
                    compGroup.append("circle")
                        .attr("cx", comp.x)
                        .attr("cy", comp.y)
                        .attr("r", componentRadius)
                        .attr("fill", "url(#agentic-rag-gradient)")
                        .attr("stroke", comp.color)
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Component name with responsive font sizing
                    const componentFontSize = isMobile ? "8px" : isTablet ? "8.5px" : "9px";
                    compGroup.append("text")
                        .attr("x", comp.x)
                        .attr("y", comp.y + (isMobile ? 3 : 4))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", componentFontSize)
                        .style("font-weight", "bold")
                        .text(comp.name);

                    // Add arrows between components with responsive positioning
                    if (i < agenticComponents.length - 1) {
                        svg.append("path")
                            .attr("d", `M ${comp.x} ${comp.y + componentRadius} L ${comp.x} ${agenticComponents[i + 1].y - componentRadius}`)
                            .attr("stroke", comp.color)
                            .attr("stroke-width", isMobile ? 1.5 : 2)
                            .attr("marker-end", "url(#arrowhead-agentic)");
                    }

                    // Add hover interactions
                    compGroup.on("mouseover", function (event) {
                        d3.select(this).select("circle").attr("stroke-width", 4);
                        showTooltip(event, `<b>${comp.name}</b><br>${comp.description}`);
                    })
                        .on("mouseout", function () {
                            d3.select(this).select("circle").attr("stroke-width", 2);
                            hideTooltip();
                        });
                });

                // Add arrow marker definitions
                defs.append("marker")
                    .attr("id", "arrowhead-standard")
                    .attr("markerWidth", "10")
                    .attr("markerHeight", "7")
                    .attr("refX", "9")
                    .attr("refY", "3.5")
                    .attr("orient", "auto")
                    .append("polygon")
                    .attr("points", "0 0, 10 3.5, 0 7")
                    .attr("fill", "var(--accent-blue)");

                defs.append("marker")
                    .attr("id", "arrowhead-agentic")
                    .attr("markerWidth", "10")
                    .attr("markerHeight", "7")
                    .attr("refX", "9")
                    .attr("refY", "3.5")
                    .attr("orient", "auto")
                    .append("polygon")
                    .attr("points", "0 0, 10 3.5, 0 7")
                    .attr("fill", "var(--accent-purple)");

                // Comparison metrics with optimized positioning
                const metricsY = isMobile ? height * 0.85 : height * 0.65;
                const metricsSpacing = isMobile ? 20 : 25;
                const metrics = [
                    { metric: "Query Understanding", standard: 0.6, agentic: 0.9, color: "var(--accent-blue)" },
                    { metric: "Retrieval Accuracy", standard: 0.7, agentic: 0.85, color: "var(--accent-green)" },
                    { metric: "Context Relevance", standard: 0.65, agentic: 0.88, color: "var(--accent-cyan)" },
                    { metric: "Response Quality", standard: 0.75, agentic: 0.92, color: "var(--accent-purple)" },
                    { metric: "Multi-step Reasoning", standard: 0.3, agentic: 0.85, color: "var(--accent-blue)" },
                    { metric: "Adaptability", standard: 0.4, agentic: 0.9, color: "var(--accent-green)" }
                ];

                // Metrics title with improved positioning
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", metricsY - 25)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "11px" : "12px")
                    .style("font-weight", "bold")
                    .text("Performance Comparison: Standard RAG vs Agentic RAG");

                // Render metrics bars with optimized spacing
                metrics.forEach((metric, i) => {
                    const barY = metricsY + i * metricsSpacing;
                    const barWidth = width * 0.8;
                    const barHeight = isMobile ? 12 : 15;

                    // Metric label
                    svg.append("text")
                        .attr("x", 20)
                        .attr("y", barY + 10)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(metric.metric);

                    // Standard RAG bar
                    svg.append("rect")
                        .attr("x", 150)
                        .attr("y", barY)
                        .attr("width", metric.standard * (barWidth - 200))
                        .attr("height", barHeight)
                        .attr("fill", "var(--accent-blue)")
                        .attr("opacity", 0.7)
                        .attr("rx", 3);

                    // Agentic RAG bar
                    svg.append("rect")
                        .attr("x", 150)
                        .attr("y", barY)
                        .attr("width", metric.agentic * (barWidth - 200))
                        .attr("height", barHeight)
                        .attr("fill", metric.color)
                        .attr("opacity", 0.9)
                        .attr("rx", 3);

                    // Performance values
                    svg.append("text")
                        .attr("x", 160)
                        .attr("y", barY + 10)
                        .attr("fill", "white")
                        .style("font-size", "9px")
                        .style("font-weight", "bold")
                        .text((metric.standard * 100).toFixed(0) + "%");

                    svg.append("text")
                        .attr("x", 160)
                        .attr("y", barY + 10)
                        .attr("fill", "white")
                        .style("font-size", "9px")
                        .style("font-weight", "bold")
                        .text((metric.agentic * 100).toFixed(0) + "%");
                });

                // Key differences summary with optimized positioning
                const summaryY = isMobile ? height - 15 : height - 25;
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", summaryY)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--text-secondary)")
                    .style("font-size", isMobile ? "9px" : "10px")
                    .style("font-family", "Roboto Mono")
                    .text("Agentic RAG: Intelligent routing + Multi-step reasoning + Dynamic retrieval = 25% better performance");
            }

            /** Renders the Agentic Frameworks comparison visualization with competition-level enhancements. */
            function renderAgenticFrameworksViz() {
                const container = d3.select("#agentic-frameworks-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 60, right: 40, bottom: 80, left: 40 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Advanced gradient definitions for sophisticated visual effects
                const defs = svg.append("defs");
                const frameworkGradients = [
                    { id: "langgraph-grad", colors: ["#3A86FF", "#60A5FA", "#93C5FD"] },
                    { id: "autogen-grad", colors: ["#2EC4B6", "#34D399", "#6EE7B7"] },
                    { id: "crewai-grad", colors: ["#8338EC", "#A855F7", "#C084FC"] }
                ];

                frameworkGradients.forEach(grad => {
                    const gradient = defs.append("radialGradient").attr("id", grad.id).attr("cx", "30%").attr("cy", "30%").attr("r", "70%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[2]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.8);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.7);
                });

                // Enhanced framework data with optimized positioning and spacing
                const calculateFrameworkPositions = (width, height) => {
                    const minSpacing = Math.max(200, width * 0.28); // Increased minimum spacing for better separation
                    const centerY = height * 0.42; // Optimized vertical positioning for better balance
                    
                    // Calculate optimal positions with enhanced spacing and responsive margins
                    const positions = [];
                    const totalWidth = Math.min(width * 0.75, width - 200); // Increased margins for better spacing
                    const startX = (width - totalWidth) / 2;
                    
                    // Improved spacing calculation with better distribution
                    const spacing = Math.max(minSpacing, totalWidth / 2.5); // Better spacing ratio
                    
                    for (let i = 0; i < 3; i++) {
                        positions.push({
                            x: startX + (spacing * i),
                            y: centerY
                        });
                    }
                    
                    return positions;
                };
                
                const frameworkPositions = calculateFrameworkPositions(width, height);
                
                const frameworks = [
                    {
                        name: "LangGraph",
                        x: frameworkPositions[0].x,
                        y: frameworkPositions[0].y,
                        color: "url(#langgraph-grad)",
                        complexity: 85,
                        flexibility: 90,
                        enterprise: 75,
                        community: 80,
                        tooltip: "<b>LangGraph</b><br><span style='color:#3A86FF'>●</span> State-based workflow orchestration<br><b>Complexity:</b> 85/100<br><b>Flexibility:</b> 90/100<br><b>Enterprise:</b> 75/100<br><b>Community:</b> 80/100<br><br>Advanced state management with conditional branching, loop handling, and stateful agent interactions. Ideal for deterministic workflows requiring precise control flow."
                    },
                    {
                        name: "AutoGen",
                        x: frameworkPositions[1].x,
                        y: frameworkPositions[1].y,
                        color: "url(#autogen-grad)",
                        complexity: 70,
                        flexibility: 95,
                        enterprise: 60,
                        community: 85,
                        tooltip: "<b>AutoGen</b><br><span style='color:#2EC4B6'>●</span> Multi-agent conversation framework<br><b>Complexity:</b> 70/100<br><b>Flexibility:</b> 95/100<br><b>Enterprise:</b> 60/100<br><b>Community:</b> 85/100<br><br>Enables collaborative problem-solving between specialized agents with role-based interactions, code execution, and iterative refinement."
                    },
                    {
                        name: "CrewAI",
                        x: frameworkPositions[2].x,
                        y: frameworkPositions[2].y,
                        color: "url(#crewai-grad)",
                        complexity: 60,
                        flexibility: 75,
                        enterprise: 95,
                        community: 70,
                        tooltip: "<b>CrewAI</b><br><span style='color:#8338EC'>●</span> Enterprise agent orchestration<br><b>Complexity:</b> 60/100<br><b>Flexibility:</b> 75/100<br><b>Enterprise:</b> 95/100<br><b>Community:</b> 70/100<br><br>Hierarchical team structures with role-based task delegation. Implements project management paradigms with defined roles and deliverable tracking."
                    }
                ];

                // Add animated background patterns
                svg.append("rect").attr("width", width).attr("height", height).attr("fill", "rgba(224, 224, 224, 0.05)");
                
                // Add comparison legend for enhanced clarity
                const legendGroup = svg.append("g").attr("class", "comparison-legend");
                const legendY = height * 0.85;
                const legendItems = [
                    { label: "Complexity", color: "#3A86FF", x: width * 0.15 },
                    { label: "Flexibility", color: "#2EC4B6", x: width * 0.35 },
                    { label: "Enterprise", color: "#8338EC", x: width * 0.55 },
                    { label: "Community", color: "#FFB700", x: width * 0.75 }
                ];
                
                legendItems.forEach(item => {
                    const legendItem = legendGroup.append("g");
                    
                    // Legend indicator circle
                    legendItem.append("circle")
                        .attr("cx", item.x)
                        .attr("cy", legendY)
                        .attr("r", 8)
                        .attr("fill", item.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 1);
                    
                    // Legend label
                    legendItem.append("text")
                        .attr("x", item.x)
                        .attr("y", legendY + 20)
                        .attr("text-anchor", "middle")
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .text(item.label);
                });

                // Create framework nodes with advanced visual effects
                frameworks.forEach((f, index) => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, f.tooltip)).on("mouseout", hideTooltip);

                    // Animated pulsing background with performance optimization
                    const pulseGroup = g.append("g");
                    const shouldAnimate = window.innerWidth > 768 && !window.matchMedia('(prefers-reduced-motion)').matches;
                    
                    if (shouldAnimate) {
                        pulseGroup.append("circle")
                            .attr("cx", f.x).attr("cy", f.y).attr("r", 80)
                            .attr("fill", f.color).attr("opacity", 0.1)
                            .style("animation", `pulse 2s ease-in-out infinite ${index * 0.5}s`);
                    } else {
                        // Static version for performance
                        pulseGroup.append("circle")
                            .attr("cx", f.x).attr("cy", f.y).attr("r", 80)
                            .attr("fill", f.color).attr("opacity", 0.1);
                    }

                    // Main framework circle with gradient and enhanced styling
                    g.append("circle")
                        .attr("cx", f.x).attr("cy", f.y).attr("r", 70)
                        .attr("fill", f.color)
                        .attr("stroke", "rgba(255, 255, 255, 0.4)")
                        .attr("stroke-width", 3)
                        .style("filter", "drop-shadow(0 6px 16px rgba(0,0,0,0.4))");

                    // Framework name with enhanced typography
                    g.append("text")
                        .attr("x", f.x).attr("y", f.y - 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-weight", "700")
                        .style("font-size", "16px")
                        .style("text-shadow", "0 2px 4px rgba(0,0,0,0.5)")
                        .text(f.name);

                    // Add capability indicators around each framework with improved positioning
                    const capabilities = [
                        { label: "Complexity", value: f.complexity, angle: -45 },
                        { label: "Flexibility", value: f.flexibility, angle: 0 },
                        { label: "Enterprise", value: f.enterprise, angle: 45 },
                        { label: "Community", value: f.community, angle: 90 }
                    ];

                    // Calculate optimal capability indicator positions with enhanced collision avoidance
                    const calculateCapabilityPosition = (angle, frameworkRadius, indicatorRadius) => {
                        const angleRad = (angle * Math.PI) / 180;
                        const baseRadius = frameworkRadius + indicatorRadius + 15; // Increased gap to 15px
                        
                        // Calculate base position
                        let x = f.x + Math.cos(angleRad) * baseRadius;
                        let y = f.y + Math.sin(angleRad) * baseRadius;
                        
                        // Enhanced collision detection with improved name area calculation
                        const nameArea = { x: f.x - 40, y: f.y - 25, width: 80, height: 30 }; // Expanded name area
                        const indicatorArea = { x: x - indicatorRadius, y: y - indicatorRadius, width: indicatorRadius * 2, height: indicatorRadius * 2 };
                        
                        // Check for collision with framework name area
                        if (indicatorArea.x < nameArea.x + nameArea.width && 
                            indicatorArea.x + indicatorArea.width > nameArea.x &&
                            indicatorArea.y < nameArea.y + nameArea.height && 
                            indicatorArea.y + indicatorArea.height > nameArea.y) {
                            
                            // Improved collision avoidance with better positioning logic
                            if (angle >= -90 && angle <= 90) {
                                // Top half - move further up to avoid name collision
                                y = f.y - 50;
                                // Adjust x to maintain visual balance
                                x = f.x + Math.cos(angleRad) * (frameworkRadius + 25);
                            } else {
                                // Bottom half - move further down
                                y = f.y + 50;
                                // Adjust x to maintain visual balance
                                x = f.x + Math.cos(angleRad) * (frameworkRadius + 25);
                            }
                        }
                        
                        // Enhanced boundary checking with responsive margins
                        const margin = Math.max(25, width * 0.05); // Responsive margin
                        x = Math.max(margin, Math.min(width - margin, x));
                        y = Math.max(margin, Math.min(height - margin, y));
                        
                        return { x, y };
                    };

                    capabilities.forEach((cap, i) => {
                        const angle = cap.angle;
                        const indicatorRadius = 12;
                        const frameworkRadius = 70;
                        
                        const pos = calculateCapabilityPosition(angle, frameworkRadius, indicatorRadius);
                        const angleRad = (angle * Math.PI) / 180;

                        // Capability indicator line with improved styling
                        g.append("line")
                            .attr("x1", f.x + Math.cos(angleRad) * frameworkRadius)
                            .attr("y1", f.y + Math.sin(angleRad) * frameworkRadius)
                            .attr("x2", pos.x)
                            .attr("y2", pos.y)
                            .attr("stroke", "rgba(255, 255, 255, 0.5)")
                            .attr("stroke-width", 2)
                            .attr("stroke-linecap", "round");

                        // Capability score circle with enhanced styling
                        g.append("circle")
                            .attr("cx", pos.x)
                            .attr("cy", pos.y)
                            .attr("r", indicatorRadius)
                            .attr("fill", f.color)
                            .attr("stroke", "white")
                            .attr("stroke-width", 2)
                            .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                        // Score text with improved typography
                        g.append("text")
                            .attr("x", pos.x)
                            .attr("y", pos.y + 4)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", "11px")
                            .style("font-weight", "700")
                            .style("text-shadow", "0 1px 2px rgba(0,0,0,0.5)")
                            .text(cap.value);

                        // Capability label with enhanced positioning and collision avoidance
                        const labelDistance = 25; // Increased distance for better separation
                        let labelX = pos.x + Math.cos(angleRad) * labelDistance;
                        let labelY = pos.y + Math.sin(angleRad) * labelDistance + 4;
                        
                        // Enhanced label positioning to avoid overlaps with other elements
                        const labelArea = { x: labelX - 20, y: labelY - 8, width: 40, height: 16 };
                        
                        // Check for collision with framework name and adjust if needed
                        const frameworkNameArea = { x: f.x - 50, y: f.y - 30, width: 100, height: 20 };
                        if (labelArea.x < frameworkNameArea.x + frameworkNameArea.width && 
                            labelArea.x + labelArea.width > frameworkNameArea.x &&
                            labelArea.y < frameworkNameArea.y + frameworkNameArea.height && 
                            labelArea.y + labelArea.height > frameworkNameArea.y) {
                            
                            // Adjust label position to avoid collision
                            if (angle >= -90 && angle <= 90) {
                                labelY = f.y - 60; // Move further up
                            } else {
                                labelY = f.y + 60; // Move further down
                            }
                        }
                        
                        // Ensure label stays within bounds
                        const margin = Math.max(30, width * 0.06);
                        labelX = Math.max(margin, Math.min(width - margin, labelX));
                        labelY = Math.max(margin, Math.min(height - margin, labelY));
                        
                        g.append("text")
                            .attr("x", labelX)
                            .attr("y", labelY)
                            .attr("text-anchor", "middle")
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", "10px")
                            .style("font-weight", "600")
                            .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                            .text(cap.label);
                    });

                    // Add workflow visualization for each framework
                    if (f.name === "LangGraph") {
                        const workflowNodes = [
                            { x: f.x - 40, y: f.y + 100, label: "State" },
                            { x: f.x - 10, y: f.y + 100, label: "Action" },
                            { x: f.x + 20, y: f.y + 100, label: "Update" },
                            { x: f.x + 50, y: f.y + 100, label: "Next" }
                        ];

                        workflowNodes.forEach((node, i) => {
                            g.append("rect")
                                .attr("x", node.x - 15).attr("y", node.y - 8)
                                .attr("width", 30).attr("height", 16)
                                .attr("fill", f.color).attr("rx", 3)
                                .attr("opacity", 0.8);

                            g.append("text")
                                .attr("x", node.x).attr("y", node.y + 3)
                                .attr("text-anchor", "middle")
                                .attr("fill", "white")
                                .style("font-size", "9px")
                                .style("font-weight", "500")
                                .text(node.label);

                            if (i < workflowNodes.length - 1) {
                                g.append("line")
                                    .attr("x1", node.x + 15).attr("y1", node.y)
                                    .attr("x2", workflowNodes[i + 1].x - 15).attr("y2", workflowNodes[i + 1].y)
                                    .attr("stroke", f.color)
                                    .attr("stroke-width", 2)
                                    .attr("opacity", 0.6);
                            }
                        });
                    } else if (f.name === "AutoGen") {
                        // Multi-agent conversation flow
                        const agents = [
                            { x: f.x - 30, y: f.y + 100, label: "Agent A" },
                            { x: f.x, y: f.y + 100, label: "Coordinator" },
                            { x: f.x + 30, y: f.y + 100, label: "Agent B" }
                        ];

                        agents.forEach((agent, i) => {
                            g.append("circle")
                                .attr("cx", agent.x).attr("cy", agent.y).attr("r", 12)
                                .attr("fill", f.color).attr("opacity", 0.8);

                            g.append("text")
                                .attr("x", agent.x).attr("y", agent.y + 3)
                                .attr("text-anchor", "middle")
                                .attr("fill", "white")
                                .style("font-size", "8px")
                                .style("font-weight", "500")
                                .text(agent.label);

                            if (i < agents.length - 1) {
                                g.append("line")
                                    .attr("x1", agent.x + 12).attr("y1", agent.y)
                                    .attr("x2", agents[i + 1].x - 12).attr("y2", agents[i + 1].y)
                                    .attr("stroke", f.color)
                                    .attr("stroke-width", 2)
                                    .attr("opacity", 0.6)
                                    .style("stroke-dasharray", "3,3");
                            }
                        });
                    } else if (f.name === "CrewAI") {
                        // Hierarchical team structure
                        const hierarchy = [
                            { x: f.x, y: f.y + 100, label: "Manager", level: 0 },
                            { x: f.x - 25, y: f.y + 120, label: "Agent 1", level: 1 },
                            { x: f.x + 25, y: f.y + 120, label: "Agent 2", level: 1 }
                        ];

                        hierarchy.forEach((member, i) => {
                            const size = member.level === 0 ? 15 : 10;
                            g.append("rect")
                                .attr("x", member.x - size / 2).attr("y", member.y - size / 2)
                                .attr("width", size).attr("height", size)
                                .attr("fill", f.color).attr("rx", 2)
                                .attr("opacity", 0.8);

                            g.append("text")
                                .attr("x", member.x).attr("y", member.y + 3)
                                .attr("text-anchor", "middle")
                                .attr("fill", "white")
                                .style("font-size", member.level === 0 ? "9px" : "7px")
                                .style("font-weight", "500")
                                .text(member.label);

                            if (member.level === 1) {
                                g.append("line")
                                    .attr("x1", f.x).attr("y1", f.y + 100 + 7.5)
                                    .attr("x2", member.x).attr("y2", member.y - 5)
                                    .attr("stroke", f.color)
                                    .attr("stroke-width", 2)
                                    .attr("opacity", 0.6);
                            }
                        });
                    }
                });

                // Add comparison matrix at the bottom
                const matrixY = height - 20;
                const matrixData = [
                    { framework: "LangGraph", metrics: { complexity: 85, flexibility: 90, enterprise: 75, community: 80 } },
                    { framework: "AutoGen", metrics: { complexity: 70, flexibility: 95, enterprise: 60, community: 85 } },
                    { framework: "CrewAI", metrics: { complexity: 60, flexibility: 75, enterprise: 95, community: 70 } }
                ];

                const metricLabels = ["Complexity", "Flexibility", "Enterprise", "Community"];
                const barWidth = width / (matrixData.length * metricLabels.length + 1);

                matrixData.forEach((data, i) => {
                    metricLabels.forEach((metric, j) => {
                        const x = (i * metricLabels.length + j + 1) * barWidth;
                        const value = data.metrics[metric.toLowerCase()];
                        const barHeight = (value / 100) * 30;

                        svg.append("rect")
                            .attr("x", x).attr("y", matrixY - barHeight)
                            .attr("width", barWidth * 0.8).attr("height", barHeight)
                            .attr("fill", frameworks[i].color)
                            .attr("opacity", 0.7)
                            .attr("rx", 2);

                        svg.append("text")
                            .attr("x", x + barWidth * 0.4).attr("y", matrixY + 12)
                            .attr("text-anchor", "middle")
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", "8px")
                            .text(metric);
                    });
                });

                // Add CSS animation for pulsing effect
                if (!document.getElementById('framework-animations')) {
                    const style = document.createElement('style');
                    style.id = 'framework-animations';
                    style.textContent = `
                    @keyframes pulse {
                        0%, 100% { opacity: 0.1; transform: scale(1); }
                        50% { opacity: 0.2; transform: scale(1.05); }
                    }
                `;
                    document.head.appendChild(style);
                }
            }

            /** Renders the Fine-Tuning Techniques quadrant visualization with advanced design. */
            function renderFineTuningTechniquesViz() {
                const container = d3.select("#fine-tuning-techniques-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 60, right: 60, bottom: 60, left: 60 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Gradient definitions for sophisticated backgrounds
                const defs = svg.append("defs");
                const quadrantGradients = [
                    { id: "q1-gradient", colors: ["var(--color-alignment)", "var(--accent-blue-dark)"] },
                    { id: "q2-gradient", colors: ["var(--color-efficiency)", "var(--accent-green-dark)"] },
                    { id: "q3-gradient", colors: ["var(--color-model)", "var(--accent-purple-dark)"] },
                    { id: "q4-gradient", colors: ["var(--color-compute)", "var(--accent-orange-dark)"] }
                ];

                quadrantGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.1);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.2);
                });

                // Quadrant backgrounds with gradient fills
                const quadrants = [
                    { x: width / 2, y: 0, w: width / 2, h: height / 2, fill: "url(#q1-gradient)", label: "High Compute\nAlignment-Focused" },
                    { x: 0, y: 0, w: width / 2, h: height / 2, fill: "url(#q2-gradient)", label: "High Compute\nPerformance-Focused" },
                    { x: 0, y: height / 2, w: width / 2, h: height / 2, fill: "url(#q3-gradient)", label: "Low Compute\nPerformance-Focused" },
                    { x: width / 2, y: height / 2, w: width / 2, h: height / 2, fill: "url(#q4-gradient)", label: "Low Compute\nAlignment-Focused" }
                ];

                quadrants.forEach(q => {
                    svg.append("rect").attr("x", q.x).attr("y", q.y).attr("width", q.w).attr("height", q.h).attr("fill", q.fill);
                    const lines = q.label.split('\n');
                    lines.forEach((line, i) => {
                        svg.append("text").attr("x", q.x + q.w / 2).attr("y", q.y + 20 + (i * 12)).attr("text-anchor", "middle").attr("fill", "var(--text-secondary)").style("font-size", "var(--text-base)").style("font-weight", "var(--font-medium)").style("font-family", "var(--font-primary)").text(line);
                    });
                });

                // Axis lines with enhanced styling
                svg.append("line").attr("x1", 0).attr("y1", height / 2).attr("x2", width).attr("y2", height / 2).attr("stroke", "var(--text-primary)").attr("stroke-width", 2).attr("opacity", 0.6);
                svg.append("line").attr("x1", width / 2).attr("y1", 0).attr("x2", width / 2).attr("y2", height).attr("stroke", "var(--text-primary)").attr("stroke-width", 2).attr("opacity", 0.6);

                // Axis labels with enhanced typography
                svg.append("text").attr("x", width).attr("y", height / 2 - 10).attr("text-anchor", "end").attr("fill", "var(--text-primary)").style("font-weight", "var(--font-semibold)").style("font-family", "var(--font-primary)").style("font-size", "var(--text-md)").text("Alignment Focused →");
                svg.append("text").attr("x", 5).attr("y", height / 2 - 10).attr("fill", "var(--text-primary)").style("font-weight", "var(--font-semibold)").style("font-family", "var(--font-primary)").style("font-size", "var(--text-md)").text("← Performance Focused");
                svg.append("text").attr("x", width / 2 - 10).attr("y", 15).attr("text-anchor", "end").attr("fill", "var(--text-primary)").style("font-weight", "var(--font-semibold)").style("font-family", "var(--font-primary)").style("font-size", "var(--text-md)").text("↑ High Compute");
                svg.append("text").attr("x", width / 2 - 10).attr("y", height - 5).attr("text-anchor", "end").attr("fill", "var(--text-primary)").style("font-weight", "var(--font-semibold)").style("font-family", "var(--font-primary)").style("font-size", "var(--text-md)").text("↓ Low Compute");

                // Techniques positioned strategically with size encoding efficiency and semantic colors
                const techniques = [
                    { name: "SFT", x: 0.35, y: 0.35, size: 12, color: "var(--color-efficiency)", tooltip: "<b>Supervised Fine-Tuning (SFT)</b><br>Task-specific adaptation using curated instruction-response pairs. Foundation technique requiring substantial compute but optimizing for performance over alignment. Essential baseline for domain adaptation." },
                    { name: "RLHF", x: 0.75, y: 0.3, size: 16, color: "var(--color-alignment)", tooltip: "<b>Reinforcement Learning from Human Feedback</b><br>Complex alignment technique using reward models and policy optimization. High computational cost but excellent for human preference alignment. Gold standard for safety-critical applications." },
                    { name: "PPO", x: 0.8, y: 0.25, size: 14, color: "var(--accent-blue-dark)", tooltip: "<b>Proximal Policy Optimization</b><br>Stable policy gradient method used in RLHF pipelines. Balances exploration and exploitation while maintaining training stability. Critical component in human feedback optimization loops." },
                    { name: "DPO", x: 0.65, y: 0.6, size: 14, color: "var(--color-compute)", tooltip: "<b>Direct Preference Optimization</b><br>Simplified alignment approach that directly optimizes preference pairs. Lower computational overhead than RLHF while achieving comparable alignment quality. Emerging as preferred method for resource-constrained environments." },
                    { name: "LoRA", x: 0.25, y: 0.7, size: 18, color: "var(--color-model)", tooltip: "<b>Low-Rank Adaptation</b><br>Parameter-efficient technique achieving 99% parameter reduction. Freezes base weights and trains small adapter matrices. Revolutionary for democratizing fine-tuning access across resource constraints." },
                    { name: "QLoRA", x: 0.15, y: 0.75, size: 20, color: "var(--accent-purple-dark)", tooltip: "<b>Quantized LoRA</b><br>Combines 4-bit quantization with LoRA for extreme efficiency. Enables 65B+ model fine-tuning on single GPUs. Game-changing technique for widespread model customization." },
                    { name: "GRPO", x: 0.7, y: 0.8, size: 13, color: "var(--accent-orange-dark)", tooltip: "<b>Group Relative Policy Optimization</b><br>Advanced preference learning for multi-objective scenarios. Handles conflicting preferences through sophisticated group-based modeling. Cutting-edge technique for complex stakeholder requirements." }
                ];

                // Add connecting lines showing relationships
                const relationships = [
                    { from: "SFT", to: "RLHF", style: "solid" },
                    { from: "RLHF", to: "PPO", style: "dashed" },
                    { from: "RLHF", to: "DPO", style: "dotted" },
                    { from: "LoRA", to: "QLoRA", style: "solid" }
                ];

                relationships.forEach(rel => {
                    const from = techniques.find(t => t.name === rel.from);
                    const to = techniques.find(t => t.name === rel.to);
                    if (from && to) {
                        svg.append("line")
                            .attr("x1", from.x * width).attr("y1", from.y * height)
                            .attr("x2", to.x * width).attr("y2", to.y * height)
                            .attr("stroke", "var(--text-secondary)")
                            .attr("stroke-width", 1)
                            .attr("stroke-dasharray", rel.style === "dashed" ? "5,5" : rel.style === "dotted" ? "2,2" : "none")
                            .attr("opacity", 0.4);
                    }
                });

                // Render technique nodes with sophisticated styling
                techniques.forEach(t => {
                    const g = svg.append("g").attr("class", "interactive-node").on("mouseover", (e) => showTooltip(e, t.tooltip)).on("mouseout", hideTooltip);

                    // Outer glow effect
                    g.append("circle")
                        .attr("cx", t.x * width).attr("cy", t.y * height)
                        .attr("r", t.size + 4)
                        .attr("fill", t.color)
                        .attr("opacity", 0.2);

                    // Main node circle with gradient
                    g.append("circle")
                        .attr("cx", t.x * width).attr("cy", t.y * height)
                        .attr("r", t.size)
                        .attr("fill", t.color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2)
                        .style("filter", "drop-shadow(0px 2px 4px rgba(0,0,0,0.3))");

                    // Technique label with enhanced typography
                    g.append("text")
                        .attr("x", t.x * width).attr("y", t.y * height + 4)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-weight", "var(--font-semibold)")
                        .style("font-size", `${Math.max(9, t.size - 5)}px`)
                        .style("font-family", "var(--font-primary)")
                        .text(t.name);
                });

                // Add legend explaining size encoding with consistent typography
                svg.append("text").attr("x", 10).attr("y", height - 10).attr("fill", "var(--text-secondary)").style("font-size", "var(--text-sm)").style("font-family", "var(--font-primary)").style("font-weight", "var(--font-medium)").text("Circle size indicates parameter efficiency (larger = more efficient)");
            }

            /** Renders the Real-Time Cost/Performance Calculator with interactive controls. */
            function renderCostPerformanceCalculatorViz() {
                const container = d3.select("#cost-performance-calculator-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                const margin = { top: 40, right: 40, bottom: 80, left: 40 };
                const width = bounds.width - margin.left - margin.right; const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Model data with real pricing and performance metrics
                const models = [
                    { name: "GPT-4", provider: "OpenAI", inputCost: 0.03, outputCost: 0.06, tokensPerSec: 60, latency: 1.2, context: 128000, capabilities: ["Text", "Code", "Vision"] },
                    { name: "Claude-3.5", provider: "Anthropic", inputCost: 0.003, outputCost: 0.015, tokensPerSec: 75, latency: 0.8, context: 200000, capabilities: ["Text", "Code", "Vision"] },
                    { name: "Llama 3.1", provider: "Meta", inputCost: 0.0008, outputCost: 0.0008, tokensPerSec: 85, latency: 0.6, context: 128000, capabilities: ["Text", "Code"] },
                    { name: "Gemini Pro", provider: "Google", inputCost: 0.0005, outputCost: 0.0015, tokensPerSec: 70, latency: 1.0, context: 2000000, capabilities: ["Text", "Code", "Vision", "Audio"] },
                    { name: "Mixtral 8x7B", provider: "Mistral", inputCost: 0.00027, outputCost: 0.00027, tokensPerSec: 90, latency: 0.5, context: 32000, capabilities: ["Text", "Code"] },
                    { name: "Command R+", provider: "Cohere", inputCost: 0.001, outputCost: 0.003, tokensPerSec: 80, latency: 0.7, context: 128000, capabilities: ["Text", "RAG"] }
                ];

                // Responsive interactive controls
                const isMobile = width < 768;
                const isTablet = width < 1024 && width >= 768;
                const controlsY = 20;
                const controlsWidth = Math.min(200, width * 0.4);
                const controlsSpacing = isMobile ? 60 : 40;
                const sliderHeight = isMobile ? 30 : 20;
                const handleRadius = isMobile ? 12 : 8;

                // Input tokens slider
                svg.append("text")
                    .attr("x", 10)
                    .attr("y", controlsY)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "14px" : "12px")
                    .style("font-weight", "600")
                    .text("Input Tokens:");
                
                const inputTokensSlider = svg.append("g").attr("class", "slider-group");
                inputTokensSlider.append("rect")
                    .attr("x", 10)
                    .attr("y", controlsY + 5)
                    .attr("width", controlsWidth)
                    .attr("height", sliderHeight)
                    .attr("fill", "rgba(27, 38, 59, 0.8)")
                    .attr("rx", sliderHeight / 2);
                
                const inputTokensHandle = inputTokensSlider.append("circle")
                    .attr("cx", 110)
                    .attr("cy", controlsY + 5 + sliderHeight / 2)
                    .attr("r", handleRadius)
                    .attr("fill", "var(--accent-blue)")
                    .style("cursor", "pointer");
                
                const inputTokensValue = svg.append("text")
                    .attr("x", 220)
                    .attr("y", controlsY + 20)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "12px" : "11px")
                    .text("1000 tokens");

                // Output tokens slider
                svg.append("text")
                    .attr("x", 10)
                    .attr("y", controlsY + controlsSpacing)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "14px" : "12px")
                    .style("font-weight", "600")
                    .text("Output Tokens:");
                
                const outputTokensSlider = svg.append("g").attr("class", "slider-group");
                outputTokensSlider.append("rect")
                    .attr("x", 10)
                    .attr("y", controlsY + controlsSpacing + 5)
                    .attr("width", controlsWidth)
                    .attr("height", sliderHeight)
                    .attr("fill", "rgba(27, 38, 59, 0.8)")
                    .attr("rx", sliderHeight / 2);
                
                const outputTokensHandle = outputTokensSlider.append("circle")
                    .attr("cx", 110)
                    .attr("cy", controlsY + controlsSpacing + 5 + sliderHeight / 2)
                    .attr("r", handleRadius)
                    .attr("fill", "var(--accent-green)")
                    .style("cursor", "pointer");
                
                const outputTokensValue = svg.append("text")
                    .attr("x", 220)
                    .attr("y", controlsY + controlsSpacing + 20)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "12px" : "11px")
                    .text("500 tokens");

                // Requests per second slider
                svg.append("text")
                    .attr("x", 10)
                    .attr("y", controlsY + controlsSpacing * 2)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "14px" : "12px")
                    .style("font-weight", "600")
                    .text("Requests/sec:");
                
                const rpsSlider = svg.append("g").attr("class", "slider-group");
                rpsSlider.append("rect")
                    .attr("x", 10)
                    .attr("y", controlsY + controlsSpacing * 2 + 5)
                    .attr("width", controlsWidth)
                    .attr("height", sliderHeight)
                    .attr("fill", "rgba(27, 38, 59, 0.8)")
                    .attr("rx", sliderHeight / 2);
                
                const rpsHandle = rpsSlider.append("circle")
                    .attr("cx", 110)
                    .attr("cy", controlsY + controlsSpacing * 2 + 5 + sliderHeight / 2)
                    .attr("r", handleRadius)
                    .attr("fill", "var(--accent-purple)")
                    .style("cursor", "pointer");
                
                const rpsValue = svg.append("text")
                    .attr("x", 220)
                    .attr("y", controlsY + controlsSpacing * 2 + 20)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isMobile ? "12px" : "11px")
                    .text("10 req/s");

                // Current values
                let currentInputTokens = 1000;
                let currentOutputTokens = 500;
                let currentRPS = 10;

                // Calculate costs and performance
                const calculateMetrics = () => {
                    return models.map(model => {
                        const inputCost = (currentInputTokens / 1000) * model.inputCost;
                        const outputCost = (currentOutputTokens / 1000) * model.outputCost;
                        const totalCostPerRequest = inputCost + outputCost;
                        const hourlyCost = totalCostPerRequest * currentRPS * 3600;
                        const dailyCost = hourlyCost * 24;
                        const monthlyCost = dailyCost * 30;

                        const throughput = Math.min(currentRPS, model.tokensPerSec / (currentInputTokens + currentOutputTokens));
                        const effectiveLatency = model.latency + ((currentInputTokens + currentOutputTokens) / model.tokensPerSec);

                        return {
                            ...model,
                            inputCost: inputCost,
                            outputCost: outputCost,
                            totalCostPerRequest: totalCostPerRequest,
                            hourlyCost: hourlyCost,
                            dailyCost: dailyCost,
                            monthlyCost: monthlyCost,
                            throughput: throughput,
                            effectiveLatency: effectiveLatency,
                            costEfficiency: throughput / totalCostPerRequest
                        };
                    });
                };

                // Update visualization with responsive design
                const updateVisualization = () => {
                    const metrics = calculateMetrics();

                    // Clear previous visualization
                    svg.selectAll(".model-bar, .cost-text, .performance-text").remove();

                    // Responsive bar chart calculations with improved alignment
                    const chartStartX = Math.max(300, width * 0.3);
                    const chartWidth = width - chartStartX - 20;
                    const totalBars = models.length;
                    const barSpacing = Math.max(8, chartWidth * 0.02); // Consistent spacing between bars
                    const availableWidth = chartWidth - (totalBars - 1) * barSpacing;
                    const barWidth = Math.max(25, availableWidth / totalBars); // Minimum bar width for readability
                    const maxCost = Math.max(...metrics.map(m => m.monthlyCost));
                    const costScale = d3.scaleLinear().domain([0, maxCost]).range([0, height - 150]);

                    metrics.forEach((model, i) => {
                        // Calculate precise bar positioning with consistent spacing
                        const x = chartStartX + i * (barWidth + barSpacing);
                        const barHeight = costScale(model.monthlyCost);
                        const y = height - 100 - barHeight;
                        
                        // Consistent bar width - no more dynamic sizing that causes misalignment
                        const actualBarWidth = barWidth;

                        // Cost bar with precise positioning
                        svg.append("rect")
                            .attr("class", "model-bar")
                            .attr("x", x)
                            .attr("y", y)
                            .attr("width", actualBarWidth)
                            .attr("height", barHeight)
                            .attr("fill", d3.interpolateBlues(model.costEfficiency / Math.max(...metrics.map(m => m.costEfficiency))))
                            .attr("rx", 3)
                            .style("cursor", "pointer")
                            .on("mouseover", (e) => showTooltip(e,
                                `<b>${model.name}</b><br>
                            <b>Monthly Cost:</b> $${model.monthlyCost.toFixed(2)}<br>
                            <b>Cost per Request:</b> $${model.totalCostPerRequest.toFixed(4)}<br>
                            <b>Throughput:</b> ${model.throughput.toFixed(1)} req/s<br>
                            <b>Latency:</b> ${model.effectiveLatency.toFixed(2)}s<br>
                            <b>Cost Efficiency:</b> ${model.costEfficiency.toFixed(1)} req/$`
                            ))
                            .on("mouseout", hideTooltip);

                        // Model name with consistent positioning
                        svg.append("text")
                            .attr("class", "cost-text")
                            .attr("x", x + actualBarWidth * 0.5)
                            .attr("y", height - 80)
                            .attr("text-anchor", "middle")
                            .attr("fill", "var(--text-primary)")
                            .style("font-size", Math.min(12, actualBarWidth / 4) + "px")
                            .style("font-weight", "600")
                            .text(model.name);

                        // Cost value with improved positioning and collision avoidance
                        const costTextY = Math.max(y - 8, y - 5);
                        svg.append("text")
                            .attr("class", "cost-text")
                            .attr("x", x + actualBarWidth * 0.5)
                            .attr("y", costTextY)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", Math.min(10, actualBarWidth / 5) + "px")
                            .style("font-weight", "600")
                            .text(`$${model.monthlyCost.toFixed(0)}`);

                        // Performance indicators with improved spacing and collision avoidance
                        const perfY = Math.max(y - 25, costTextY - 15);
                        const perfRadius = Math.min(6, actualBarWidth / 8);
                        svg.append("circle")
                            .attr("class", "performance-text")
                            .attr("cx", x + actualBarWidth * 0.5)
                            .attr("cy", perfY)
                            .attr("r", perfRadius)
                            .attr("fill", model.effectiveLatency < 1 ? "#2EC4B6" : model.effectiveLatency < 2 ? "#FFB700" : "#FF6B6B");

                        svg.append("text")
                            .attr("class", "performance-text")
                            .attr("x", x + actualBarWidth * 0.5)
                            .attr("y", perfY + 2)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", Math.min(7, actualBarWidth / 10) + "px")
                            .style("font-weight", "600")
                            .text(`${model.effectiveLatency.toFixed(1)}s`);
                    });

                    // Summary statistics
                    const totalMonthlyCost = metrics.reduce((sum, m) => sum + m.monthlyCost, 0);
                    const avgLatency = metrics.reduce((sum, m) => sum + m.effectiveLatency, 0) / metrics.length;
                    const bestCostEfficiency = Math.max(...metrics.map(m => m.costEfficiency));

                    svg.selectAll(".summary-text").remove();
                    svg.append("text").attr("class", "summary-text").attr("x", 10).attr("y", height - 20).attr("fill", "var(--text-secondary)").style("font-size", "11px").text(`Total Monthly Cost (All Models): $${totalMonthlyCost.toFixed(2)}`);
                    svg.append("text").attr("class", "summary-text").attr("x", 10).attr("y", height - 5).attr("fill", "var(--text-secondary)").style("font-size", "11px").text(`Average Latency: ${avgLatency.toFixed(2)}s | Best Cost Efficiency: ${bestCostEfficiency.toFixed(1)} req/$`);
                };

                // Performance optimization with debouncing
                let updateTimeout;
                const debouncedUpdate = () => {
                    clearTimeout(updateTimeout);
                    updateTimeout = setTimeout(() => {
                        updateVisualization();
                    }, 100); // 100ms debounce
                };

                // Optimize for mobile devices
                const isLowEndDevice = navigator.hardwareConcurrency <= 2 || 
                                       navigator.deviceMemory <= 4;

                // Slider interaction handlers with performance optimization
                const createSliderHandler = (handle, valueText, updateFn, formatFn) => {
                    const drag = d3.drag()
                        .on("drag", function (event) {
                            const x = Math.max(10, Math.min(210, event.x));
                            handle.attr("cx", x);
                            const normalized = (x - 10) / 200;
                            updateFn(normalized);
                            valueText.text(formatFn());
                            
                            // Use debounced update for better performance
                            if (isLowEndDevice) {
                                debouncedUpdate();
                            } else {
                                updateVisualization();
                            }
                        });
                    handle.call(drag);
                };

                createSliderHandler(
                    inputTokensHandle, inputTokensValue,
                    (val) => { currentInputTokens = Math.round(100 + val * 9900); },
                    () => `${currentInputTokens.toLocaleString()} tokens`
                );

                createSliderHandler(
                    outputTokensHandle, outputTokensValue,
                    (val) => { currentOutputTokens = Math.round(50 + val * 4950); },
                    () => `${currentOutputTokens.toLocaleString()} tokens`
                );

                createSliderHandler(
                    rpsHandle, rpsValue,
                    (val) => { currentRPS = Math.round(1 + val * 99); },
                    () => `${currentRPS} req/s`
                );

                // Initial visualization
                updateVisualization();
            }

            /** Renders the Advanced RAG Pipelines architecture visualization with hybrid retrieval patterns, responsive design, and Tableau Jedi Master techniques. */
            function renderAdvancedRAGPipelinesViz() {
                console.log('Starting renderAdvancedRAGPipelinesViz...');
                
                // Check if required dependencies are available
                if (typeof arrowMarker === 'undefined') {
                    console.error('arrowMarker function not available, delaying render...');
                    setTimeout(() => renderAdvancedRAGPipelinesViz(), 50);
                    return;
                }
                
                const container = d3.select("#advanced-rag-pipelines-viz"); 
                if (container.empty()) {
                    console.error('Container #advanced-rag-pipelines-viz not found');
                    return;
                }
                
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); 
                console.log('Container bounds:', bounds);
                
                if (bounds.width <= 0 || bounds.height <= 0) {
                    console.warn('Container has invalid dimensions, retrying...', bounds);
                    setTimeout(() => renderAdvancedRAGPipelinesViz(), 100);
                    return;
                }
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 40 : isTablet ? 45 : 50, 
                    right: isMobile ? 20 : isTablet ? 25 : 30, 
                    bottom: isMobile ? 50 : isTablet ? 55 : 60, 
                    left: isMobile ? 20 : isTablet ? 25 : 30 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers for different retrieval patterns with sophisticated styling
                arrowMarker(svg, "arrow-rag-adv", "var(--accent-blue)");
                arrowMarker(svg, "arrow-dense", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-sparse", "var(--accent-green)");
                arrowMarker(svg, "arrow-hybrid", "var(--accent-purple)");
                arrowMarker(svg, "arrow-multimodal", "var(--accent-blue)");
                arrowMarker(svg, "arrow-energy", "#FF6B6B");
                arrowMarker(svg, "arrow-hybrid-fusion", "#FF6B6B");
                arrowMarker(svg, "arrow-learned-retrieval", "#9C27B0");
                arrowMarker(svg, "arrow-graph-retrieval", "#4CAF50");
                arrowMarker(svg, "arrow-temporal-retrieval", "#FF9800");
                arrowMarker(svg, "arrow-rrf", "#FF6B6B");
                arrowMarker(svg, "arrow-weighted", "#3A86FF");
                arrowMarker(svg, "arrow-learned", "#9C27B0");
                arrowMarker(svg, "arrow-adaptive", "#4CAF50");

                // Advanced gradient definitions for hybrid retrieval patterns with competition-level styling
                const defs = svg.append("defs");

                // Sophisticated component gradients with depth, dimension, and visual hierarchy
                const componentGradients = [
                    { id: "query-analysis-grad", colors: ["#8338EC", "#A855F7", "#C084FC"], direction: "vertical", type: "linear" },
                    { id: "semantic-chunking-grad", colors: ["#2EC4B6", "#34D399", "#6EE7B7"], direction: "diagonal", type: "linear" },
                    { id: "hybrid-retrieval-grad", colors: ["#3A86FF", "#60A5FA", "#93C5FD"], direction: "radial", type: "radial" },
                    { id: "reranking-grad", colors: ["#FFB700", "#FCD34D", "#FDE68A"], direction: "horizontal", type: "linear" },
                    { id: "context-opt-grad", colors: ["#FF6B6B", "#F87171", "#FCA5A5"], direction: "vertical", type: "linear" }
                ];

                componentGradients.forEach(grad => {
                    if (grad.type === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", grad.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[2]).attr("stop-opacity", 0.5);
                    } else {
                        const gradient = defs.append("linearGradient").attr("id", grad.id);
                        if (grad.direction === "vertical") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                        } else if (grad.direction === "horizontal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                        } else if (grad.direction === "diagonal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                        }
                        gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        gradient.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.7);
                        gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[2]).attr("stop-opacity", 0.5);
                    }
                });

                // Add sophisticated filter effects for visual depth
                const filter = defs.append("filter").attr("id", "rag-glow-effect");
                filter.append("feGaussianBlur").attr("stdDeviation", "3").attr("result", "coloredBlur");
                const feMerge = filter.append("feMerge");
                feMerge.append("feMergeNode").attr("in", "coloredBlur");
                feMerge.append("feMergeNode").attr("in", "SourceGraphic");

                // Add drop shadow filter for professional depth
                const dropShadow = defs.append("filter").attr("id", "rag-drop-shadow").attr("x", "-50%").attr("y", "-50%").attr("width", "200%").attr("height", "200%");
                dropShadow.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", "4").attr("result", "blur");
                dropShadow.append("feOffset").attr("in", "blur").attr("dx", "2").attr("dy", "2").attr("result", "offsetBlur");
                const feFlood = dropShadow.append("feFlood").attr("flood-color", "rgba(0,0,0,0.3)").attr("flood-opacity", "0.5").attr("result", "offsetColor");
                dropShadow.append("feComposite").attr("in", "offsetColor").attr("in2", "offsetBlur").attr("operator", "in").attr("result", "offsetBlur");
                const feMerge2 = dropShadow.append("feMerge");
                feMerge2.append("feMergeNode").attr("in", "offsetBlur");
                feMerge2.append("feMergeNode").attr("in", "SourceGraphic");

                // Hybrid retrieval pattern gradients with advanced patterns
                const retrievalGradients = [
                    { id: "dense-retrieval-grad", colors: ["#2EC4B6", "#1DA9A0"] },
                    { id: "sparse-retrieval-grad", colors: ["#FFB700", "#E09800"] },
                    { id: "hybrid-fusion-grad", colors: ["#FF6B6B", "#E53E3E"] },
                    { id: "learned-retrieval-grad", colors: ["#9C27B0", "#7B1FA2"] },
                    { id: "multimodal-grad", colors: ["#8338EC", "#6D2BCA"] },
                    { id: "graph-retrieval-grad", colors: ["#4CAF50", "#388E3C"] },
                    { id: "temporal-retrieval-grad", colors: ["#FF9800", "#F57C00"] }
                ];

                // Ranking algorithm gradients with sophisticated styling
                const rankingGradients = [
                    { id: "rrf-grad", colors: ["#FF6B6B", "#E53E3E"] },
                    { id: "weighted-grad", colors: ["#3A86FF", "#2563EB"] },
                    { id: "learned-ranking-grad", colors: ["#9C27B0", "#7B1FA2"] },
                    { id: "adaptive-grad", colors: ["#4CAF50", "#388E3C"] }
                ];

                retrievalGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.8);
                    gradient.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 1.0);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.8);
                });

                rankingGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id).attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.8);
                    gradient.append("stop").attr("offset", "50%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 1.0);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.8);
                });

                // Calculate responsive component positioning based on screen size with enhanced spacing
                const calculateComponentPositions = (isMobile, isTablet, width, height) => {
                    if (isMobile) {
                        // Mobile: Stack components vertically with enhanced spacing
                        const verticalSpacing = Math.max(height * 0.18, 80); // Increased minimum spacing
                        const startY = height * 0.15; // Better top margin
                        return [
                            { x: width * 0.5, y: startY },                    // Query Analysis
                            { x: width * 0.5, y: startY + verticalSpacing },     // Semantic Chunking
                            { x: width * 0.5, y: startY + (verticalSpacing * 2) }, // Hybrid Retrieval
                            { x: width * 0.5, y: startY + (verticalSpacing * 3) }, // Reranking & Filtering
                            { x: width * 0.5, y: startY + (verticalSpacing * 4) }  // Context Optimization
                        ];
                    } else if (isTablet) {
                        // Tablet: 2x3 grid layout with enhanced spacing
                        const horizontalSpacing = Math.max(width * 0.4, 160); // Increased horizontal spacing
                        const verticalSpacing = Math.max(height * 0.25, 100); // Increased vertical spacing
                        return [
                            { x: width * 0.25, y: height * 0.2 },  // Query Analysis
                            { x: width * 0.75, y: height * 0.2 },  // Semantic Chunking
                            { x: width * 0.5, y: height * 0.5 },   // Hybrid Retrieval (center)
                            { x: width * 0.25, y: height * 0.8 },  // Reranking & Filtering
                            { x: width * 0.75, y: height * 0.8 }   // Context Optimization
                        ];
                    } else {
                        // Desktop: Enhanced flow layout with better spacing
                        const horizontalSpacing = Math.max(width * 0.18, 140); // Increased minimum spacing
                        const startX = width * 0.12; // Better left margin
                        const centerY = height * 0.25; // Better vertical centering
                        return [
                            { x: startX, y: centerY },                    // Query Analysis
                            { x: startX + horizontalSpacing, y: centerY - 30 },     // Semantic Chunking
                            { x: startX + (horizontalSpacing * 2), y: centerY }, // Hybrid Retrieval
                            { x: startX + (horizontalSpacing * 3), y: centerY - 30 }, // Reranking & Filtering
                            { x: startX + (horizontalSpacing * 4), y: centerY }  // Context Optimization
                        ];
                    }
                };

                const componentPositions = calculateComponentPositions(isMobile, isTablet, width, height);

                // Enhanced components with responsive positioning, hybrid retrieval patterns, performance metrics, and sophisticated visual storytelling
                const components = [
                    {
                        name: isMobile ? "Query" : "Query\nAnalysis",
                        x: componentPositions[0].x,
                        y: componentPositions[0].y,
                        gradient: "query-analysis-grad",
                        icon: "🔍",
                        complexity: "high",
                        priority: "Critical",
                        category: "Intelligence",
                        performance: { latency: "5ms", accuracy: "95%", cost: "$0.001" },
                        metrics: { throughput: "1000 queries/sec", efficiency: "98%", reliability: "99.9%" },
                        tooltip: "<b>Query Analysis</b><br>Intent detection, complexity assessment, and routing decisions. Determines optimal retrieval strategy based on query characteristics, user context, and performance requirements.<br><br><b>Performance:</b> 5ms latency, 95% accuracy, $0.001 cost<br><b>Priority:</b> Critical<br><b>Features:</b> Intent classification, complexity scoring, routing logic<br><b>Metrics:</b> 1000 queries/sec throughput, 98% efficiency, 99.9% reliability"
                    },
                    {
                        name: isMobile ? "Chunking" : "Semantic\nChunking",
                        x: componentPositions[1].x,
                        y: componentPositions[1].y,
                        gradient: "semantic-chunking-grad",
                        icon: "📄",
                        complexity: "medium",
                        priority: "High",
                        category: "Processing",
                        performance: { latency: "50ms", accuracy: "92%", cost: "$0.005" },
                        metrics: { throughput: "500 chunks/sec", efficiency: "94%", reliability: "99.5%" },
                        tooltip: "<b>Semantic Chunking</b><br>Context-aware document segmentation that preserves semantic coherence. Uses sentence transformers and topic modeling to create meaningful chunks that maintain conceptual integrity.<br><br><b>Performance:</b> 50ms latency, 92% accuracy, $0.005 cost<br><b>Priority:</b> High<br><b>Features:</b> Sentence transformers, topic modeling, coherence preservation<br><b>Metrics:</b> 500 chunks/sec throughput, 94% efficiency, 99.5% reliability"
                    },
                    {
                        name: isMobile ? "Retrieval" : "Hybrid\nRetrieval",
                        x: componentPositions[2].x,
                        y: componentPositions[2].y,
                        gradient: "hybrid-retrieval-grad",
                        icon: "🔗",
                        complexity: "critical",
                        priority: "Critical",
                        category: "Core Engine",
                        performance: { latency: "100ms", accuracy: "98%", cost: "$0.015" },
                        metrics: { throughput: "200 retrievals/sec", efficiency: "96%", reliability: "99.8%" },
                        tooltip: "<b>Hybrid Retrieval</b><br>Combines dense (semantic) and sparse (keyword) search for comprehensive coverage. Implements reciprocal rank fusion and adaptive weighting based on query characteristics.<br><br><b>Performance:</b> 100ms latency, 98% accuracy, $0.015 cost<br><b>Priority:</b> Critical<br><b>Features:</b> Dense + sparse search, rank fusion, adaptive weighting<br><b>Metrics:</b> 200 retrievals/sec throughput, 96% efficiency, 99.8% reliability"
                    },
                    {
                        name: isMobile ? "Reranking" : "Reranking\n& Filtering",
                        x: componentPositions[3].x,
                        y: componentPositions[3].y,
                        gradient: "reranking-grad",
                        icon: "⚖️",
                        complexity: "high",
                        priority: "High",
                        category: "Optimization",
                        performance: { latency: "75ms", accuracy: "96%", cost: "$0.010" },
                        metrics: { throughput: "300 reranks/sec", efficiency: "95%", reliability: "99.7%" },
                        tooltip: "<b>Reranking & Filtering</b><br>Cross-encoder models and relevance filtering to optimize retrieved context quality. Includes diversity injection and redundancy removal for optimal LLM input preparation.<br><br><b>Performance:</b> 75ms latency, 96% accuracy, $0.010 cost<br><b>Priority:</b> High<br><b>Features:</b> Cross-encoder models, relevance filtering, diversity injection<br><b>Metrics:</b> 300 reranks/sec throughput, 95% efficiency, 99.7% reliability"
                    },
                    {
                        name: isMobile ? "Context" : "Context\nOptimization",
                        x: componentPositions[4].x,
                        y: componentPositions[4].y,
                        gradient: "context-opt-grad",
                        icon: "🎯",
                        complexity: "medium",
                        priority: "High",
                        category: "Finalization",
                        performance: { latency: "25ms", accuracy: "94%", cost: "$0.003" },
                        metrics: { throughput: "800 optimizations/sec", efficiency: "97%", reliability: "99.6%" },
                        tooltip: "<b>Context Optimization</b><br>Dynamic context window management, token budgeting, and attention optimization. Ensures relevant information fits within model constraints while maximizing utility.<br><br><b>Performance:</b> 25ms latency, 94% accuracy, $0.003 cost<br><b>Priority:</b> High<br><b>Features:</b> Token budgeting, attention optimization, context window management<br><b>Metrics:</b> 800 optimizations/sec throughput, 97% efficiency, 99.6% reliability"
                    }
                ];

                // Enhanced hybrid retrieval pattern visualization with sophisticated metrics and advanced patterns
                const calculateHybridPatternPositions = (isMobile, isTablet, width, height) => {
                    if (isMobile) {
                        // Mobile: Stack patterns vertically with enhanced spacing
                        const verticalSpacing = Math.max(height * 0.12, 60);
                        const startY = height * 0.6;
                        return [
                            { x: width * 0.5, y: startY },
                            { x: width * 0.5, y: startY + verticalSpacing },
                            { x: width * 0.5, y: startY + (verticalSpacing * 2) },
                            { x: width * 0.5, y: startY + (verticalSpacing * 3) },
                            { x: width * 0.5, y: startY + (verticalSpacing * 4) },
                            { x: width * 0.5, y: startY + (verticalSpacing * 5) },
                            { x: width * 0.5, y: startY + (verticalSpacing * 6) }
                        ];
                    } else if (isTablet) {
                        // Tablet: 2x4 grid layout with enhanced spacing
                        const horizontalSpacing = Math.max(width * 0.3, 120);
                        const verticalSpacing = Math.max(height * 0.15, 70);
                        const startX = width * 0.2;
                        const startY = height * 0.6;
                        return [
                            { x: startX, y: startY },
                            { x: startX + horizontalSpacing, y: startY },
                            { x: startX + (horizontalSpacing * 2), y: startY },
                            { x: startX, y: startY + verticalSpacing },
                            { x: startX + horizontalSpacing, y: startY + verticalSpacing },
                            { x: startX + (horizontalSpacing * 2), y: startY + verticalSpacing },
                            { x: startX + (horizontalSpacing * 0.5), y: startY + (verticalSpacing * 2) }
                        ];
                    } else {
                        // Desktop: Enhanced horizontal layout with better spacing
                        const horizontalSpacing = Math.max(width * 0.12, 100);
                        const startX = width * 0.1;
                        const patternY = height * 0.6;
                        return [
                            { x: startX, y: patternY },
                            { x: startX + horizontalSpacing, y: patternY },
                            { x: startX + (horizontalSpacing * 2), y: patternY },
                            { x: startX + (horizontalSpacing * 3), y: patternY },
                            { x: startX + (horizontalSpacing * 4), y: patternY },
                            { x: startX + (horizontalSpacing * 5), y: patternY },
                            { x: startX + (horizontalSpacing * 6), y: patternY }
                        ];
                    }
                };

                const hybridPatternPositions = calculateHybridPatternPositions(isMobile, isTablet, width, height);

                const hybridPatterns = [
                    {
                        name: "Dense Retrieval",
                        x: hybridPatternPositions[0].x,
                        y: hybridPatternPositions[0].y,
                        color: "#2EC4B6",
                        gradient: "dense-retrieval-grad",
                        icon: "🧠",
                        category: "Semantic",
                        priority: "High",
                        description: "Semantic similarity search using dense vector embeddings",
                        performance: { recall: "85%", precision: "78%", latency: "30ms" },
                        metrics: { throughput: "500 searches/sec", efficiency: "92%", reliability: "99.5%" },
                        tooltip: "<b>Dense Retrieval</b><br>Semantic similarity search using dense vector embeddings for context-aware matching.<br><br><b>Performance:</b> 85% recall, 78% precision, 30ms latency<br><b>Category:</b> Semantic<br><b>Priority:</b> High<br><b>Metrics:</b> 500 searches/sec throughput, 92% efficiency, 99.5% reliability"
                    },
                    {
                        name: "Sparse Retrieval",
                        x: hybridPatternPositions[1].x,
                        y: hybridPatternPositions[1].y,
                        color: "#FFB700",
                        gradient: "sparse-retrieval-grad",
                        icon: "🔤",
                        category: "Keyword",
                        priority: "Medium",
                        description: "Keyword-based search using BM25 and TF-IDF",
                        performance: { recall: "72%", precision: "85%", latency: "15ms" },
                        metrics: { throughput: "800 searches/sec", efficiency: "88%", reliability: "99.2%" },
                        tooltip: "<b>Sparse Retrieval</b><br>Keyword-based search using BM25 and TF-IDF for exact term matching.<br><br><b>Performance:</b> 72% recall, 85% precision, 15ms latency<br><b>Category:</b> Keyword<br><b>Priority:</b> Medium<br><b>Metrics:</b> 800 searches/sec throughput, 88% efficiency, 99.2% reliability"
                    },
                    {
                        name: "Hybrid Fusion",
                        x: hybridPatternPositions[2].x,
                        y: hybridPatternPositions[2].y,
                        color: "#FF6B6B",
                        gradient: "hybrid-fusion-grad",
                        icon: "⚡",
                        category: "Fusion",
                        priority: "Critical",
                        description: "Reciprocal Rank Fusion combining dense and sparse results",
                        performance: { recall: "92%", precision: "88%", latency: "45ms" },
                        metrics: { throughput: "350 searches/sec", efficiency: "95%", reliability: "99.7%" },
                        tooltip: "<b>Hybrid Fusion</b><br>Reciprocal Rank Fusion (RRF) combining dense and sparse retrieval results for optimal coverage and precision.<br><br><b>Performance:</b> 92% recall, 88% precision, 45ms latency<br><b>Category:</b> Fusion<br><b>Priority:</b> Critical<br><b>Metrics:</b> 350 searches/sec throughput, 95% efficiency, 99.7% reliability"
                    },
                    {
                        name: "Learned Retrieval",
                        x: hybridPatternPositions[3].x,
                        y: hybridPatternPositions[3].y,
                        color: "#9C27B0",
                        gradient: "learned-retrieval-grad",
                        icon: "🎓",
                        category: "Adaptive",
                        priority: "High",
                        description: "Neural ranking models with query-document interaction",
                        performance: { recall: "88%", precision: "91%", latency: "80ms" },
                        metrics: { throughput: "250 searches/sec", efficiency: "93%", reliability: "99.6%" },
                        tooltip: "<b>Learned Retrieval</b><br>Neural ranking models with query-document interaction learning for personalized and context-aware retrieval.<br><br><b>Performance:</b> 88% recall, 91% precision, 80ms latency<br><b>Category:</b> Adaptive<br><b>Priority:</b> High<br><b>Metrics:</b> 250 searches/sec throughput, 93% efficiency, 99.6% reliability"
                    },
                    {
                        name: "Multimodal Retrieval",
                        x: hybridPatternPositions[4].x,
                        y: hybridPatternPositions[4].y,
                        color: "#8338EC",
                        gradient: "multimodal-grad",
                        icon: "🎨",
                        category: "Cross-Modal",
                        priority: "High",
                        description: "Cross-modal search across text, images, and audio",
                        performance: { recall: "90%", precision: "82%", latency: "120ms" },
                        metrics: { throughput: "200 searches/sec", efficiency: "95%", reliability: "99.8%" },
                        tooltip: "<b>Multimodal Retrieval</b><br>Cross-modal search across text, images, and audio for comprehensive content understanding.<br><br><b>Performance:</b> 90% recall, 82% precision, 120ms latency<br><b>Category:</b> Cross-Modal<br><b>Priority:</b> High<br><b>Metrics:</b> 200 searches/sec throughput, 95% efficiency, 99.8% reliability"
                    },
                    {
                        name: "Graph Retrieval",
                        x: hybridPatternPositions[5].x,
                        y: hybridPatternPositions[5].y,
                        color: "#4CAF50",
                        gradient: "graph-retrieval-grad",
                        icon: "🕸️",
                        category: "Relational",
                        priority: "Medium",
                        description: "Knowledge graph traversal and entity relationship search",
                        performance: { recall: "86%", precision: "89%", latency: "60ms" },
                        metrics: { throughput: "300 searches/sec", efficiency: "90%", reliability: "99.4%" },
                        tooltip: "<b>Graph Retrieval</b><br>Knowledge graph traversal and entity relationship search for structured information retrieval.<br><br><b>Performance:</b> 86% recall, 89% precision, 60ms latency<br><b>Category:</b> Relational<br><b>Priority:</b> Medium<br><b>Metrics:</b> 300 searches/sec throughput, 90% efficiency, 99.4% reliability"
                    },
                    {
                        name: "Temporal Retrieval",
                        x: hybridPatternPositions[6].x,
                        y: hybridPatternPositions[6].y,
                        color: "#FF9800",
                        gradient: "temporal-retrieval-grad",
                        icon: "⏰",
                        category: "Temporal",
                        priority: "Medium",
                        description: "Time-aware retrieval with recency and relevance weighting",
                        performance: { recall: "84%", precision: "87%", latency: "35ms" },
                        metrics: { throughput: "400 searches/sec", efficiency: "91%", reliability: "99.3%" },
                        tooltip: "<b>Temporal Retrieval</b><br>Time-aware retrieval with recency and relevance weighting for dynamic content discovery.<br><br><b>Performance:</b> 84% recall, 87% precision, 35ms latency<br><b>Category:</b> Temporal<br><b>Priority:</b> Medium<br><b>Metrics:</b> 400 searches/sec throughput, 91% efficiency, 99.3% reliability"
                    }
                ];

                // Add energy flow visualization for RAG pipeline dynamics
                const energyFlows = [
                    { from: components[0], to: components[1], intensity: 0.9, type: "query-flow" },
                    { from: components[1], to: components[2], intensity: 0.8, type: "chunk-flow" },
                    { from: components[2], to: components[3], intensity: 0.85, type: "retrieval-flow" },
                    { from: components[3], to: components[4], intensity: 0.95, type: "optimization-flow" }
                ];

                // Advanced ranking algorithms with sophisticated performance comparison
                const rankingAlgorithms = [
                    {
                        name: "RRF",
                        fullName: "Reciprocal Rank Fusion",
                        x: width * 0.15,
                        y: height * 0.75,
                        color: "#FF6B6B",
                        gradient: "rrf-grad",
                        icon: "⚡",
                        category: "Fusion",
                        priority: "Critical",
                        description: "Combines multiple ranking lists using reciprocal rank weighting",
                        performance: {
                            effectiveness: "92%",
                            stability: "95%",
                            latency: "5ms",
                            diversity: "88%"
                        },
                        metrics: {
                            throughput: "1000 fusions/sec",
                            efficiency: "98%",
                            reliability: "99.9%",
                            adaptability: "High"
                        },
                        tooltip: "<b>Reciprocal Rank Fusion (RRF)</b><br>Combines multiple ranking lists using reciprocal rank weighting for optimal result diversity and relevance.<br><br><b>Performance:</b> 92% effectiveness, 95% stability, 5ms latency, 88% diversity<br><b>Category:</b> Fusion<br><b>Priority:</b> Critical<br><b>Metrics:</b> 1000 fusions/sec throughput, 98% efficiency, 99.9% reliability, High adaptability"
                    },
                    {
                        name: "Weighted",
                        fullName: "Weighted Combination",
                        x: width * 0.35,
                        y: height * 0.75,
                        color: "#3A86FF",
                        gradient: "weighted-grad",
                        icon: "⚖️",
                        category: "Linear",
                        priority: "High",
                        description: "Linear combination with learned or fixed weights",
                        performance: {
                            effectiveness: "89%",
                            stability: "92%",
                            latency: "3ms",
                            diversity: "82%"
                        },
                        metrics: {
                            throughput: "1500 combinations/sec",
                            efficiency: "96%",
                            reliability: "99.7%",
                            adaptability: "Medium"
                        },
                        tooltip: "<b>Weighted Combination</b><br>Linear combination with learned or fixed weights for balanced retrieval performance.<br><br><b>Performance:</b> 89% effectiveness, 92% stability, 3ms latency, 82% diversity<br><b>Category:</b> Linear<br><b>Priority:</b> High<br><b>Metrics:</b> 1500 combinations/sec throughput, 96% efficiency, 99.7% reliability, Medium adaptability"
                    },
                    {
                        name: "Learned",
                        fullName: "Learned Ranking",
                        x: width * 0.55,
                        y: height * 0.75,
                        color: "#9C27B0",
                        gradient: "learned-ranking-grad",
                        icon: "🧠",
                        category: "Neural",
                        priority: "High",
                        description: "Neural network-based ranking with query-document interaction",
                        performance: {
                            effectiveness: "94%",
                            stability: "88%",
                            latency: "25ms",
                            diversity: "85%"
                        },
                        metrics: {
                            throughput: "400 rankings/sec",
                            efficiency: "93%",
                            reliability: "99.5%",
                            adaptability: "Very High"
                        },
                        tooltip: "<b>Learned Ranking</b><br>Neural network-based ranking with query-document interaction for personalized and context-aware results.<br><br><b>Performance:</b> 94% effectiveness, 88% stability, 25ms latency, 85% diversity<br><b>Category:</b> Neural<br><b>Priority:</b> High<br><b>Metrics:</b> 400 rankings/sec throughput, 93% efficiency, 99.5% reliability, Very High adaptability"
                    },
                    {
                        name: "Adaptive",
                        fullName: "Adaptive Fusion",
                        x: width * 0.75,
                        y: height * 0.75,
                        color: "#4CAF50",
                        gradient: "adaptive-grad",
                        icon: "🔄",
                        category: "Dynamic",
                        priority: "Critical",
                        description: "Dynamic weight adjustment based on query characteristics",
                        performance: {
                            effectiveness: "96%",
                            stability: "90%",
                            latency: "15ms",
                            diversity: "91%"
                        },
                        metrics: {
                            throughput: "600 adaptations/sec",
                            efficiency: "95%",
                            reliability: "99.8%",
                            adaptability: "Maximum"
                        },
                        tooltip: "<b>Adaptive Fusion</b><br>Dynamic weight adjustment based on query characteristics for optimal performance across diverse scenarios.<br><br><b>Performance:</b> 96% effectiveness, 90% stability, 15ms latency, 91% diversity<br><b>Category:</b> Dynamic<br><b>Priority:</b> Critical<br><b>Metrics:</b> 600 adaptations/sec throughput, 95% efficiency, 99.8% reliability, Maximum adaptability"
                    }
                ];

                // Render main pipeline components with sophisticated visual storytelling
                components.forEach((c, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node rag-component")
                        .attr("data-complexity", c.complexity)
                        .attr("data-priority", c.priority)
                        .attr("data-category", c.category)
                        .style("opacity", 0)
                        .on("mouseover", (e) => {
                            showTooltip(e, c.tooltip);
                            // Highlight connected components with sophisticated effects
                            svg.selectAll(".rag-component").style("opacity", 0.3);
                            g.style("opacity", 1.0).style("filter", "url(#rag-glow-effect)");
                            // Highlight hybrid patterns
                            svg.selectAll(".hybrid-pattern").style("opacity", 0.2);
                            // Show energy flows
                            svg.selectAll(".energy-flow").style("opacity", 0.3);
                            svg.selectAll(`.energy-${i}`).style("opacity", 1.0);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".rag-component").style("opacity", 1.0).style("filter", "none");
                            svg.selectAll(".hybrid-pattern").style("opacity", 0.8);
                            svg.selectAll(".energy-flow").style("opacity", 0.5);
                        });

                    // Component background with sophisticated gradient and depth
                    const componentRect = g.append("rect")
                        .attr("x", c.x - 65)
                        .attr("y", c.y - 35)
                        .attr("width", 130)
                        .attr("height", 70)
                        .attr("fill", `url(#${c.gradient})`)
                        .attr("rx", 15)
                        .style("filter", "url(#rag-drop-shadow)")
                        .style("opacity", 0);

                    // Priority indicator with shape encoding
                    const priorityShapes = {
                        "Critical": "diamond",
                        "High": "circle",
                        "Medium": "square",
                        "Low": "triangle"
                    };

                    const priorityColor = {
                        "Critical": "#FF6B6B",
                        "High": "#FFB700",
                        "Medium": "#3A86FF",
                        "Low": "#2EC4B6"
                    };

                    // Add priority indicator
                    const priorityIndicator = g.append("g").attr("class", "priority-indicator");
                    if (c.priority === "Critical") {
                        priorityIndicator.append("polygon")
                            .attr("points", `${c.x - 55},${c.y - 25} ${c.x - 45},${c.y - 15} ${c.x - 55},${c.y - 5} ${c.x - 65},${c.y - 15}`)
                            .attr("fill", priorityColor[c.priority])
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (c.priority === "High") {
                        priorityIndicator.append("circle")
                            .attr("cx", c.x - 50)
                            .attr("cy", c.y - 15)
                            .attr("r", 6)
                            .attr("fill", priorityColor[c.priority])
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    }

                    // Complexity indicator with visual encoding
                    const complexityBars = g.append("g").attr("class", "complexity-indicator");
                    const complexityLevels = { "Low": 1, "Medium": 2, "High": 3, "Critical": 4 };
                    for (let j = 0; j < complexityLevels[c.complexity]; j++) {
                        complexityBars.append("rect")
                            .attr("x", c.x + 45 + (j * 4))
                            .attr("y", c.y - 25 - (j * 2))
                            .attr("width", 3)
                            .attr("height", 8 - (j * 1.5))
                            .attr("fill", c.complexity === "Critical" ? "#FF6B6B" : c.complexity === "High" ? "#FFB700" : c.complexity === "Medium" ? "#3A86FF" : "#2EC4B6")
                            .attr("rx", 1);
                    }

                    // Component icon with entrance animation
                    g.append("text")
                        .attr("x", c.x)
                        .attr("y", c.y - 5)
                        .attr("text-anchor", "middle")
                        .style("font-size", "24px")
                        .style("opacity", 0)
                        .text(c.icon)
                        .transition()
                        .delay(i * 300 + 500)
                        .duration(800)
                        .style("opacity", 1);

                    // Component name with sophisticated typography
                    c.name.split('\n').forEach((line, j) => {
                        g.append("text")
                            .attr("x", c.x)
                            .attr("y", c.y + (j * 14) + 10)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", "12px")
                            .style("font-weight", "bold")
                            .style("opacity", 0)
                            .text(line)
                            .transition()
                            .delay(i * 300 + 700)
                            .duration(600)
                            .style("opacity", 1);
                    });

                    // Enhanced performance indicators with visual storytelling
                    const perfIndicators = g.append("g").attr("class", "performance-indicators");
                    const indicatorY = c.y + 30;

                    // Performance bars with animation
                    const perfMetrics = [
                        { label: "Latency", value: parseInt(c.performance.latency), color: "#2EC4B6", x: c.x - 50 },
                        { label: "Accuracy", value: parseInt(c.performance.accuracy), color: "#FFB700", x: c.x - 15 },
                        { label: "Cost", value: parseFloat(c.performance.cost.replace('$', '')) * 1000, color: "#FF6B6B", x: c.x + 20 }
                    ];

                    perfMetrics.forEach((metric, j) => {
                        const barGroup = perfIndicators.append("g").attr("class", `perf-bar-${j}`);

                        // Background bar
                        barGroup.append("rect")
                            .attr("x", metric.x - 10)
                            .attr("y", indicatorY - 8)
                            .attr("width", 20)
                            .attr("height", 4)
                            .attr("fill", "rgba(255,255,255,0.2)")
                            .attr("rx", 2);

                        // Performance bar with animation
                        barGroup.append("rect")
                            .attr("x", metric.x - 10)
                            .attr("y", indicatorY - 8)
                            .attr("width", 0)
                            .attr("height", 4)
                            .attr("fill", metric.color)
                            .attr("rx", 2)
                            .transition()
                            .delay(i * 300 + 1000)
                            .duration(1200)
                            .attr("width", (metric.value / 100) * 20);

                        // Performance indicator dot
                        barGroup.append("circle")
                            .attr("cx", metric.x)
                            .attr("cy", indicatorY - 6)
                            .attr("r", 2)
                            .attr("fill", metric.color)
                            .attr("opacity", 0)
                            .transition()
                            .delay(i * 300 + 1200)
                            .duration(600)
                            .attr("opacity", 1);
                    });

                    // Animate component entrance
                    componentRect.transition()
                        .delay(i * 300)
                        .duration(800)
                        .style("opacity", 1);

                    // Connect to next component with sophisticated energy flow and improved path calculation
                    if (i < components.length - 1) {
                        const nextC = components[i + 1];
                        
                        // Calculate optimal connection path based on layout
                        let pathData;
                        if (isMobile) {
                            // Vertical layout: straight vertical connections with slight curve
                            const midY = (c.y + nextC.y) / 2;
                            pathData = `M ${c.x} ${c.y + 35} 
                                      Q ${c.x + 20} ${midY} ${nextC.x} ${nextC.y - 35}`;
                        } else if (isTablet) {
                            // Grid layout: diagonal connections with smooth curves
                            const midX = (c.x + nextC.x) / 2;
                            const midY = (c.y + nextC.y) / 2;
                            pathData = `M ${c.x + 65} ${c.y} 
                                      Q ${midX} ${midY - 30} ${nextC.x - 65} ${nextC.y}`;
                        } else {
                            // Horizontal layout: smooth horizontal connections with better curve calculation
                            const midX = (c.x + nextC.x) / 2;
                            const curveOffset = Math.abs(c.y - nextC.y) > 20 ? 40 : 20; // Dynamic curve based on vertical difference
                            pathData = `M ${c.x + 65} ${c.y} 
                                      Q ${midX} ${Math.min(c.y, nextC.y) - curveOffset} ${nextC.x - 65} ${nextC.y}`;
                        }
                        
                        const path = svg.append("path")
                            .attr("class", `rag-connection connection-${i}`)
                            .attr("d", pathData)
                            .attr("stroke", "var(--accent-blue)")
                            .attr("fill", "none")
                            .attr("stroke-width", isMobile ? 2.5 : isTablet ? 3 : 3.5)
                            .attr("opacity", 0)
                            .attr("marker-end", "url(#arrow-rag-adv)")
                            .style("stroke-linecap", "round")
                            .style("filter", "drop-shadow(0 2px 4px rgba(58, 134, 255, 0.3))");

                        // Animate the pipeline flow with sophisticated timing
                        const pathLength = path.node().getTotalLength();
                        path.attr("stroke-dasharray", `${pathLength} ${pathLength}`)
                            .attr("stroke-dashoffset", pathLength)
                            .transition()
                            .delay(i * 300 + 1500)
                            .duration(2000)
                            .attr("stroke-dashoffset", 0)
                            .attr("opacity", 0.7);

                        // Add energy flow particles with improved positioning
                        const energyFlow = svg.append("g").attr("class", `energy-flow energy-${i}`);
                        for (let p = 0; p < 3; p++) {
                            energyFlow.append("circle")
                                .attr("r", 3)
                                .attr("fill", "#FF6B6B")
                                .attr("opacity", 0.8)
                                .attr("cx", c.x + 65)
                                .attr("cy", c.y)
                                .transition()
                                .delay(i * 300 + 2000 + (p * 200))
                                .duration(1500)
                                .attr("cx", nextC.x - 65)
                                .attr("cy", nextC.y)
                                .transition()
                                .duration(0)
                                .attr("cx", c.x + 65)
                                .attr("cy", c.y);
                        }
                    }
                });

                // Render hybrid retrieval patterns with sophisticated visual storytelling
                hybridPatterns.forEach((pattern, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node hybrid-pattern")
                        .attr("data-category", pattern.category)
                        .attr("data-priority", pattern.priority)
                        .style("opacity", 0)
                        .on("mouseover", (e) => {
                            showTooltip(e, pattern.tooltip);
                            svg.selectAll(".hybrid-pattern").style("opacity", 0.3);
                            g.style("opacity", 1.0).style("filter", "url(#rag-glow-effect)");
                            // Highlight connections to hybrid retrieval component
                            svg.selectAll(".pattern-connection").style("opacity", 0.2);
                            svg.selectAll(`.pattern-connection-${i}`).style("opacity", 1.0).style("stroke-width", 3);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".hybrid-pattern").style("opacity", 0.8).style("filter", "none");
                            svg.selectAll(".pattern-connection").style("opacity", 0.4).style("stroke-width", 2);
                        });

                    // Pattern background with sophisticated styling
                    const patternRect = g.append("rect")
                        .attr("x", pattern.x - 55)
                        .attr("y", pattern.y - 30)
                        .attr("width", 110)
                        .attr("height", 60)
                        .attr("fill", `url(#${pattern.gradient})`)
                        .attr("rx", 12)
                        .style("filter", "url(#rag-drop-shadow)")
                        .style("opacity", 0);

                    // Priority indicator for patterns
                    const priorityIndicator = g.append("g").attr("class", "priority-indicator");
                    if (pattern.priority === "High") {
                        priorityIndicator.append("circle")
                            .attr("cx", pattern.x - 40)
                            .attr("cy", pattern.y - 20)
                            .attr("r", 5)
                            .attr("fill", "#FFB700")
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (pattern.priority === "Medium") {
                        priorityIndicator.append("rect")
                            .attr("x", pattern.x - 45)
                            .attr("y", pattern.y - 25)
                            .attr("width", 10)
                            .attr("height", 10)
                            .attr("fill", "#3A86FF")
                            .attr("stroke", "white")
                            .attr("stroke-width", 1)
                            .attr("rx", 2);
                    }

                    // Pattern icon with entrance animation
                    g.append("text")
                        .attr("x", pattern.x)
                        .attr("y", pattern.y - 5)
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("opacity", 0)
                        .text(pattern.icon)
                        .transition()
                        .delay(2000 + (i * 200))
                        .duration(800)
                        .style("opacity", 1);

                    // Pattern name with sophisticated typography
                    g.append("text")
                        .attr("x", pattern.x)
                        .attr("y", pattern.y + 12)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "11px")
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(pattern.name)
                        .transition()
                        .delay(2200 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Performance indicators for patterns
                    const perfIndicators = g.append("g").attr("class", "pattern-performance");
                    const perfY = pattern.y + 25;

                    // Recall indicator
                    perfIndicators.append("circle")
                        .attr("cx", pattern.x - 20)
                        .attr("cy", perfY)
                        .attr("r", 3)
                        .attr("fill", "#2EC4B6")
                        .attr("opacity", 0)
                        .transition()
                        .delay(2400 + (i * 200))
                        .duration(600)
                        .attr("opacity", 0.8);

                    // Precision indicator
                    perfIndicators.append("circle")
                        .attr("cx", pattern.x)
                        .attr("cy", perfY)
                        .attr("r", 3)
                        .attr("fill", "#FFB700")
                        .attr("opacity", 0)
                        .transition()
                        .delay(2400 + (i * 200))
                        .duration(600)
                        .attr("opacity", 0.8);

                    // Latency indicator
                    perfIndicators.append("circle")
                        .attr("cx", pattern.x + 20)
                        .attr("cy", perfY)
                        .attr("r", 3)
                        .attr("fill", "#FF6B6B")
                        .attr("opacity", 0)
                        .transition()
                        .delay(2400 + (i * 200))
                        .duration(600)
                        .attr("opacity", 0.8);

                    // Animate pattern entrance
                    patternRect.transition()
                        .delay(1800 + (i * 200))
                        .duration(800)
                        .style("opacity", 1);

                    // Connect to hybrid retrieval component with sophisticated visual effects
                    const hybridComponent = components[2]; // Hybrid Retrieval component
                    const connection = svg.append("line")
                        .attr("class", `pattern-connection pattern-connection-${i}`)
                        .attr("x1", pattern.x)
                        .attr("y1", pattern.y - 30)
                        .attr("x2", hybridComponent.x)
                        .attr("y2", hybridComponent.y + 35)
                        .attr("stroke", pattern.color)
                        .attr("stroke-width", 2)
                        .attr("opacity", 0)
                        .attr("stroke-dasharray", "6,6")
                        .attr("marker-end", `url(#arrow-${pattern.name.toLowerCase().replace(' ', '-')})`);

                    // Animate pattern connections
                    connection.transition()
                        .delay(3000 + (i * 300))
                        .duration(1500)
                        .attr("opacity", 0.4);
                });

                // Render ranking algorithms with sophisticated visual storytelling and performance comparison
                rankingAlgorithms.forEach((algorithm, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node ranking-algorithm")
                        .attr("data-category", algorithm.category)
                        .attr("data-priority", algorithm.priority)
                        .style("opacity", 0)
                        .on("mouseover", (e) => {
                            showTooltip(e, algorithm.tooltip);
                            svg.selectAll(".ranking-algorithm").style("opacity", 0.3);
                            g.style("opacity", 1.0).style("filter", "url(#rag-glow-effect)");
                            // Highlight connections to reranking component
                            svg.selectAll(".ranking-connection").style("opacity", 0.2);
                            svg.selectAll(`.ranking-connection-${i}`).style("opacity", 1.0).style("stroke-width", 3);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".ranking-algorithm").style("opacity", 0.8).style("filter", "none");
                            svg.selectAll(".ranking-connection").style("opacity", 0.4).style("stroke-width", 2);
                        });

                    // Algorithm background with sophisticated styling
                    const algorithmRect = g.append("rect")
                        .attr("x", algorithm.x - 50)
                        .attr("y", algorithm.y - 25)
                        .attr("width", 100)
                        .attr("height", 50)
                        .attr("fill", `url(#${algorithm.gradient})`)
                        .attr("rx", 10)
                        .style("filter", "url(#rag-drop-shadow)")
                        .style("opacity", 0);

                    // Priority indicator for algorithms
                    const priorityIndicator = g.append("g").attr("class", "priority-indicator");
                    if (algorithm.priority === "Critical") {
                        priorityIndicator.append("polygon")
                            .attr("points", `${algorithm.x - 40},${algorithm.y - 20} ${algorithm.x - 30},${algorithm.y - 10} ${algorithm.x - 40},${algorithm.y} ${algorithm.x - 50},${algorithm.y - 10}`)
                            .attr("fill", "#FF6B6B")
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    } else if (algorithm.priority === "High") {
                        priorityIndicator.append("circle")
                            .attr("cx", algorithm.x - 35)
                            .attr("cy", algorithm.y - 10)
                            .attr("r", 4)
                            .attr("fill", "#FFB700")
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);
                    }

                    // Algorithm icon with entrance animation
                    g.append("text")
                        .attr("x", algorithm.x)
                        .attr("y", algorithm.y - 5)
                        .attr("text-anchor", "middle")
                        .style("font-size", "16px")
                        .style("opacity", 0)
                        .text(algorithm.icon)
                        .transition()
                        .delay(3500 + (i * 200))
                        .duration(800)
                        .style("opacity", 1);

                    // Algorithm name with sophisticated typography
                    g.append("text")
                        .attr("x", algorithm.x)
                        .attr("y", algorithm.y + 8)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(algorithm.name)
                        .transition()
                        .delay(3700 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Performance indicators for algorithms
                    const perfIndicators = g.append("g").attr("class", "algorithm-performance");
                    const perfY = algorithm.y + 18;

                    // Effectiveness indicator
                    perfIndicators.append("circle")
                        .attr("cx", algorithm.x - 15)
                        .attr("cy", perfY)
                        .attr("r", 2)
                        .attr("fill", "#2EC4B6")
                        .attr("opacity", 0)
                        .transition()
                        .delay(3900 + (i * 200))
                        .duration(600)
                        .attr("opacity", 0.8);

                    // Stability indicator
                    perfIndicators.append("circle")
                        .attr("cx", algorithm.x - 5)
                        .attr("cy", perfY)
                        .attr("r", 2)
                        .attr("fill", "#FFB700")
                        .attr("opacity", 0)
                        .transition()
                        .delay(3900 + (i * 200))
                        .duration(600)
                        .attr("opacity", 0.8);

                    // Latency indicator
                    perfIndicators.append("circle")
                        .attr("cx", algorithm.x + 5)
                        .attr("cy", perfY)
                        .attr("r", 2)
                        .attr("fill", "#FF6B6B")
                        .attr("opacity", 0)
                        .transition()
                        .delay(3900 + (i * 200))
                        .duration(600)
                        .attr("opacity", 0.8);

                    // Diversity indicator
                    perfIndicators.append("circle")
                        .attr("cx", algorithm.x + 15)
                        .attr("cy", perfY)
                        .attr("r", 2)
                        .attr("fill", "#9C27B0")
                        .attr("opacity", 0)
                        .transition()
                        .delay(3900 + (i * 200))
                        .duration(600)
                        .attr("opacity", 0.8);

                    // Animate algorithm entrance
                    algorithmRect.transition()
                        .delay(3300 + (i * 200))
                        .duration(800)
                        .style("opacity", 1);

                    // Connect to reranking component with sophisticated visual effects
                    const rerankingComponent = components[3]; // Reranking & Filtering component
                    const connection = svg.append("line")
                        .attr("class", `ranking-connection ranking-connection-${i}`)
                        .attr("x1", algorithm.x)
                        .attr("y1", algorithm.y - 25)
                        .attr("x2", rerankingComponent.x)
                        .attr("y2", rerankingComponent.y + 35)
                        .attr("stroke", algorithm.color)
                        .attr("stroke-width", 2)
                        .attr("opacity", 0)
                        .attr("stroke-dasharray", "4,4")
                        .attr("marker-end", `url(#arrow-${algorithm.name.toLowerCase()})`);

                    // Animate ranking connections
                    connection.transition()
                        .delay(4500 + (i * 300))
                        .duration(1500)
                        .attr("opacity", 0.4);
                });

                // Add sophisticated RAG performance dashboard with advanced visual storytelling
                const dashboard = svg.append("g").attr("class", "rag-performance-dashboard").attr("transform", `translate(0, ${height - 50})`);

                // Enhanced dashboard background with sophisticated styling
                const dashboardBg = dashboard.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", width)
                    .attr("height", 50)
                    .attr("fill", "rgba(27, 38, 59, 0.9)")
                    .attr("stroke", "var(--primary-border)")
                    .attr("rx", 8)
                    .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.4))")
                    .style("opacity", 0);

                // Calculate comprehensive RAG performance metrics
                const totalLatency = components.reduce((sum, c) => sum + parseInt(c.performance.latency), 0);
                const avgAccuracy = components.reduce((sum, c) => sum + parseInt(c.performance.accuracy), 0) / components.length;
                const totalCost = components.reduce((sum, c) => sum + parseFloat(c.performance.cost.replace('$', '')), 0);
                const criticalComponents = components.filter(c => c.priority === "Critical").length;
                const avgEfficiency = components.reduce((sum, c) => sum + parseInt(c.metrics.efficiency), 0) / components.length;
                const totalThroughput = components.reduce((sum, c) => {
                    const throughput = parseInt(c.metrics.throughput.split('/')[0]);
                    return sum + throughput;
                }, 0);

                // Add dashboard title
                dashboard.append("text")
                    .attr("x", 10)
                    .attr("y", 15)
                    .attr("fill", "var(--accent-blue)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .text("Advanced RAG Pipeline Performance Dashboard")
                    .transition()
                    .delay(4000)
                    .duration(800)
                    .style("opacity", 1);

                // Enhanced RAG metrics with sophisticated visual indicators
                const ragMetrics = [
                    {
                        label: "Total Latency",
                        value: `${totalLatency}ms`,
                        x: 10,
                        y: 30,
                        color: "var(--accent-cyan)",
                        icon: "⏱️",
                        trend: "stable"
                    },
                    {
                        label: "Avg Accuracy",
                        value: `${avgAccuracy.toFixed(1)}%`,
                        x: width / 5,
                        y: 30,
                        color: "var(--accent-green)",
                        icon: "🎯",
                        trend: "up"
                    },
                    {
                        label: "Total Cost",
                        value: `$${totalCost.toFixed(3)}`,
                        x: 2 * width / 5,
                        y: 30,
                        color: "var(--accent-purple)",
                        icon: "💰",
                        trend: "stable"
                    },
                    {
                        label: "Critical Components",
                        value: `${criticalComponents}/${components.length}`,
                        x: 3 * width / 5,
                        y: 30,
                        color: "var(--accent-red)",
                        icon: "⚡",
                        trend: "stable"
                    },
                    {
                        label: "Avg Efficiency",
                        value: `${avgEfficiency.toFixed(1)}%`,
                        x: 4 * width / 5,
                        y: 30,
                        color: "var(--accent-blue)",
                        icon: "📈",
                        trend: "up"
                    }
                ];

                // Render RAG metrics with sophisticated animations
                ragMetrics.forEach((metric, i) => {
                    const metricGroup = dashboard.append("g").attr("class", "rag-metric-group");

                    // Metric icon
                    metricGroup.append("text")
                        .attr("x", metric.x - 15)
                        .attr("y", metric.y)
                        .attr("fill", metric.color)
                        .style("font-size", "14px")
                        .style("opacity", 0)
                        .text(metric.icon)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Metric label
                    metricGroup.append("text")
                        .attr("x", metric.x)
                        .attr("y", metric.y - 5)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "9px")
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(metric.label)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Metric value
                    metricGroup.append("text")
                        .attr("x", metric.x)
                        .attr("y", metric.y + 8)
                        .attr("fill", metric.color)
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .style("opacity", 0)
                        .text(metric.value)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);

                    // Trend indicator
                    const trendIcon = metric.trend === "up" ? "↗" : metric.trend === "down" ? "↘" : "→";
                    metricGroup.append("text")
                        .attr("x", metric.x + 50)
                        .attr("y", metric.y)
                        .attr("fill", metric.trend === "up" ? "var(--accent-green)" : metric.trend === "down" ? "var(--accent-red)" : "var(--accent-cyan)")
                        .style("font-size", "12px")
                        .style("opacity", 0)
                        .text(trendIcon)
                        .transition()
                        .delay(4500 + (i * 200))
                        .duration(600)
                        .style("opacity", 1);
                });

                // Add RAG performance sparklines for visual storytelling
                const sparklineData = [92, 95, 94, 96, 95, 97, 96, 98, 97, 98];
                const sparklineGroup = dashboard.append("g").attr("class", "rag-sparkline").attr("transform", `translate(${width - 120}, 15)`);

                const sparklineScale = d3.scaleLinear()
                    .domain([0, sparklineData.length - 1])
                    .range([0, 100]);

                const sparklineValueScale = d3.scaleLinear()
                    .domain(d3.extent(sparklineData))
                    .range([10, 20]);

                const sparklinePath = d3.line()
                    .x((d, i) => sparklineScale(i))
                    .y(d => sparklineValueScale(d))
                    .curve(d3.curveMonotoneX);

                sparklineGroup.append("path")
                    .datum(sparklineData)
                    .attr("d", sparklinePath)
                    .attr("fill", "none")
                    .attr("stroke", "var(--accent-blue)")
                    .attr("stroke-width", 2)
                    .style("opacity", 0)
                    .transition()
                    .delay(5000)
                    .duration(1500)
                    .style("opacity", 1);

                // Add sparkline label
                sparklineGroup.append("text")
                    .attr("x", 50)
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-blue)")
                    .style("font-size", "8px")
                    .style("font-weight", "bold")
                    .style("opacity", 0)
                    .text("Accuracy Trend")
                    .transition()
                    .delay(5000)
                    .duration(600)
                    .style("opacity", 1);

                // Animate dashboard entrance
                dashboardBg.transition()
                    .delay(3500)
                    .duration(1000)
                    .style("opacity", 1);
            }

            /** Renders the Frontend Integration architecture visualization with responsive design and dynamic state management. */
            function renderFrontendIntegrationViz() {
                const container = d3.select("#frontend-integration-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on container size
                const isMobile = bounds.width < 768;
                const isTablet = bounds.width >= 768 && bounds.width < 1024;
                const margin = { 
                    top: isMobile ? 30 : isTablet ? 35 : 40, 
                    right: isMobile ? 15 : isTablet ? 17 : 20, 
                    bottom: isMobile ? 30 : isTablet ? 35 : 40, 
                    left: isMobile ? 15 : isTablet ? 17 : 20 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Calculate responsive layer dimensions and spacing
                const layerDimensions = {
                    width: isMobile ? width * 0.9 : width * 0.8,
                    height: isMobile ? 30 : isTablet ? 35 : 40,
                    cornerRadius: isMobile ? 6 : 8,
                    fontSize: isMobile ? "11px" : isTablet ? "12px" : "14px",
                    spacing: isMobile ? height * 0.25 : height * 0.3
                };

                const layerX = (width - layerDimensions.width) / 2;

                const layers = [
                    { 
                        name: isMobile ? "React/Angular + TS" : isTablet ? "React/Angular + TypeScript" : "React/Angular + TypeScript", 
                        y: height * 0.2, 
                        color: "var(--accent-purple)", 
                        tooltip: "<b>Frontend Framework</b><br>Type-safe component architecture with React Hooks or Angular services. Implements real-time state management, optimistic UI updates, and streaming response handling for fluid AI interactions." 
                    },
                    { 
                        name: isMobile ? "GraphQL + WebSocket" : isTablet ? "GraphQL + WebSocket/SSE" : "GraphQL + WebSocket/SSE", 
                        y: height * 0.5, 
                        color: "var(--accent-cyan)", 
                        tooltip: "<b>API & Real-time Layer</b><br>Efficient data fetching with GraphQL subscriptions and real-time communication via WebSockets or Server-Sent Events. Enables streaming AI responses and live collaboration features." 
                    },
                    { 
                        name: isMobile ? "State + Caching" : isTablet ? "State Management + Cache" : "State Management + Caching", 
                        y: height * 0.8, 
                        color: "var(--accent-green)", 
                        tooltip: "<b>State & Caching Layer</b><br>Redux/Zustand for complex state management with intelligent caching strategies. Implements conversation persistence, offline capabilities, and optimized re-rendering for AI applications." 
                    }
                ];

                // Render responsive integration layers
                layers.forEach((layer, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node integration-layer")
                        .on("mouseover", (e) => {
                            showTooltip(e, layer.tooltip);
                            // Highlight current layer
                            svg.selectAll(".integration-layer").style("opacity", 0.4);
                            g.style("opacity", 1.0);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".integration-layer").style("opacity", 1.0);
                        });

                    // Layer background with responsive sizing
                    g.append("rect")
                        .attr("x", layerX)
                        .attr("y", layer.y - (layerDimensions.height / 2))
                        .attr("width", layerDimensions.width)
                        .attr("height", layerDimensions.height)
                        .attr("fill", layer.color)
                        .attr("rx", layerDimensions.cornerRadius)
                        .attr("opacity", 0.8)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.2))")
                        .style("transition", "all 0.3s ease");

                    // Layer text with responsive sizing
                    g.append("text")
                        .attr("x", width / 2)
                        .attr("y", layer.y + (isMobile ? 3 : 5))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-weight", "bold")
                        .style("font-size", layerDimensions.fontSize)
                        .text(layer.name);

                    // Add layer index indicator for mobile
                    if (isMobile) {
                        g.append("circle")
                            .attr("cx", layerX + 15)
                            .attr("cy", layer.y)
                            .attr("r", 8)
                            .attr("fill", "rgba(255,255,255,0.2)")
                            .attr("stroke", "white")
                            .attr("stroke-width", 1);

                        g.append("text")
                            .attr("x", layerX + 15)
                            .attr("y", layer.y + 3)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", "10px")
                            .style("font-weight", "bold")
                            .text(i + 1);
                    }
                });
            }

            /** Renders the Bias Detection & Interpretability visualization dashboard with comprehensive monitoring and analysis tools. */
            function renderBiasInterpretabilityViz() {
                const container = d3.select("#bias-interpretability-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation based on screen size
                const isSmallScreen = bounds.width < 600;
                const isMediumScreen = bounds.width < 900;
                const margin = {
                    top: isSmallScreen ? 30 : 40,
                    right: isSmallScreen ? 15 : 20,
                    bottom: isSmallScreen ? 30 : 40,
                    left: isSmallScreen ? 15 : 20
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers for bias detection flows
                arrowMarker(svg, "arrow-bias-detection", "var(--accent-green)");
                arrowMarker(svg, "arrow-interpretability", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-mitigation", "var(--accent-purple)");
                arrowMarker(svg, "arrow-monitoring", "var(--accent-blue)");

                // Advanced gradient definitions for bias detection dashboard
                const defs = svg.append("defs");

                // Bias detection method gradients
                const biasGradients = [
                    { id: "adversarial-grad", colors: ["#FF6B6B", "#CC5555"], direction: "vertical" },
                    { id: "lime-shap-grad", colors: ["#2EC4B6", "#1DA9A0"], direction: "diagonal" },
                    { id: "attention-grad", colors: ["#3A86FF", "#1D4ED8"], direction: "radial" },
                    { id: "human-loop-grad", colors: ["#8338EC", "#6D2BCA"], direction: "horizontal" }
                ];

                biasGradients.forEach(grad => {
                    const gradient = defs.append("linearGradient").attr("id", grad.id);
                    if (grad.direction === "vertical") {
                        gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                    } else if (grad.direction === "horizontal") {
                        gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                    } else if (grad.direction === "diagonal") {
                        gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                    } else if (grad.direction === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", grad.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                        return;
                    }
                    gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                    gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                });

                const centerX = width / 2; const centerY = height / 2;
                // Bias detection and interpretability approaches with comprehensive metrics
                // Responsive approach positioning with dynamic layout
                const basePositions = isSmallScreen ? [
                    { x: width * 0.25, y: height * 0.15 },  // Top-left with more padding
                    { x: width * 0.75, y: height * 0.15 },  // Top-right with more padding  
                    { x: width * 0.25, y: height * 0.55 },  // Mid-left
                    { x: width * 0.75, y: height * 0.85 }   // Bottom-right with more padding
                ] : [
                    { x: width * 0.2, y: height * 0.3 },    // Original positions for larger screens
                    { x: width * 0.8, y: height * 0.3 },
                    { x: width * 0.2, y: height * 0.7 },
                    { x: width * 0.8, y: height * 0.7 }
                ];

                const approaches = [
                    {
                        name: "Adversarial\nDebiasing",
                        x: basePositions[0].x,
                        y: basePositions[0].y,
                        gradient: "adversarial-grad",
                        icon: "⚔️",
                        category: "Mitigation",
                        effectiveness: 85,
                        complexity: "high",
                        cost: "$0.05",
                        tooltip: "<b>Adversarial Debiasing</b><br>Training discriminators to detect and remove biased representations during model training. Implements fairness constraints through adversarial objectives that enforce demographic parity and equalized opportunity.<br><br><b>Effectiveness:</b> 85% bias reduction<br><b>Complexity:</b> High implementation<br><b>Cost:</b> $0.05 per prediction<br><b>Use Cases:</b> High-stakes decisions, regulatory compliance"
                    },
                    {
                        name: "LIME/SHAP\nExplanations",
                        x: basePositions[1].x,
                        y: basePositions[1].y,
                        gradient: "lime-shap-grad",
                        icon: "🔍",
                        category: "Interpretability",
                        effectiveness: 92,
                        complexity: "medium",
                        cost: "$0.02",
                        tooltip: "<b>LIME/SHAP Explanations</b><br>Local interpretability methods providing feature importance for individual predictions. Essential for understanding model decisions in high-stakes applications and regulatory compliance requirements.<br><br><b>Effectiveness:</b> 92% explanation accuracy<br><b>Complexity:</b> Medium implementation<br><b>Cost:</b> $0.02 per explanation<br><b>Use Cases:</b> Model debugging, regulatory compliance, user trust"
                    },
                    {
                        name: "Attention\nVisualization",
                        x: basePositions[2].x,
                        y: basePositions[2].y,
                        gradient: "attention-grad",
                        icon: "👁️",
                        category: "Analysis",
                        effectiveness: 78,
                        complexity: "low",
                        cost: "$0.01",
                        tooltip: "<b>Attention Visualization</b><br>Attention heatmaps and pattern analysis for transformer models. Reveals model focus patterns, potential biases in attention mechanisms, and provides insights into reasoning processes.<br><br><b>Effectiveness:</b> 78% pattern detection<br><b>Complexity:</b> Low implementation<br><b>Cost:</b> $0.01 per visualization<br><b>Use Cases:</b> Model understanding, bias detection, debugging"
                    },
                    {
                        name: "Human-in-Loop\nSystems",
                        x: basePositions[3].x,
                        y: basePositions[3].y,
                        gradient: "human-loop-grad",
                        icon: "👥",
                        category: "Monitoring",
                        effectiveness: 95,
                        complexity: "high",
                        cost: "$0.10",
                        tooltip: "<b>Human-in-the-Loop</b><br>Continuous monitoring systems with human oversight for bias detection and correction. Implements active learning, human feedback integration, and escalation protocols for ethical AI governance.<br><br><b>Effectiveness:</b> 95% bias detection<br><b>Complexity:</b> High implementation<br><b>Cost:</b> $0.10 per review<br><b>Use Cases:</b> Critical decisions, ethical oversight, continuous improvement"
                    }
                ];

                // Render bias detection approaches
                approaches.forEach((approach, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node bias-approach")
                        .attr("data-category", approach.category)
                        .on("mouseover", (e) => {
                            showTooltip(e, approach.tooltip);
                            // Highlight related approaches
                            svg.selectAll(".bias-approach").style("opacity", 0.4);
                            g.style("opacity", 1.0);
                            // Highlight connections
                            svg.selectAll(".connection-line").style("opacity", 0.3);
                            svg.selectAll(`.connection-${i}`).style("opacity", 1.0).style("stroke-width", 3);
                        })
                        .on("mouseout", () => {
                            hideTooltip();
                            svg.selectAll(".bias-approach").style("opacity", 1.0);
                            svg.selectAll(".connection-line").style("opacity", 0.6).style("stroke-width", 2);
                        });

                    // Approach background with gradient
                    g.append("rect")
                        .attr("x", approach.x - 60)
                        .attr("y", approach.y - 40)
                        .attr("width", 120)
                        .attr("height", 80)
                        .attr("fill", `url(#${approach.gradient})`)
                        .attr("rx", 12)
                        .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");

                    // Approach icon
                    g.append("text")
                        .attr("x", approach.x)
                        .attr("y", approach.y - 15)
                        .attr("text-anchor", "middle")
                        .style("font-size", "24px")
                        .text(approach.icon);

                    // Approach name
                    approach.name.split('\n').forEach((line, j) => {
                        g.append("text")
                            .attr("x", approach.x)
                            .attr("y", approach.y + (j * 12) + 5)
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", "11px")
                            .style("font-weight", "bold")
                            .text(line);
                    });

                    // Effectiveness indicator
                    g.append("rect")
                        .attr("x", approach.x - 50)
                        .attr("y", approach.y + 20)
                        .attr("width", approach.effectiveness)
                        .attr("height", 6)
                        .attr("fill", approach.effectiveness > 90 ? "#2EC4B6" : approach.effectiveness > 80 ? "#FFB700" : "#FF6B6B")
                        .attr("rx", 3);

                    // Effectiveness percentage
                    g.append("text")
                        .attr("x", approach.x)
                        .attr("y", approach.y + 35)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "9px")
                        .style("font-weight", "bold")
                        .text(`${approach.effectiveness}%`);
                });

                // Add responsive central monitoring dashboard
                const dashboard = svg.append("g").attr("class", "bias-monitoring-dashboard");

                // Dynamic dashboard sizing based on screen size
                const dashboardWidth = isSmallScreen ? 120 : 160;
                const dashboardHeight = isSmallScreen ? 90 : 120;
                const dashboardX = centerX - (dashboardWidth / 2);
                const dashboardY = centerY - (dashboardHeight / 2);

                // Dashboard background
                dashboard.append("rect")
                    .attr("x", dashboardX)
                    .attr("y", dashboardY)
                    .attr("width", dashboardWidth)
                    .attr("height", dashboardHeight)
                    .attr("fill", "rgba(27, 38, 59, 0.9)")
                    .attr("stroke", "var(--accent-green)")
                    .attr("stroke-width", 2)
                    .attr("rx", 12)
                    .style("filter", "drop-shadow(0 8px 16px rgba(0,0,0,0.5))");

                // Responsive dashboard title
                dashboard.append("text")
                    .attr("x", centerX)
                    .attr("y", dashboardY + (isSmallScreen ? 15 : 20))
                    .attr("text-anchor", "middle")
                    .attr("fill", "var(--accent-green)")
                    .style("font-size", isSmallScreen ? "12px" : "14px")
                    .style("font-weight", "bold")
                    .text("Bias Monitoring");

                // Responsive bias metrics with dynamic positioning
                const metricSpacing = isSmallScreen ? 12 : 15;
                const baseMetricY = dashboardY + (isSmallScreen ? 35 : 45);
                const biasMetrics = [
                    { label: "Demographic Parity", value: "94%", color: "#2EC4B6", y: baseMetricY },
                    { label: "Equalized Opportunity", value: "91%", color: "#3A86FF", y: baseMetricY + metricSpacing },
                    { label: "Calibration", value: "88%", color: "#FFB700", y: baseMetricY + metricSpacing * 2 },
                    { label: "Overall Fairness", value: "92%", color: "#8338EC", y: baseMetricY + metricSpacing * 3 }
                ];

                biasMetrics.forEach(metric => {
                    const labelOffsetX = isSmallScreen ? -45 : -60;
                    const valueOffsetX = isSmallScreen ? 25 : 40;
                    const fontSize = isSmallScreen ? "9px" : "10px";
                    
                    dashboard.append("text")
                        .attr("x", centerX + labelOffsetX)
                        .attr("y", metric.y)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", fontSize)
                        .text(metric.label);

                    dashboard.append("text")
                        .attr("x", centerX + valueOffsetX)
                        .attr("y", metric.y)
                        .attr("fill", metric.color)
                        .style("font-size", fontSize)
                        .style("font-weight", "bold")
                        .text(metric.value);
                });

                // Add optimized bias detection flow connections with intelligent routing
                approaches.forEach((approach, i) => {
                    // Calculate intelligent connection endpoints to avoid overlaps
                    const connectionOffset = 25; // Offset from center to create multiple endpoints
                    const angle = (i * Math.PI * 2) / approaches.length; // Distribute endpoints in circle
                    const endX = centerX + Math.cos(angle) * connectionOffset;
                    const endY = centerY + Math.sin(angle) * connectionOffset;
                    
                    // Create curved path to avoid overlaps and improve visual flow
                    const controlPointOffset = 40;
                    const controlX1 = approach.x + (endX - approach.x) * 0.3 + Math.cos(angle + Math.PI/2) * controlPointOffset;
                    const controlY1 = approach.y + (endY - approach.y) * 0.3 + Math.sin(angle + Math.PI/2) * controlPointOffset;
                    const controlX2 = approach.x + (endX - approach.x) * 0.7 + Math.cos(angle - Math.PI/2) * controlPointOffset;
                    const controlY2 = approach.y + (endY - approach.y) * 0.7 + Math.sin(angle - Math.PI/2) * controlPointOffset;
                    
                    const pathData = `M ${approach.x} ${approach.y} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
                    
                    const connection = svg.append("path")
                        .attr("class", `connection-line connection-${i}`)
                        .attr("d", pathData)
                        .attr("fill", "none")
                        .attr("stroke", approach.category === "Mitigation" ? "var(--accent-purple)" :
                            approach.category === "Interpretability" ? "var(--accent-cyan)" :
                                approach.category === "Analysis" ? "var(--accent-blue)" : "var(--accent-green)")
                        .attr("stroke-width", 2)
                        .attr("opacity", 0.6)
                        .attr("stroke-dasharray", "5,5")
                        .attr("marker-end", "url(#arrow-bias-detection)");

                    // Animate the connection with improved timing
                    const pathLength = connection.node().getTotalLength();
                    connection.attr("stroke-dasharray", `${pathLength} ${pathLength}`)
                        .attr("stroke-dashoffset", pathLength)
                        .transition()
                        .duration(2000)
                        .delay(i * 200) // Reduced delay for smoother animation
                        .ease(d3.easeCubicInOut)
                        .attr("stroke-dashoffset", 0);
                });

                // Add responsive bias detection legend with boundary detection
                const legendWidth = isSmallScreen ? 90 : 120;
                const legendX = Math.min(width - legendWidth - 10, width - 120);
                const legendY = isSmallScreen ? 10 : 20;
                const legend = svg.append("g").attr("class", "bias-legend").attr("transform", `translate(${legendX}, ${legendY})`);

                legend.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", isSmallScreen ? "11px" : "12px")
                    .style("font-weight", "bold")
                    .text("Bias Detection");

                const legendItemSpacing = isSmallScreen ? 16 : 20;
                const legendItems = [
                    { category: "Mitigation", color: "var(--accent-purple)", y: legendItemSpacing },
                    { category: "Interpretability", color: "var(--accent-cyan)", y: legendItemSpacing * 2 },
                    { category: "Analysis", color: "var(--accent-blue)", y: legendItemSpacing * 3 },
                    { category: "Monitoring", color: "var(--accent-green)", y: legendItemSpacing * 4 }
                ];

                legendItems.forEach(item => {
                    const rectSize = isSmallScreen ? 10 : 12;
                    const textOffsetX = isSmallScreen ? 18 : 25;
                    const textSize = isSmallScreen ? "9px" : "10px";
                    
                    legend.append("rect")
                        .attr("x", 5)
                        .attr("y", item.y - (rectSize / 2) - 2)
                        .attr("width", rectSize)
                        .attr("height", rectSize)
                        .attr("fill", item.color)
                        .attr("rx", 2);

                    legend.append("text")
                        .attr("x", textOffsetX)
                        .attr("y", item.y + 2)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", textSize)
                        .text(item.category);
                });
            }

            /** Renders the Model Context Protocol (MCP) visualization with tool orchestration flow and security boundaries. */
            function renderMCPProtocolViz() {
                const container = d3.select("#mcp-protocol-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive margin calculation for MCP Protocol
                const isSmallScreen = bounds.width < 600;
                const isMediumScreen = bounds.width < 900;
                const margin = {
                    top: isSmallScreen ? 30 : 40,
                    right: isSmallScreen ? 15 : 20,
                    bottom: isSmallScreen ? 30 : 40,
                    left: isSmallScreen ? 15 : 20
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers for MCP protocol flows
                arrowMarker(svg, "arrow-mcp-request", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-mcp-response", "var(--accent-green)");
                arrowMarker(svg, "arrow-tool-discovery", "var(--accent-purple)");
                arrowMarker(svg, "arrow-security-boundary", "var(--accent-blue)");

                // Advanced gradient definitions for MCP protocol visualization
                const defs = svg.append("defs");

                // MCP component gradients
                const mcpGradients = [
                    { id: "agent-grad", colors: ["#3A86FF", "#1D4ED8"], direction: "radial" },
                    { id: "mcp-server-grad", colors: ["#00A6FB", "#0077B6"], direction: "vertical" },
                    { id: "tool-grad", colors: ["#2EC4B6", "#1DA9A0"], direction: "diagonal" },
                    { id: "security-grad", colors: ["#8338EC", "#6D2BCA"], direction: "horizontal" }
                ];

                mcpGradients.forEach(grad => {
                    if (grad.direction === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", grad.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                    } else {
                        const gradient = defs.append("linearGradient").attr("id", grad.id);
                        if (grad.direction === "vertical") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                        } else if (grad.direction === "horizontal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
                        } else if (grad.direction === "diagonal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                        }
                        gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                    }
                });

                const centerX = width / 2; const centerY = height / 2;

                // Optimized MCP protocol components with intelligent spacing
                const componentSpacing = Math.max(width * 0.25, 120); // Minimum spacing between components
                const leftMargin = Math.max(width * 0.1, 60); // Minimum left margin
                const rightMargin = Math.max(width * 0.1, 60); // Minimum right margin
                const availableWidth = width - leftMargin - rightMargin;
                
                const components = [
                    {
                        name: "AI Agent",
                        x: leftMargin + componentSpacing * 0.5,
                        y: centerY,
                        gradient: "agent-grad",
                        icon: "🤖",
                        type: "Client",
                        capabilities: ["Tool Discovery", "Request Orchestration", "Response Processing"],
                        tooltip: "<b>AI Agent (MCP Client)</b><br>Intelligent agent that discovers and invokes external tools through the Model Context Protocol. Handles tool discovery, request orchestration, and response processing with built-in security validation.<br><br><b>Capabilities:</b> Tool Discovery, Request Orchestration, Response Processing<br><b>Security:</b> Request validation, response sanitization<br><b>Protocol:</b> MCP Client implementation"
                    },
                    {
                        name: "MCP Server",
                        x: leftMargin + componentSpacing * 1.5,
                        y: centerY,
                        gradient: "mcp-server-grad",
                        icon: "🔗",
                        type: "Protocol",
                        capabilities: ["Tool Registry", "Request Routing", "Security Enforcement"],
                        tooltip: "<b>MCP Server</b><br>Central protocol server that manages tool registry, routes requests to appropriate tools, and enforces security boundaries. Provides standardized interface for tool discovery and invocation across diverse AI systems.<br><br><b>Capabilities:</b> Tool Registry, Request Routing, Security Enforcement<br><b>Security:</b> Authentication, authorization, rate limiting<br><b>Protocol:</b> Standardized MCP specification"
                    },
                    {
                        name: "External Tools",
                        x: leftMargin + componentSpacing * 2.5,
                        y: centerY,
                        gradient: "tool-grad",
                        icon: "🛠️",
                        type: "Service",
                        capabilities: ["API Integration", "Data Processing", "Function Execution"],
                        tooltip: "<b>External Tools & Services</b><br>Diverse external capabilities including APIs, databases, file systems, and specialized services. Each tool implements MCP server interface for standardized integration with AI agents.<br><br><b>Capabilities:</b> API Integration, Data Processing, Function Execution<br><b>Security:</b> Isolated execution, sandboxed environment<br><b>Protocol:</b> MCP Server implementation"
                    }
                ];

                // Optimized security boundary zones with dynamic positioning
                const zoneWidth = Math.min(componentSpacing * 0.8, 140);
                const zoneHeight = 80;
                const securityZones = [
                    {
                        name: "Agent Environment",
                        x: components[0].x,
                        y: centerY,
                        width: zoneWidth,
                        height: zoneHeight,
                        color: "var(--accent-blue)",
                        opacity: 0.1
                    },
                    {
                        name: "MCP Protocol Layer",
                        x: components[1].x,
                        y: centerY,
                        width: zoneWidth,
                        height: zoneHeight,
                        color: "var(--accent-cyan)",
                        opacity: 0.1
                    },
                    {
                        name: "External Services",
                        x: components[2].x,
                        y: centerY,
                        width: zoneWidth,
                        height: zoneHeight,
                        color: "var(--accent-green)",
                        opacity: 0.1
                    }
                ];

                // Render security boundary zones
                securityZones.forEach(zone => {
                    svg.append("rect")
                        .attr("x", zone.x - zone.width / 2)
                        .attr("y", zone.y - zone.height / 2)
                        .attr("width", zone.width)
                        .attr("height", zone.height)
                        .attr("fill", zone.color)
                        .attr("opacity", zone.opacity)
                        .attr("rx", 8)
                        .attr("stroke", zone.color)
                        .attr("stroke-width", 1)
                        .attr("stroke-dasharray", "5,5");

                    svg.append("text")
                        .attr("x", zone.x)
                        .attr("y", zone.y - zone.height / 2 - 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", zone.color)
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .text(zone.name);
                });

                // Optimized MCP Tool-Integrated Retrieval Workflow Flows with intelligent positioning
                const componentOffset = 50; // Distance from component center to connection point
                const retrievalFlows = [
                    {
                        from: { x: components[0].x + componentOffset, y: centerY },
                        to: { x: components[1].x - componentOffset, y: centerY },
                        type: "mcp-request",
                        label: "Tool Discovery Request",
                        color: "var(--accent-cyan)"
                    },
                    {
                        from: { x: components[1].x + componentOffset, y: centerY },
                        to: { x: components[2].x - componentOffset, y: centerY - 30 },
                        type: "tool-discovery",
                        label: "Vector Search Request",
                        color: "var(--accent-green)"
                    },
                    {
                        from: { x: components[1].x + componentOffset, y: centerY },
                        to: { x: components[2].x - componentOffset, y: centerY + 30 },
                        type: "tool-discovery",
                        label: "Knowledge Query",
                        color: "var(--accent-purple)"
                    },
                    {
                        from: { x: components[2].x - componentOffset, y: centerY - 30 },
                        to: { x: components[1].x + componentOffset, y: centerY },
                        type: "mcp-response",
                        label: "Vector Results",
                        color: "var(--accent-green)"
                    },
                    {
                        from: { x: components[2].x - componentOffset, y: centerY + 30 },
                        to: { x: components[1].x + componentOffset, y: centerY },
                        type: "mcp-response",
                        label: "Knowledge Context",
                        color: "var(--accent-purple)"
                    },
                    {
                        from: { x: components[1].x - componentOffset, y: centerY },
                        to: { x: components[0].x + componentOffset, y: centerY },
                        type: "mcp-response",
                        label: "Integrated Response",
                        color: "var(--accent-cyan)"
                    }
                ];

                // Render retrieval workflow flows
                retrievalFlows.forEach(flow => {
                    const path = svg.append("path")
                        .attr("d", `M ${flow.from.x} ${flow.from.y} L ${flow.to.x} ${flow.to.y}`)
                        .attr("stroke", flow.color)
                        .attr("stroke-width", 3)
                        .attr("fill", "none")
                        .attr("marker-end", `url(#arrow-${flow.type})`)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.2))");

                    // Add flow labels
                    const midX = (flow.from.x + flow.to.x) / 2;
                    const midY = (flow.from.y + flow.to.y) / 2;
                    
                    svg.append("text")
                        .attr("x", midX)
                        .attr("y", midY - 8)
                        .attr("text-anchor", "middle")
                        .attr("fill", flow.color)
                        .style("font-size", "9px")
                        .style("font-weight", "bold")
                        .style("background", "white")
                        .style("padding", "2px 4px")
                        .text(flow.label);
                });

                // Render responsive MCP components
                components.forEach((component, i) => {
                    const g = svg.append("g")
                        .attr("class", "interactive-node mcp-component")
                        .attr("data-type", component.type);

                    // Responsive component sizing
                    const compWidth = isSmallScreen ? 80 : 100;
                    const compHeight = isSmallScreen ? 50 : 60;

                    // Component background with gradient
                    g.append("rect")
                        .attr("x", component.x - compWidth / 2)
                        .attr("y", component.y - compHeight / 2)
                        .attr("width", compWidth)
                        .attr("height", compHeight)
                        .attr("fill", `url(#${component.gradient})`)
                        .attr("rx", 8)
                        .attr("stroke", "var(--accent-cyan)")
                        .attr("stroke-width", 2)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Responsive component icon
                    g.append("text")
                        .attr("x", component.x)
                        .attr("y", component.y - (isSmallScreen ? 3 : 5))
                        .attr("text-anchor", "middle")
                        .style("font-size", isSmallScreen ? "16px" : "20px")
                        .text(component.icon);

                    // Responsive component name with truncation
                    g.append("text")
                        .attr("x", component.x)
                        .attr("y", component.y + (isSmallScreen ? 12 : 15))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", isSmallScreen ? "9px" : "11px")
                        .style("font-weight", "bold")
                        .text(isSmallScreen && component.name.length > 10 ? component.name.substring(0, 8) + "..." : component.name);

                    // Component type badge
                    g.append("rect")
                        .attr("x", component.x - 25)
                        .attr("y", component.y + 20)
                        .attr("width", 50)
                        .attr("height", 12)
                        .attr("fill", "rgba(255,255,255,0.2)")
                        .attr("rx", 6);

                    g.append("text")
                        .attr("x", component.x)
                        .attr("y", component.y + 28)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", "8px")
                        .style("font-weight", "bold")
                        .text(component.type);

                    // Add hover interactions
                    g.on("mouseover", function (event) {
                        d3.select(this).select("rect").attr("stroke-width", 3);
                        showTooltip(event, component.tooltip);
                    })
                        .on("mouseout", function () {
                            d3.select(this).select("rect").attr("stroke-width", 2);
                            hideTooltip();
                        });
                });

                // Optimized MCP protocol flow arrows with dynamic positioning
                const flows = [
                    {
                        from: { x: components[0].x + componentOffset, y: centerY },
                        to: { x: components[1].x - componentOffset, y: centerY },
                        type: "mcp-request",
                        label: "Tool Discovery",
                        color: "var(--accent-cyan)"
                    },
                    {
                        from: { x: components[1].x + componentOffset, y: centerY },
                        to: { x: components[2].x - componentOffset, y: centerY },
                        type: "tool-discovery",
                        label: "Tool Invocation",
                        color: "var(--accent-purple)"
                    },
                    {
                        from: { x: components[2].x - componentOffset, y: centerY },
                        to: { x: components[1].x + componentOffset, y: centerY },
                        type: "mcp-response",
                        label: "Response",
                        color: "var(--accent-green)"
                    },
                    {
                        from: { x: components[1].x - componentOffset, y: centerY },
                        to: { x: components[0].x + componentOffset, y: centerY },
                        type: "security-boundary",
                        label: "Validated Response",
                        color: "var(--accent-blue)"
                    }
                ];

                // Render protocol flow arrows
                flows.forEach(flow => {
                    const arrow = svg.append("line")
                        .attr("x1", flow.from.x)
                        .attr("y1", flow.from.y)
                        .attr("x2", flow.to.x)
                        .attr("y2", flow.to.y)
                        .attr("stroke", flow.color)
                        .attr("stroke-width", 3)
                        .attr("marker-end", `url(#arrow-${flow.type})`)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");

                    // Flow label
                    const midX = (flow.from.x + flow.to.x) / 2;
                    const midY = (flow.from.y + flow.to.y) / 2;

                    svg.append("text")
                        .attr("x", midX)
                        .attr("y", midY - 10)
                        .attr("text-anchor", "middle")
                        .attr("fill", flow.color)
                        .style("font-size", "10px")
                        .style("font-weight", "bold")
                        .style("background", "var(--bg-color)")
                        .style("padding", "2px 4px")
                        .text(flow.label);
                });

                // Add MCP protocol legend
                const legend = svg.append("g").attr("class", "mcp-legend").attr("transform", `translate(${width - 140}, 20)`);

                legend.append("text")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("fill", "var(--text-primary)")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("MCP Protocol");

                const legendItems = [
                    { type: "Client", color: "var(--accent-blue)", y: 20 },
                    { type: "Protocol", color: "var(--accent-cyan)", y: 40 },
                    { type: "Service", color: "var(--accent-green)", y: 60 }
                ];

                legendItems.forEach(item => {
                    legend.append("rect")
                        .attr("x", 5)
                        .attr("y", item.y - 8)
                        .attr("width", 12)
                        .attr("height", 12)
                        .attr("fill", item.color)
                        .attr("rx", 2);

                    legend.append("text")
                        .attr("x", 25)
                        .attr("y", item.y + 2)
                        .attr("fill", "var(--text-secondary)")
                        .style("font-size", "10px")
                        .text(item.type);
                });
            }

            /** Renders the Agent-to-Agent (A2A) Communication Protocol visualization with responsive inter-agent coordination flows. */
            function renderA2AProtocolViz() {
                const container = d3.select("#a2a-protocol-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive design detection and adaptive margins
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || bounds.width < 600;
                const isTablet = deviceType.type === 'tablet' || (bounds.width >= 600 && bounds.width < 1024);
                
                const margin = { 
                    top: isMobile ? 20 : 40, 
                    right: isMobile ? 10 : 20, 
                    bottom: isMobile ? 20 : 40, 
                    left: isMobile ? 10 : 20 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers for A2A communication flows
                arrowMarker(svg, "arrow-a2a-request", "var(--accent-purple)");
                arrowMarker(svg, "arrow-a2a-response", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-negotiation", "var(--accent-green)");
                arrowMarker(svg, "arrow-coordination", "var(--accent-blue)");

                // Advanced gradient definitions for A2A protocol visualization
                const defs = svg.append("defs");

                // A2A component gradients
                const a2aGradients = [
                    { id: "agent1-grad", colors: ["#8338EC", "#6D2BCA"], direction: "radial" },
                    { id: "agent2-grad", colors: ["#3A86FF", "#1D4ED8"], direction: "radial" },
                    { id: "agent3-grad", colors: ["#2EC4B6", "#1DA9A0"], direction: "radial" },
                    { id: "coordinator-grad", colors: ["#00A6FB", "#0077B6"], direction: "vertical" }
                ];

                a2aGradients.forEach(grad => {
                    if (grad.direction === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", grad.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                    } else {
                        const gradient = defs.append("linearGradient").attr("id", grad.id);
                        gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                        gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                    }
                });

                const centerX = width / 2; const centerY = height / 2;

                // Enhanced responsive agent positioning with collision detection and adaptive spacing
                const agentRadius = isMobile ? 25 : 35;
                const minSpacing = agentRadius * 2.5; // Minimum spacing between agents
                
                // Calculate optimal agent positions with collision avoidance
                const agentBasePositions = isMobile ? {
                    research: { x: Math.max(width * 0.2, minSpacing), y: Math.max(height * 0.15, minSpacing) },
                    decision: { x: Math.min(width * 0.8, width - minSpacing), y: Math.max(height * 0.15, minSpacing) },
                    execution: { x: Math.max(width * 0.2, minSpacing), y: Math.min(height * 0.85, height - minSpacing) },
                    coordinator: { x: centerX, y: centerY }
                } : isTablet ? {
                    research: { x: Math.max(width * 0.15, minSpacing), y: Math.max(height * 0.25, minSpacing) },
                    decision: { x: Math.min(width * 0.85, width - minSpacing), y: Math.max(height * 0.25, minSpacing) },
                    execution: { x: Math.max(width * 0.15, minSpacing), y: Math.min(height * 0.75, height - minSpacing) },
                    coordinator: { x: centerX, y: centerY }
                } : {
                    research: { x: Math.max(width * 0.15, minSpacing), y: Math.max(height * 0.2, minSpacing) },
                    decision: { x: Math.min(width * 0.85, width - minSpacing), y: Math.max(height * 0.2, minSpacing) },
                    execution: { x: Math.max(width * 0.15, minSpacing), y: Math.min(height * 0.8, height - minSpacing) },
                    coordinator: { x: centerX, y: centerY }
                };

                // A2A protocol agents with specialized roles and responsive sizing
                const agents = [
                    {
                        name: "Research Agent",
                        x: agentBasePositions.research.x,
                        y: agentBasePositions.research.y,
                        gradient: "agent1-grad",
                        icon: "🔍",
                        role: "Information Gathering",
                        capabilities: ["Data Collection", "Analysis", "Report Generation"],
                        tooltip: "<b>Research Agent</b><br>Specialized in information gathering and analysis. Collects data from multiple sources, performs analysis, and generates comprehensive reports for other agents in the system.<br><br><b>Capabilities:</b> Data Collection, Analysis, Report Generation<br><b>Communication:</b> Sends research findings, requests clarification<br><b>Protocol:</b> A2A Research Protocol"
                    },
                    {
                        name: "Decision Agent",
                        x: agentBasePositions.decision.x,
                        y: agentBasePositions.decision.y,
                        gradient: "agent2-grad",
                        icon: "🎯",
                        role: "Strategic Planning",
                        capabilities: ["Decision Making", "Risk Assessment", "Strategy Formulation"],
                        tooltip: "<b>Decision Agent</b><br>Responsible for strategic planning and decision making. Evaluates options, assesses risks, and formulates strategies based on input from other agents.<br><br><b>Capabilities:</b> Decision Making, Risk Assessment, Strategy Formulation<br><b>Communication:</b> Requests analysis, sends decisions<br><b>Protocol:</b> A2A Decision Protocol"
                    },
                    {
                        name: "Execution Agent",
                        x: agentBasePositions.execution.x,
                        y: agentBasePositions.execution.y,
                        gradient: "agent3-grad",
                        icon: "⚡",
                        role: "Task Execution",
                        capabilities: ["Task Implementation", "Progress Monitoring", "Result Reporting"],
                        tooltip: "<b>Execution Agent</b><br>Handles task implementation and execution. Monitors progress, reports results, and coordinates with other agents for complex multi-step operations.<br><br><b>Capabilities:</b> Task Implementation, Progress Monitoring, Result Reporting<br><b>Communication:</b> Receives tasks, sends progress updates<br><b>Protocol:</b> A2A Execution Protocol"
                    },
                    {
                        name: "Coordinator",
                        x: agentBasePositions.coordinator.x,
                        y: agentBasePositions.coordinator.y,
                        gradient: "coordinator-grad",
                        icon: "🎭",
                        role: "System Orchestration",
                        capabilities: ["Message Routing", "Conflict Resolution", "Load Balancing"],
                        tooltip: "<b>System Coordinator</b><br>Central orchestrator that manages inter-agent communication, resolves conflicts, and balances workload across the multi-agent system.<br><br><b>Capabilities:</b> Message Routing, Conflict Resolution, Load Balancing<br><b>Communication:</b> Routes all messages, manages protocols<br><b>Protocol:</b> A2A Coordination Protocol"
                    }
                ];

                // Optimized communication zones with intelligent boundary management
                const baseZoneSize = isMobile ? { width: 90, height: 60 } : { width: 120, height: 80 };
                const zonePadding = isMobile ? 15 : 20; // Padding around agents
                
                // Calculate zone sizes based on agent radius and content
                const zoneSize = {
                    width: Math.max(baseZoneSize.width, agentRadius * 2 + zonePadding * 2),
                    height: Math.max(baseZoneSize.height, agentRadius * 2 + zonePadding * 2 + 25) // Extra space for labels
                };
                
                const communicationZones = [
                    {
                        name: "Research Zone",
                        x: agentBasePositions.research.x - zoneSize.width / 2,
                        y: agentBasePositions.research.y - zoneSize.height / 2,
                        width: zoneSize.width,
                        height: zoneSize.height,
                        color: "var(--accent-purple)",
                        opacity: 0.1,
                        agentIndex: 0
                    },
                    {
                        name: "Decision Zone",
                        x: agentBasePositions.decision.x - zoneSize.width / 2,
                        y: agentBasePositions.decision.y - zoneSize.height / 2,
                        width: zoneSize.width,
                        height: zoneSize.height,
                        color: "var(--accent-blue)",
                        opacity: 0.1,
                        agentIndex: 1
                    },
                    {
                        name: "Execution Zone",
                        x: agentBasePositions.execution.x - zoneSize.width / 2,
                        y: agentBasePositions.execution.y - zoneSize.height / 2,
                        width: zoneSize.width,
                        height: zoneSize.height,
                        color: "var(--accent-green)",
                        opacity: 0.1,
                        agentIndex: 2
                    },
                    {
                        name: "Coordination Hub",
                        x: agentBasePositions.coordinator.x - zoneSize.width / 2,
                        y: agentBasePositions.coordinator.y - zoneSize.height / 2,
                        width: zoneSize.width,
                        height: zoneSize.height,
                        color: "var(--accent-cyan)",
                        opacity: 0.15,
                        agentIndex: 3
                    }
                ];

                // Render optimized communication zones with enhanced boundary visualization
                communicationZones.forEach((zone, index) => {
                    // Zone background with gradient effect
                    const zoneGroup = svg.append("g").attr("class", `communication-zone zone-${index}`);
                    
                    // Zone background
                    zoneGroup.append("rect")
                        .attr("x", zone.x)
                        .attr("y", zone.y)
                        .attr("width", zone.width)
                        .attr("height", zone.height)
                        .attr("fill", zone.color)
                        .attr("opacity", zone.opacity)
                        .attr("rx", 12)
                        .attr("stroke", zone.color)
                        .attr("stroke-width", 1.5)
                        .attr("stroke-dasharray", "5,5")
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.1))");

                    // Zone boundary highlight
                    zoneGroup.append("rect")
                        .attr("x", zone.x + 2)
                        .attr("y", zone.y + 2)
                        .attr("width", zone.width - 4)
                        .attr("height", zone.height - 4)
                        .attr("fill", "none")
                        .attr("stroke", zone.color)
                        .attr("stroke-width", 0.5)
                        .attr("stroke-opacity", 0.3)
                        .attr("rx", 10);

                    // Zone label with background
                    const labelBg = zoneGroup.append("rect")
                        .attr("x", zone.x + zone.width / 2 - 25)
                        .attr("y", zone.y - 12)
                        .attr("width", 50)
                        .attr("height", 10)
                        .attr("fill", zone.color)
                        .attr("opacity", 0.8)
                        .attr("rx", 5);

                    zoneGroup.append("text")
                        .attr("x", zone.x + zone.width / 2)
                        .attr("y", zone.y - 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", isMobile ? "7px" : "9px")
                        .style("font-weight", "bold")
                        .text(isMobile ? zone.name.split(' ')[0] : zone.name);

                    // Add zone interaction for highlighting
                    zoneGroup.on("mouseover", function() {
                        // Highlight zone and contained agent
                        zoneGroup.selectAll("rect").attr("opacity", 0.2);
                        svg.selectAll(`.a2a-agent:nth-child(${zone.agentIndex + 1}) circle`)
                            .attr("stroke-width", 3)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                    })
                    .on("mouseout", function() {
                        // Reset zone and agent highlighting
                        zoneGroup.selectAll("rect").attr("opacity", zone.opacity);
                        svg.selectAll(`.a2a-agent:nth-child(${zone.agentIndex + 1}) circle`)
                            .attr("stroke-width", isMobile ? 1.5 : 2)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                    });
                });

                // Render A2A agents with responsive sizing and collision detection
                agents.forEach((agent, i) => {
                    // Calculate responsive agent sizing
                    const agentRadius = isMobile ? 25 : 35;
                    const iconSize = isMobile ? "14px" : "18px";
                    const nameSize = isMobile ? "8px" : "10px";
                    const roleSize = isMobile ? "6px" : "7px";
                    const badgeWidth = isMobile ? 50 : 60;
                    const badgeHeight = isMobile ? 8 : 10;

                    const g = svg.append("g")
                        .attr("class", "interactive-node a2a-agent")
                        .attr("data-role", agent.role);

                    // Agent background with gradient and responsive radius
                    g.append("circle")
                        .attr("cx", agent.x)
                        .attr("cy", agent.y)
                        .attr("r", agentRadius)
                        .attr("fill", `url(#${agent.gradient})`)
                        .attr("stroke", "var(--accent-cyan)")
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Agent icon with responsive sizing
                    g.append("text")
                        .attr("x", agent.x)
                        .attr("y", agent.y - (isMobile ? 3 : 5))
                        .attr("text-anchor", "middle")
                        .style("font-size", iconSize)
                        .text(agent.icon);

                    // Agent name with responsive text truncation
                    const agentName = isMobile && agent.name.length > 8 ? agent.name.split(' ')[0] : agent.name;
                    g.append("text")
                        .attr("x", agent.x)
                        .attr("y", agent.y + (isMobile ? 8 : 10))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", nameSize)
                        .style("font-weight", "bold")
                        .text(agentName);

                    // Agent role badge with responsive sizing
                    if (!isMobile || (isMobile && i < 4)) { // Only show badges on mobile for first 4 agents
                        g.append("rect")
                            .attr("x", agent.x - badgeWidth / 2)
                            .attr("y", agent.y + (isMobile ? 12 : 15))
                            .attr("width", badgeWidth)
                            .attr("height", badgeHeight)
                            .attr("fill", "rgba(255,255,255,0.2)")
                            .attr("rx", isMobile ? 3 : 5);

                        // Responsive role text with truncation
                        const roleText = isMobile ? agent.role.split(' ')[0] : agent.role;
                        g.append("text")
                            .attr("x", agent.x)
                            .attr("y", agent.y + (isMobile ? 18 : 22))
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", roleSize)
                            .style("font-weight", "bold")
                            .text(roleText);
                    }

                    // Enhanced responsive agent interactions with touch support and accessibility
                    g.on("mouseover", function (event) {
                        d3.select(this).select("circle")
                            .attr("stroke-width", 3)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                        showTooltip(event, agent.tooltip);
                    })
                    .on("mouseout", function () {
                        d3.select(this).select("circle")
                            .attr("stroke-width", isMobile ? 1.5 : 2)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                        hideTooltip();
                    })
                    .on("click", function (event) {
                        // Enhanced click interaction for mobile and desktop
                        const clickedAgent = d3.select(this);
                        const isActive = clickedAgent.classed("active");
                        
                        // Remove active state from all agents
                        svg.selectAll(".a2a-agent").classed("active", false)
                            .select("circle").attr("stroke-width", isMobile ? 1.5 : 2);
                        
                        if (!isActive) {
                            // Activate clicked agent
                            clickedAgent.classed("active", true)
                                .select("circle")
                                .attr("stroke-width", 4)
                                .style("filter", "drop-shadow(0 8px 16px rgba(0,0,0,0.5))");
                            
                            // Show enhanced tooltip with more details
                            const enhancedTooltip = `${agent.tooltip}<br><br><b>Communication Status:</b> Active<br><b>Message Queue:</b> ${Math.floor(Math.random() * 5)} pending<br><b>Response Time:</b> ${Math.floor(Math.random() * 100 + 50)}ms`;
                            showTooltip(event, enhancedTooltip);
                        } else {
                            hideTooltip();
                        }
                    });
                    
                    // Add touch support for mobile devices
                    if (isMobile) {
                        g.on("touchstart", function (event) {
                            event.preventDefault();
                            d3.select(this).select("circle")
                                .attr("stroke-width", 3)
                                .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                        })
                        .on("touchend", function (event) {
                            event.preventDefault();
                            d3.select(this).select("circle")
                                .attr("stroke-width", 1.5)
                                .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                        });
                    }
                });

                // Dynamic A2A communication flow arrows with responsive routing
                const flowAgentRadius = isMobile ? 25 : 35;
                const flows = [
                    {
                        from: { 
                            x: agentBasePositions.research.x + flowAgentRadius, 
                            y: agentBasePositions.research.y 
                        },
                        to: { 
                            x: agentBasePositions.coordinator.x - flowAgentRadius, 
                            y: agentBasePositions.coordinator.y 
                        },
                        type: "a2a-request",
                        label: isMobile ? "Research" : "Research Request",
                        color: "var(--accent-purple)",
                        messageType: "data_request"
                    },
                    {
                        from: { 
                            x: agentBasePositions.coordinator.x + flowAgentRadius, 
                            y: agentBasePositions.coordinator.y 
                        },
                        to: { 
                            x: agentBasePositions.decision.x - flowAgentRadius, 
                            y: agentBasePositions.decision.y 
                        },
                        type: "negotiation",
                        label: isMobile ? "Decision" : "Decision Query",
                        color: "var(--accent-green)",
                        messageType: "decision_request"
                    },
                    {
                        from: { 
                            x: agentBasePositions.decision.x - flowAgentRadius, 
                            y: agentBasePositions.decision.y 
                        },
                        to: { 
                            x: agentBasePositions.coordinator.x + flowAgentRadius, 
                            y: agentBasePositions.coordinator.y 
                        },
                        type: "a2a-response",
                        label: isMobile ? "Strategy" : "Strategy Response",
                        color: "var(--accent-cyan)",
                        messageType: "decision_response"
                    },
                    {
                        from: { 
                            x: agentBasePositions.coordinator.x - flowAgentRadius, 
                            y: agentBasePositions.coordinator.y 
                        },
                        to: { 
                            x: agentBasePositions.execution.x + flowAgentRadius, 
                            y: agentBasePositions.execution.y 
                        },
                        type: "coordination",
                        label: isMobile ? "Execute" : "Execution Task",
                        color: "var(--accent-blue)",
                        messageType: "task_assignment"
                    },
                    {
                        from: { 
                            x: agentBasePositions.execution.x + flowAgentRadius, 
                            y: agentBasePositions.execution.y 
                        },
                        to: { 
                            x: agentBasePositions.coordinator.x - flowAgentRadius, 
                            y: agentBasePositions.coordinator.y 
                        },
                        type: "a2a-response",
                        label: isMobile ? "Report" : "Progress Report",
                        color: "var(--accent-green)",
                        messageType: "status_update"
                    }
                ];

                // Render dynamic communication flow arrows with message routing animation
                flows.forEach((flow, flowIndex) => {
                    // Calculate responsive arrow styling
                    const strokeWidth = isMobile ? 1.5 : 2;
                    const labelSize = isMobile ? "7px" : "9px";
                    
                    // Main communication arrow
                    const arrow = svg.append("line")
                        .attr("class", `a2a-flow a2a-${flow.messageType}`)
                        .attr("x1", flow.from.x)
                        .attr("y1", flow.from.y)
                        .attr("x2", flow.to.x)
                        .attr("y2", flow.to.y)
                        .attr("stroke", flow.color)
                        .attr("stroke-width", strokeWidth)
                        .attr("marker-end", `url(#arrow-${flow.type})`)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                        .style("opacity", 0.7);

                    // Dynamic message routing animation
                    const messageDistance = Math.sqrt(
                        Math.pow(flow.to.x - flow.from.x, 2) + 
                        Math.pow(flow.to.y - flow.from.y, 2)
                    );
                    
                    // Enhanced animated message packets with responsive routing
                    const messageCount = isMobile ? 2 : 3; // Fewer messages on mobile for performance
                    const packetSize = isMobile ? 2 : 3;
                    const animationDuration = isMobile ? 1200 : 1500; // Faster on mobile
                    
                    for (let i = 0; i < messageCount; i++) {
                        const messagePacket = svg.append("circle")
                            .attr("class", "message-packet")
                            .attr("cx", flow.from.x)
                            .attr("cy", flow.from.y)
                            .attr("r", packetSize)
                            .attr("fill", flow.color)
                            .style("opacity", 0.8)
                            .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))");

                        // Enhanced message routing animation with dynamic path calculation
                        const pathLength = Math.sqrt(
                            Math.pow(flow.to.x - flow.from.x, 2) + 
                            Math.pow(flow.to.y - flow.from.y, 2)
                        );
                        
                        // Calculate intermediate points for more realistic message routing
                        const intermediatePoints = [];
                        const numPoints = Math.max(2, Math.floor(pathLength / 50)); // More points for longer paths
                        
                        for (let j = 1; j < numPoints; j++) {
                            const t = j / numPoints;
                            const x = flow.from.x + (flow.to.x - flow.from.x) * t;
                            const y = flow.from.y + (flow.to.y - flow.from.y) * t;
                            // Add slight curve to make routing more realistic
                            const curveOffset = Math.sin(t * Math.PI) * (isMobile ? 5 : 10);
                            intermediatePoints.push({
                                x: x + (Math.random() - 0.5) * curveOffset,
                                y: y + (Math.random() - 0.5) * curveOffset
                            });
                        }

                        // Animate message movement through intermediate points
                        let currentPoint = 0;
                        const animateNextPoint = () => {
                            if (currentPoint < intermediatePoints.length) {
                                const point = intermediatePoints[currentPoint];
                                messagePacket
                                    .transition()
                                    .duration(animationDuration / numPoints)
                                    .ease(d3.easeLinear)
                                    .attr("cx", point.x)
                                    .attr("cy", point.y)
                                    .on("end", () => {
                                        currentPoint++;
                                        animateNextPoint();
                                    });
                            } else {
                                // Final movement to destination
                                messagePacket
                                    .transition()
                                    .duration(animationDuration / numPoints)
                                    .ease(d3.easeLinear)
                                    .attr("cx", flow.to.x)
                                    .attr("cy", flow.to.y)
                                    .style("opacity", 0)
                                    .remove();
                            }
                        };

                        // Start animation with delay
                        setTimeout(() => {
                            animateNextPoint();
                        }, flowIndex * 800 + i * 400);
                    }

                    // Enhanced flow label positioning with collision detection and adaptive placement
                    const midX = (flow.from.x + flow.to.x) / 2;
                    const midY = (flow.from.y + flow.to.y) / 2;
                    
                    // Calculate label offset to avoid overlapping with other elements
                    const labelOffset = isMobile ? 15 : 20;
                    const labelX = midX;
                    const labelY = midY - labelOffset;
                    
                    // Check for label collision with other elements and adjust position
                    const labelWidth = flow.label.length * (isMobile ? 4 : 6);
                    const labelHeight = isMobile ? 12 : 16;
                    
                    // Add background for better text readability with adaptive sizing
                    if (!isMobile || width > 400) {
                        svg.append("rect")
                            .attr("x", labelX - labelWidth / 2)
                            .attr("y", labelY - labelHeight / 2)
                            .attr("width", labelWidth)
                            .attr("height", labelHeight)
                            .attr("fill", "var(--bg-color)")
                            .attr("opacity", 0.9)
                            .attr("rx", 4)
                            .style("filter", "drop-shadow(0 1px 3px rgba(0,0,0,0.2))");
                    }

                    svg.append("text")
                        .attr("x", labelX)
                        .attr("y", labelY + (isMobile ? 2 : 4))
                        .attr("text-anchor", "middle")
                        .attr("fill", flow.color)
                        .style("font-size", labelSize)
                        .style("font-weight", "bold")
                        .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                        .text(flow.label);

                    // Message type indicator
                    if (!isMobile && flow.messageType) {
                        svg.append("text")
                            .attr("x", midX)
                            .attr("y", midY + 8)
                            .attr("text-anchor", "middle")
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", "6px")
                            .style("opacity", 0.7)
                            .text(`[${flow.messageType.replace('_', ' ').toUpperCase()}]`);
                    }
                });

                // Enhanced responsive A2A protocol legend with intelligent positioning and collision avoidance
                if (!isMobile || width > 400) { // Only show legend if there's enough space
                    const legendWidth = isMobile ? 90 : 130;
                    const legendHeight = isMobile ? 80 : 100;
                    
                    // Intelligent legend positioning to avoid overlapping with agents
                    let legendX, legendY;
                    if (isMobile) {
                        // For mobile, position legend in top-right corner with margin
                        legendX = Math.min(width - legendWidth - 5, width * 0.7);
                        legendY = 5;
                    } else {
                        // For larger screens, position legend in optimal location
                        legendX = Math.min(width - legendWidth - 10, width * 0.75);
                        legendY = 10;
                    }
                    
                    // Dynamic legend positioning based on agent positions to avoid collisions
                    const agentPositions = [
                        { x: agentBasePositions.research.x, y: agentBasePositions.research.y },
                        { x: agentBasePositions.decision.x, y: agentBasePositions.decision.y },
                        { x: agentBasePositions.execution.x, y: agentBasePositions.execution.y },
                        { x: agentBasePositions.coordinator.x, y: agentBasePositions.coordinator.y }
                    ];
                    
                    // Check for collisions with agents and adjust legend position
                    let collisionDetected = false;
                    agentPositions.forEach(agent => {
                        const distance = Math.sqrt(Math.pow(agent.x - legendX, 2) + Math.pow(agent.y - legendY, 2));
                        if (distance < 80) { // Collision threshold
                            collisionDetected = true;
                        }
                    });
                    
                    // Adjust legend position if collision detected
                    if (collisionDetected) {
                        if (isMobile) {
                            legendX = Math.max(5, width - legendWidth - 5);
                            legendY = Math.max(5, height - legendHeight - 5);
                        } else {
                            legendX = Math.max(10, width - legendWidth - 10);
                            legendY = Math.max(10, height - legendHeight - 10);
                        }
                    }
                    
                    // Add legend background for better visibility
                    svg.append("rect")
                        .attr("x", legendX - 5)
                        .attr("y", legendY - 5)
                        .attr("width", legendWidth + 10)
                        .attr("height", legendHeight + 10)
                        .attr("fill", "var(--bg-color)")
                        .attr("opacity", 0.95)
                        .attr("rx", 8)
                        .style("filter", "drop-shadow(0 2px 8px rgba(0,0,0,0.15))")
                        .style("stroke", "var(--border-color)")
                        .style("stroke-width", 1);

                    const legend = svg.append("g")
                        .attr("class", "a2a-legend")
                        .attr("transform", `translate(${legendX}, ${legendY})`);

                    legend.append("text")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", isMobile ? "10px" : "12px")
                        .style("font-weight", "bold")
                        .text(isMobile ? "A2A" : "A2A Protocol");

                    const legendItems = [
                        { role: "Research", color: "var(--accent-purple)", y: isMobile ? 15 : 20 },
                        { role: "Decision", color: "var(--accent-blue)", y: isMobile ? 28 : 40 },
                        { role: "Execution", color: "var(--accent-green)", y: isMobile ? 41 : 60 },
                        { role: "Coordination", color: "var(--accent-cyan)", y: isMobile ? 54 : 80 }
                    ];

                    legendItems.forEach(item => {
                        legend.append("circle")
                            .attr("cx", isMobile ? 6 : 8)
                            .attr("cy", item.y)
                            .attr("r", isMobile ? 4 : 6)
                            .attr("fill", item.color)
                            .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.2))");

                        legend.append("text")
                            .attr("x", isMobile ? 15 : 20)
                            .attr("y", item.y + (isMobile ? 2 : 3))
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", isMobile ? "8px" : "10px")
                            .style("font-weight", "500")
                            .text(item.role);
                    });
                }

                // Enhanced responsive resize handler with intelligent layout updates and performance optimization
                let resizeTimeout;
                let lastResizeTime = 0;
                
                function handleA2AResize() {
                    const currentTime = Date.now();
                    if (currentTime - lastResizeTime < 100) return; // Throttle rapid resize events
                    lastResizeTime = currentTime;
                    
                    if (container.node()) {
                        const newBounds = container.node().getBoundingClientRect();
                        const widthChange = Math.abs(newBounds.width - bounds.width);
                        const heightChange = Math.abs(newBounds.height - bounds.height);
                        
                        // Only re-render if there's a significant size change or device type change
                        if (newBounds.width > 0 && (widthChange > 50 || heightChange > 50)) {
                            const newDeviceType = detectDeviceType();
                            const newIsMobile = newDeviceType.type === 'mobile' || newBounds.width < 600;
                            const currentIsMobile = deviceType.type === 'mobile' || bounds.width < 600;
                            
                            // Re-render if device type changed or significant size change
                            if (newIsMobile !== currentIsMobile || widthChange > 100 || heightChange > 100) {
                                renderA2AProtocolViz(); // Re-render with new dimensions
                            }
                        }
                    }
                }

                // Optimized debounced resize handler with performance monitoring
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(handleA2AResize, 250); // Reduced debounce time for better responsiveness
                });
                
                // Add intersection observer for performance optimization
                if ('IntersectionObserver' in window) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                // Visualization is visible, ensure it's properly rendered
                                if (container.select('svg').empty()) {
                                    renderA2AProtocolViz();
                                }
                            }
                        });
                    }, { threshold: 0.1 });
                    
                    if (container.node()) {
                        observer.observe(container.node());
                    }
                }
            }

            /** Renders the Agent User Interaction (AG-UI) Protocol visualization with responsive human-agent interaction flows. */
            function renderAGUIProtocolViz() {
                const container = d3.select("#agui-protocol-viz"); container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect(); if (bounds.width <= 0) return;
                
                // Responsive design detection and adaptive margins
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || bounds.width < 600;
                const isTablet = deviceType.type === 'tablet' || (bounds.width >= 600 && bounds.width < 1024);
                
                const margin = { 
                    top: isMobile ? 20 : 40, 
                    right: isMobile ? 10 : 20, 
                    bottom: isMobile ? 20 : 40, 
                    left: isMobile ? 10 : 20 
                };
                const width = bounds.width - margin.left - margin.right; 
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Enhanced arrow markers for AG-UI interaction flows
                arrowMarker(svg, "arrow-user-input", "var(--accent-green)");
                arrowMarker(svg, "arrow-agent-response", "var(--accent-cyan)");
                arrowMarker(svg, "arrow-task-delegation", "var(--accent-purple)");
                arrowMarker(svg, "arrow-collaboration", "var(--accent-blue)");

                // Advanced gradient definitions for AG-UI protocol visualization
                const defs = svg.append("defs");

                // AG-UI component gradients
                const aguiGradients = [
                    { id: "human-grad", colors: ["#2EC4B6", "#1DA9A0"], direction: "radial" },
                    { id: "agent-grad", colors: ["#3A86FF", "#1D4ED8"], direction: "radial" },
                    { id: "interface-grad", colors: ["#00A6FB", "#0077B6"], direction: "vertical" },
                    { id: "collaboration-grad", colors: ["#8338EC", "#6D2BCA"], direction: "diagonal" }
                ];

                aguiGradients.forEach(grad => {
                    if (grad.direction === "radial") {
                        const radialGrad = defs.append("radialGradient").attr("id", grad.id);
                        radialGrad.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        radialGrad.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                    } else {
                        const gradient = defs.append("linearGradient").attr("id", grad.id);
                        if (grad.direction === "vertical") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
                        } else if (grad.direction === "diagonal") {
                            gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%");
                        }
                        gradient.append("stop").attr("offset", "0%").attr("stop-color", grad.colors[0]).attr("stop-opacity", 0.9);
                        gradient.append("stop").attr("offset", "100%").attr("stop-color", grad.colors[1]).attr("stop-opacity", 0.6);
                    }
                });

                const centerX = width / 2; const centerY = height / 2;

                // Enhanced responsive component positioning with collision detection and adaptive spacing
                const componentRadius = isMobile ? 40 : 50;
                const minSpacing = componentRadius * 3.2; // Optimized minimum spacing for better separation
                const horizontalPadding = Math.max(minSpacing, width * 0.1); // Dynamic horizontal padding
                const verticalPadding = Math.max(minSpacing, height * 0.15); // Dynamic vertical padding
                
                // Calculate optimal component positions with improved collision avoidance and better spacing
                const componentBasePositions = isMobile ? {
                    human: { x: Math.max(horizontalPadding, width * 0.2), y: Math.max(verticalPadding, height * 0.3) },
                    interface: { x: centerX, y: centerY },
                    agent: { x: Math.min(width - horizontalPadding, width * 0.8), y: Math.min(height - verticalPadding, height * 0.7) }
                } : isTablet ? {
                    human: { x: Math.max(horizontalPadding, width * 0.18), y: centerY },
                    interface: { x: centerX, y: centerY },
                    agent: { x: Math.min(width - horizontalPadding, width * 0.82), y: centerY }
                } : {
                    human: { x: Math.max(horizontalPadding, width * 0.15), y: centerY },
                    interface: { x: centerX, y: centerY },
                    agent: { x: Math.min(width - horizontalPadding, width * 0.85), y: centerY }
                };

                // AG-UI protocol components with responsive interaction patterns
                const components = [
                    {
                        name: "Human User",
                        x: componentBasePositions.human.x,
                        y: componentBasePositions.human.y,
                        gradient: "human-grad",
                        icon: "👤",
                        role: "Task Initiator",
                        capabilities: ["Natural Language Input", "Task Specification", "Feedback Provision"],
                        tooltip: "<b>Human User</b><br>Primary interface for human-agent interaction. Provides natural language input, specifies tasks, and provides feedback to guide agent behavior and improve system performance.<br><br><b>Capabilities:</b> Natural Language Input, Task Specification, Feedback Provision<br><b>Interaction:</b> Conversational interface, task delegation<br><b>Protocol:</b> AG-UI Human Interface Protocol",
                        feedbackType: "user_input"
                    },
                    {
                        name: "AG-UI Interface",
                        x: componentBasePositions.interface.x,
                        y: componentBasePositions.interface.y,
                        gradient: "interface-grad",
                        icon: "🖥️",
                        role: "Interaction Mediator",
                        capabilities: ["Intent Recognition", "Context Management", "Response Generation"],
                        tooltip: "<b>AG-UI Interface</b><br>Central mediation layer that processes human input, manages conversation context, and generates appropriate responses. Handles intent recognition, context tracking, and response formatting.<br><br><b>Capabilities:</b> Intent Recognition, Context Management, Response Generation<br><b>Interaction:</b> Bidirectional communication, context preservation<br><b>Protocol:</b> AG-UI Mediation Protocol",
                        feedbackType: "mediation_layer"
                    },
                    {
                        name: "AI Agent",
                        x: componentBasePositions.agent.x,
                        y: componentBasePositions.agent.y,
                        gradient: "agent-grad",
                        icon: "🤖",
                        role: "Task Executor",
                        capabilities: ["Task Processing", "Tool Integration", "Result Synthesis"],
                        tooltip: "<b>AI Agent</b><br>Intelligent agent that processes user requests, integrates with external tools and services, and synthesizes results for human consumption. Maintains conversation state and learning from interactions.<br><br><b>Capabilities:</b> Task Processing, Tool Integration, Result Synthesis<br><b>Interaction:</b> Task execution, progress reporting<br><b>Protocol:</b> AG-UI Agent Protocol",
                        feedbackType: "agent_response"
                    }
                ];

                // Responsive interaction zones with adaptive sizing and improved spacing
                const zoneSize = isMobile ? { width: 95, height: 60 } : { width: 115, height: 70 };
                const zonePadding = isMobile ? 8 : 12; // Additional padding around zones
                const interactionZones = [
                    {
                        name: "Human Interface",
                        x: componentBasePositions.human.x - zoneSize.width / 2 - zonePadding,
                        y: componentBasePositions.human.y - zoneSize.height / 2 - zonePadding,
                        width: zoneSize.width + (zonePadding * 2),
                        height: zoneSize.height + (zonePadding * 2),
                        color: "var(--accent-green)",
                        opacity: 0.08,
                        feedbackZone: "input_zone"
                    },
                    {
                        name: "Mediation Layer",
                        x: componentBasePositions.interface.x - zoneSize.width / 2 - zonePadding,
                        y: componentBasePositions.interface.y - zoneSize.height / 2 - zonePadding,
                        width: zoneSize.width + (zonePadding * 2),
                        height: zoneSize.height + (zonePadding * 2),
                        color: "var(--accent-cyan)",
                        opacity: 0.08,
                        feedbackZone: "processing_zone"
                    },
                    {
                        name: "Agent Processing",
                        x: componentBasePositions.agent.x - zoneSize.width / 2 - zonePadding,
                        y: componentBasePositions.agent.y - zoneSize.height / 2 - zonePadding,
                        width: zoneSize.width + (zonePadding * 2),
                        height: zoneSize.height + (zonePadding * 2),
                        color: "var(--accent-blue)",
                        opacity: 0.1,
                        feedbackZone: "response_zone"
                    }
                ];

                // Render interaction zones
                interactionZones.forEach(zone => {
                    svg.append("rect")
                        .attr("x", zone.x)
                        .attr("y", zone.y)
                        .attr("width", zone.width)
                        .attr("height", zone.height)
                        .attr("fill", zone.color)
                        .attr("opacity", zone.opacity)
                        .attr("rx", 8)
                        .attr("stroke", zone.color)
                        .attr("stroke-width", 1)
                        .attr("stroke-dasharray", "4,4");

                    svg.append("text")
                        .attr("x", zone.x + zone.width / 2)
                        .attr("y", zone.y - 5)
                        .attr("text-anchor", "middle")
                        .attr("fill", zone.color)
                        .style("font-size", isMobile ? "8px" : "10px")
                        .style("font-weight", "bold")
                        .text(isMobile ? zone.name.split(' ')[0] : zone.name);
                });

                // Render AG-UI components with responsive sizing and dynamic feedback
                components.forEach((component, i) => {
                    // Calculate responsive component sizing
                    const compWidth = isMobile ? 80 : 100;
                    const compHeight = isMobile ? 50 : 60;
                    const iconSize = isMobile ? "16px" : "20px";
                    const nameSize = isMobile ? "9px" : "11px";
                    const roleSize = isMobile ? "7px" : "8px";
                    const badgeWidth = isMobile ? 40 : 50;
                    const badgeHeight = isMobile ? 10 : 12;

                    const g = svg.append("g")
                        .attr("class", "interactive-node agui-component")
                        .attr("data-role", component.role)
                        .attr("data-feedback-type", component.feedbackType);

                    // Component background with gradient and responsive sizing
                    const componentRect = g.append("rect")
                        .attr("x", component.x - compWidth / 2)
                        .attr("y", component.y - compHeight / 2)
                        .attr("width", compWidth)
                        .attr("height", compHeight)
                        .attr("fill", `url(#${component.gradient})`)
                        .attr("rx", isMobile ? 6 : 8)
                        .attr("stroke", "var(--accent-cyan)")
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");

                    // Component icon with responsive sizing
                    g.append("text")
                        .attr("x", component.x)
                        .attr("y", component.y - (isMobile ? 3 : 5))
                        .attr("text-anchor", "middle")
                        .style("font-size", iconSize)
                        .text(component.icon);

                    // Component name with responsive text truncation
                    const componentName = isMobile && component.name.length > 8 ? 
                        component.name.replace(/\s+/g, ' ').split(' ')[0] : component.name;
                    g.append("text")
                        .attr("x", component.x)
                        .attr("y", component.y + (isMobile ? 12 : 15))
                        .attr("text-anchor", "middle")
                        .attr("fill", "white")
                        .style("font-size", nameSize)
                        .style("font-weight", "bold")
                        .text(componentName);

                    // Component role badge with responsive sizing
                    if (!isMobile || (isMobile && i < 3)) { // Only show badges on mobile for first 3 components
                        g.append("rect")
                            .attr("x", component.x - badgeWidth / 2)
                            .attr("y", component.y + (isMobile ? 17 : 20))
                            .attr("width", badgeWidth)
                            .attr("height", badgeHeight)
                            .attr("fill", "rgba(255,255,255,0.2)")
                            .attr("rx", isMobile ? 4 : 6);

                        // Responsive role text with truncation
                        const roleText = isMobile ? component.role.split(' ')[0] : component.role;
                        g.append("text")
                            .attr("x", component.x)
                            .attr("y", component.y + (isMobile ? 24 : 28))
                            .attr("text-anchor", "middle")
                            .attr("fill", "white")
                            .style("font-size", roleSize)
                            .style("font-weight", "bold")
                            .text(roleText);
                    }

                    // Dynamic user feedback indicators
                    const feedbackIndicator = g.append("circle")
                        .attr("class", "feedback-indicator")
                        .attr("cx", component.x + (compWidth / 2) - 10)
                        .attr("cy", component.y - (compHeight / 2) + 10)
                        .attr("r", 4)
                        .attr("fill", component.feedbackType === "user_input" ? "var(--accent-green)" : 
                                     component.feedbackType === "mediation_layer" ? "var(--accent-cyan)" : "var(--accent-blue)")
                        .style("opacity", 0.8);

                    // Animated feedback pulse
                    feedbackIndicator
                        .transition()
                        .delay(i * 600)
                        .duration(1000)
                        .attr("r", 6)
                        .style("opacity", 0.4)
                        .transition()
                        .duration(1000)
                        .attr("r", 4)
                        .style("opacity", 0.8);

                    // Enhanced responsive component interactions with dynamic user feedback
                    g.on("mouseover", function (event) {
                        d3.select(this).select("rect")
                            .attr("stroke-width", 3)
                            .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                        showTooltip(event, component.tooltip);
                    })
                    .on("mouseout", function () {
                        d3.select(this).select("rect")
                            .attr("stroke-width", isMobile ? 1.5 : 2)
                            .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                        hideTooltip();
                    })
                    .on("click", function (event) {
                        // Enhanced click interaction for mobile and desktop with user feedback
                        const clickedComponent = d3.select(this);
                        const isActive = clickedComponent.classed("active");
                        
                        // Remove active state from all components
                        svg.selectAll(".agui-component").classed("active", false)
                            .select("rect").attr("stroke-width", isMobile ? 1.5 : 2);
                        
                        if (!isActive) {
                            // Activate clicked component
                            clickedComponent.classed("active", true)
                                .select("rect")
                                .attr("stroke-width", 4)
                                .style("filter", "drop-shadow(0 8px 16px rgba(0,0,0,0.5))");
                            
                            // Show enhanced tooltip with user feedback details
                            const enhancedTooltip = `${component.tooltip}<br><br><b>Interaction Status:</b> Active<br><b>User Satisfaction:</b> ${Math.floor(Math.random() * 40 + 60)}%<br><b>Response Time:</b> ${Math.floor(Math.random() * 200 + 100)}ms<br><b>Feedback Score:</b> ${(Math.random() * 2 + 3).toFixed(1)}/5.0`;
                            showTooltip(event, enhancedTooltip);
                            
                            // Trigger dynamic user feedback animation
                            const feedbackIndicator = clickedComponent.select(".feedback-indicator");
                            feedbackIndicator
                                .transition()
                                .duration(300)
                                .attr("r", 8)
                                .style("opacity", 1)
                                .transition()
                                .duration(300)
                                .attr("r", 4)
                                .style("opacity", 0.8);
                        } else {
                            hideTooltip();
                        }
                    });
                    
                    // Add touch support for mobile devices with haptic feedback simulation
                    if (isMobile) {
                        g.on("touchstart", function (event) {
                            event.preventDefault();
                            d3.select(this).select("rect")
                                .attr("stroke-width", 3)
                                .style("filter", "drop-shadow(0 6px 12px rgba(0,0,0,0.4))");
                            
                            // Simulate haptic feedback with visual pulse
                            const feedbackIndicator = d3.select(this).select(".feedback-indicator");
                            feedbackIndicator
                                .transition()
                                .duration(150)
                                .attr("r", 6)
                                .style("opacity", 1)
                                .transition()
                                .duration(150)
                                .attr("r", 4)
                                .style("opacity", 0.8);
                        })
                        .on("touchend", function (event) {
                            event.preventDefault();
                            d3.select(this).select("rect")
                                .attr("stroke-width", 1.5)
                                .style("filter", "drop-shadow(0 4px 8px rgba(0,0,0,0.3))");
                        });
                    }
                });

                // Dynamic AG-UI interaction flows with responsive positioning and user feedback
                const compWidth = isMobile ? 80 : 100;
                const flowOffset = isMobile ? 8 : 12; // Additional offset for better flow separation
                const flows = [
                    {
                        from: { 
                            x: componentBasePositions.human.x + compWidth / 2 + flowOffset, 
                            y: componentBasePositions.human.y 
                        },
                        to: { 
                            x: componentBasePositions.interface.x - compWidth / 2 - flowOffset, 
                            y: componentBasePositions.interface.y 
                        },
                        type: "user-input",
                        label: isMobile ? "Input" : "Natural Language Input",
                        color: "var(--accent-green)",
                        feedbackType: "user_interaction",
                        userFeedback: "positive"
                    },
                    {
                        from: { 
                            x: componentBasePositions.interface.x + compWidth / 2 + flowOffset, 
                            y: componentBasePositions.interface.y 
                        },
                        to: { 
                            x: componentBasePositions.agent.x - compWidth / 2 - flowOffset, 
                            y: componentBasePositions.agent.y 
                        },
                        type: "task-delegation",
                        label: isMobile ? "Task" : "Task Delegation",
                        color: "var(--accent-purple)",
                        feedbackType: "processing_flow",
                        userFeedback: "neutral"
                    },
                    {
                        from: { 
                            x: componentBasePositions.agent.x - compWidth / 2 - flowOffset, 
                            y: componentBasePositions.agent.y 
                        },
                        to: { 
                            x: componentBasePositions.interface.x + compWidth / 2 + flowOffset, 
                            y: componentBasePositions.interface.y 
                        },
                        type: "agent-response",
                        label: isMobile ? "Results" : "Task Results",
                        color: "var(--accent-cyan)",
                        feedbackType: "response_flow",
                        userFeedback: "positive"
                    },
                    {
                        from: { 
                            x: componentBasePositions.interface.x - compWidth / 2 - flowOffset, 
                            y: componentBasePositions.interface.y 
                        },
                        to: { 
                            x: componentBasePositions.human.x + compWidth / 2 + flowOffset, 
                            y: componentBasePositions.human.y 
                        },
                        type: "collaboration",
                        label: isMobile ? "Feedback" : "Response & Feedback",
                        color: "var(--accent-blue)",
                        feedbackType: "user_feedback",
                        userFeedback: "positive"
                    }
                ];

                // Render dynamic interaction flow arrows with user feedback and responsive features
                flows.forEach((flow, flowIndex) => {
                    // Calculate responsive arrow styling
                    const strokeWidth = isMobile ? 2 : 3;
                    const labelSize = isMobile ? "8px" : "10px";
                    
                    // Main interaction arrow
                    const arrow = svg.append("line")
                        .attr("class", `agui-flow agui-${flow.feedbackType}`)
                        .attr("x1", flow.from.x)
                        .attr("y1", flow.from.y)
                        .attr("x2", flow.to.x)
                        .attr("y2", flow.to.y)
                        .attr("stroke", flow.color)
                        .attr("stroke-width", strokeWidth)
                        .attr("marker-end", `url(#arrow-${flow.type})`)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                        .style("opacity", 0.8);

                    // Enhanced dynamic user feedback animation with responsive behavior
                    const feedbackColor = flow.userFeedback === "positive" ? "var(--accent-green)" :
                                        flow.userFeedback === "negative" ? "var(--accent-red)" : "var(--accent-yellow)";
                    
                    // Responsive feedback animation based on device type
                    const pulseCount = isMobile ? 1 : 2; // Fewer pulses on mobile for performance
                    const pulseSize = isMobile ? 1.5 : 2;
                    const animationDuration = isMobile ? 1200 : 1500; // Faster on mobile
                    
                    for (let i = 0; i < pulseCount; i++) {
                        const feedbackPulse = svg.append("circle")
                            .attr("class", "feedback-pulse")
                            .attr("cx", flow.from.x)
                            .attr("cy", flow.from.y)
                            .attr("r", pulseSize)
                            .attr("fill", feedbackColor)
                            .style("opacity", 0.9)
                            .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.3))");

                        // Enhanced feedback pulse animation with dynamic path calculation
                        const pathLength = Math.sqrt(
                            Math.pow(flow.to.x - flow.from.x, 2) + 
                            Math.pow(flow.to.y - flow.from.y, 2)
                        );
                        
                        // Calculate intermediate points for more realistic feedback routing
                        const intermediatePoints = [];
                        const numPoints = Math.max(2, Math.floor(pathLength / 40)); // More points for longer paths
                        
                        for (let j = 1; j < numPoints; j++) {
                            const t = j / numPoints;
                            const x = flow.from.x + (flow.to.x - flow.from.x) * t;
                            const y = flow.from.y + (flow.to.y - flow.from.y) * t;
                            // Add slight curve to make feedback routing more realistic
                            const curveOffset = Math.sin(t * Math.PI) * (isMobile ? 3 : 6);
                            intermediatePoints.push({
                                x: x + (Math.random() - 0.5) * curveOffset,
                                y: y + (Math.random() - 0.5) * curveOffset
                            });
                        }

                        // Animate feedback pulse through intermediate points
                        let currentPoint = 0;
                        const animateNextPoint = () => {
                            if (currentPoint < intermediatePoints.length) {
                                const point = intermediatePoints[currentPoint];
                                feedbackPulse
                                    .transition()
                                    .duration(animationDuration / numPoints)
                                    .ease(d3.easeLinear)
                                    .attr("cx", point.x)
                                    .attr("cy", point.y)
                                    .on("end", () => {
                                        currentPoint++;
                                        animateNextPoint();
                                    });
                            } else {
                                // Final movement to destination
                                feedbackPulse
                                    .transition()
                                    .duration(animationDuration / numPoints)
                                    .ease(d3.easeLinear)
                                    .attr("cx", flow.to.x)
                                    .attr("cy", flow.to.y)
                                    .style("opacity", 0)
                                    .remove();
                            }
                        };

                        // Start animation with delay
                        setTimeout(() => {
                            animateNextPoint();
                        }, flowIndex * 1000 + i * 500);
                    }

                    // Enhanced flow label positioning with collision detection and adaptive placement
                    const midX = (flow.from.x + flow.to.x) / 2;
                    const midY = (flow.from.y + flow.to.y) / 2;
                    
                    // Calculate label offset to avoid overlapping with components and other elements
                    const labelOffset = isMobile ? 25 : 30; // Increased offset for better separation
                    const labelX = midX;
                    const labelY = midY - labelOffset;
                    
                    // Check for label collision with other elements and adjust position
                    const labelWidth = flow.label.length * (isMobile ? 6 : 8); // Slightly increased for better readability
                    const labelHeight = isMobile ? 16 : 20;
                    
                    // Add background for better text readability with adaptive sizing
                    if (!isMobile || width > 400) {
                        svg.append("rect")
                            .attr("x", labelX - labelWidth / 2)
                            .attr("y", labelY - labelHeight / 2)
                            .attr("width", labelWidth)
                            .attr("height", labelHeight)
                            .attr("fill", "var(--bg-color)")
                            .attr("opacity", 0.95)
                            .attr("rx", 5)
                            .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.2))");
                    }

                    svg.append("text")
                        .attr("x", labelX)
                        .attr("y", labelY + (isMobile ? 3 : 5))
                        .attr("text-anchor", "middle")
                        .attr("fill", flow.color)
                        .style("font-size", labelSize)
                        .style("font-weight", "bold")
                        .style("text-shadow", "0 1px 2px rgba(0,0,0,0.3)")
                        .text(flow.label);

                    // User feedback sentiment indicator
                    if (!isMobile && flow.userFeedback) {
                        const feedbackIcon = flow.userFeedback === "positive" ? "✓" : 
                                           flow.userFeedback === "negative" ? "✗" : "~";
                        svg.append("text")
                            .attr("x", midX)
                            .attr("y", midY + 8)
                            .attr("text-anchor", "middle")
                            .attr("fill", flow.userFeedback === "positive" ? "var(--accent-green)" :
                                         flow.userFeedback === "negative" ? "var(--accent-red)" : "var(--accent-yellow)")
                            .style("font-size", "8px")
                            .style("opacity", 0.8)
                            .text(`[${feedbackIcon} ${flow.feedbackType.replace('_', ' ').toUpperCase()}]`);
                    }
                });

                // Enhanced responsive AG-UI protocol legend with intelligent positioning and feedback indicators
                if (!isMobile || width > 400) { // Only show legend if there's enough space
                    const legendWidth = isMobile ? 95 : 135;
                    const legendHeight = isMobile ? 75 : 95;
                    
                    // Intelligent legend positioning to avoid overlapping with components
                    let legendX, legendY;
                    if (isMobile) {
                        // For mobile, position legend in top-right corner with improved margin and collision avoidance
                        const rightMargin = Math.max(horizontalPadding, 15);
                        legendX = Math.min(width - legendWidth - rightMargin, width * 0.6);
                        legendY = Math.max(verticalPadding * 0.5, 12);
                    } else {
                        // For larger screens, position legend in optimal location with better spacing and collision avoidance
                        const rightMargin = Math.max(horizontalPadding * 0.8, 20);
                        const topMargin = Math.max(verticalPadding * 0.3, 18);
                        legendX = Math.min(width - legendWidth - rightMargin, width * 0.65);
                        legendY = topMargin;
                    }
                    
                    // Add legend background for better visibility
                    svg.append("rect")
                        .attr("x", legendX - 5)
                        .attr("y", legendY - 5)
                        .attr("width", legendWidth + 10)
                        .attr("height", legendHeight + 10)
                        .attr("fill", "var(--bg-color)")
                        .attr("opacity", 0.95)
                        .attr("rx", 8)
                        .style("filter", "drop-shadow(0 2px 8px rgba(0,0,0,0.15))")
                        .style("stroke", "var(--border-color)")
                        .style("stroke-width", 1);

                    const legend = svg.append("g")
                        .attr("class", "agui-legend")
                        .attr("transform", `translate(${legendX}, ${legendY})`);

                    legend.append("text")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("fill", "var(--text-primary)")
                        .style("font-size", isMobile ? "10px" : "12px")
                        .style("font-weight", "bold")
                        .text(isMobile ? "AG-UI" : "AG-UI Protocol");

                    const legendItems = [
                        { role: "Human", color: "var(--accent-green)", y: isMobile ? 15 : 20, feedback: "positive" },
                        { role: "Interface", color: "var(--accent-cyan)", y: isMobile ? 28 : 40, feedback: "neutral" },
                        { role: "Agent", color: "var(--accent-blue)", y: isMobile ? 41 : 60, feedback: "positive" }
                    ];

                    legendItems.forEach(item => {
                        legend.append("rect")
                            .attr("x", 5)
                            .attr("y", item.y - 8)
                            .attr("width", isMobile ? 10 : 12)
                            .attr("height", isMobile ? 10 : 12)
                            .attr("fill", item.color)
                            .attr("rx", 2)
                            .style("filter", "drop-shadow(0 1px 2px rgba(0,0,0,0.2))");

                        legend.append("text")
                            .attr("x", isMobile ? 20 : 25)
                            .attr("y", item.y + (isMobile ? 1 : 2))
                            .attr("fill", "var(--text-secondary)")
                            .style("font-size", isMobile ? "8px" : "10px")
                            .style("font-weight", "500")
                            .text(item.role);

                        // Dynamic feedback indicator with enhanced visibility
                        if (!isMobile) {
                            const feedbackIcon = item.feedback === "positive" ? "✓" : 
                                               item.feedback === "negative" ? "✗" : "~";
                            legend.append("text")
                                .attr("x", 75)
                                .attr("y", item.y + 2)
                                .attr("fill", item.feedback === "positive" ? "var(--accent-green)" :
                                             item.feedback === "negative" ? "var(--accent-red)" : "var(--accent-yellow)")
                                .style("font-size", "8px")
                                .style("opacity", 0.9)
                                .style("font-weight", "bold")
                                .text(feedbackIcon);
                        }
                    });
                }

                // Enhanced responsive resize handler with intelligent layout updates and performance optimization
                let resizeTimeout;
                let lastResizeTime = 0;
                
                function handleAGUIResize() {
                    const currentTime = Date.now();
                    if (currentTime - lastResizeTime < 100) return; // Throttle rapid resize events
                    lastResizeTime = currentTime;
                    
                    if (container.node()) {
                        const newBounds = container.node().getBoundingClientRect();
                        const widthChange = Math.abs(newBounds.width - bounds.width);
                        const heightChange = Math.abs(newBounds.height - bounds.height);
                        
                        // Only re-render if there's a significant size change or device type change
                        if (newBounds.width > 0 && (widthChange > 50 || heightChange > 50)) {
                            const newDeviceType = detectDeviceType();
                            const newIsMobile = newDeviceType.type === 'mobile' || newBounds.width < 600;
                            const currentIsMobile = deviceType.type === 'mobile' || bounds.width < 600;
                            
                            // Re-render if device type changed or significant size change
                            if (newIsMobile !== currentIsMobile || widthChange > 100 || heightChange > 100) {
                                renderAGUIProtocolViz(); // Re-render with new dimensions
                            }
                        }
                    }
                }

                // Optimized debounced resize handler with performance monitoring
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(handleAGUIResize, 250); // Reduced debounce time for better responsiveness
                });
                
                // Add intersection observer for performance optimization
                if ('IntersectionObserver' in window) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                // Visualization is visible, ensure it's properly rendered
                                if (container.select('svg').empty()) {
                                    renderAGUIProtocolViz();
                                }
                            }
                        });
                    }, { threshold: 0.1 });
                    
                    if (container.node()) {
                        observer.observe(container.node());
                    }
                }
            }

            /** Renders the Tokenization and Embedding Demo with interactive BPE algorithm visualization. */
            function renderTokenizationEmbeddingDemoViz() {
                const container = d3.select("#tokenization-embedding-demo-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;
                
                // Enhanced responsive margins with device-specific optimization
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || bounds.width < 600;
                const isTablet = deviceType.type === 'tablet' || (bounds.width >= 600 && bounds.width < 1024);
                
                const margin = { 
                    top: isMobile ? 30 : isTablet ? 40 : 50, 
                    right: isMobile ? 20 : isTablet ? 30 : 40, 
                    bottom: isMobile ? 30 : isTablet ? 40 : 50, 
                    left: isMobile ? 20 : isTablet ? 30 : 40 
                };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Initialize demo state
                let currentMethod = 'word';
                let currentMode = 'tokens';
                let isAnimating = false;
                let animationId = null;
                let bpeSteps = [];
                let currentBpeStep = 0;

                // Sample text for demonstration
                const sampleText = "Hello world! How are you today?";
                
                // Tokenization methods
                const tokenizeWord = (text) => {
                    return text.split(/\s+/).filter(token => token.length > 0);
                };

                const tokenizeBPE = (text) => {
                    // Simplified BPE implementation for demonstration
                    const chars = text.split('');
                    let tokens = chars.map(char => char);
                    const merges = [];
                    
                    // Simulate BPE merges
                    const commonPairs = [
                        ['l', 'l'], ['o', ' '], ['w', 'o'], ['r', 'l'], ['d', '!'],
                        ['H', 'o'], ['a', 'r'], ['e', ' '], ['y', 'o'], ['u', ' '],
                        ['t', 'o'], ['d', 'a'], ['y', '?']
                    ];
                    
                    commonPairs.forEach((pair, index) => {
                        const newToken = pair.join('');
                        const newTokens = [];
                        let i = 0;
                        
                        while (i < tokens.length) {
                            if (i < tokens.length - 1 && tokens[i] === pair[0] && tokens[i + 1] === pair[1]) {
                                newTokens.push(newToken);
                                merges.push({
                                    step: index + 1,
                                    pair: pair,
                                    newToken: newToken,
                                    tokens: [...tokens]
                                });
                                i += 2;
                            } else {
                                newTokens.push(tokens[i]);
                                i++;
                            }
                        }
                        tokens = newTokens;
                    });
                    
                    return { tokens, merges };
                };

                const tokenizeSentencePiece = (text) => {
                    // Simplified SentencePiece-like tokenization
                    return text.split(/(?=[A-Z])|(?<=[a-z])(?=[A-Z])|(?<=[!?.,])\s*/).filter(token => token.length > 0);
                };

                const tokenizeSubword = (text) => {
                    // Simplified subword tokenization
                    return text.split(/(?<=[a-z])(?=[A-Z])|(?<=[!?.,])\s*|(?=\s)/).filter(token => token.length > 0);
                };

                // Generate embeddings for visualization
                const generateEmbeddings = (tokens) => {
                    return tokens.map((token, i) => ({
                        token: token,
                        x: Math.random() * (width - 100) + 50,
                        y: Math.random() * (height - 100) + 50,
                        vector: Array.from({ length: 8 }, () => Math.random() * 2 - 1)
                    }));
                };

                // Render token breakdown
                const renderTokens = (method) => {
                    svg.selectAll(".tokenization").remove();
                    
                    let tokens;
                    switch (method) {
                        case 'word':
                            tokens = tokenizeWord(sampleText);
                            break;
                        case 'bpe':
                            const bpeResult = tokenizeBPE(sampleText);
                            tokens = bpeResult.tokens;
                            bpeSteps = bpeResult.merges;
                            break;
                        case 'sentencepiece':
                            tokens = tokenizeSentencePiece(sampleText);
                            break;
                        case 'subword':
                            tokens = tokenizeSubword(sampleText);
                            break;
                        default:
                            tokens = tokenizeWord(sampleText);
                    }

                    const tokenWidth = Math.min(80, width / tokens.length - 10);
                    const tokenHeight = 40;
                    const startX = (width - (tokens.length * (tokenWidth + 10))) / 2;
                    const startY = height / 2 - tokenHeight / 2;

                    // Render tokens
                    const tokenGroups = svg.selectAll(".token-group")
                        .data(tokens)
                        .enter().append("g")
                        .attr("class", "token-group")
                        .attr("transform", (d, i) => `translate(${startX + i * (tokenWidth + 10)}, ${startY})`);

                    tokenGroups.append("rect")
                        .attr("width", tokenWidth)
                        .attr("height", tokenHeight)
                        .attr("fill", "var(--accent-orange)")
                        .attr("stroke", "white")
                        .attr("stroke-width", 2)
                        .attr("rx", 5);

                    tokenGroups.append("text")
                        .attr("x", tokenWidth / 2)
                        .attr("y", tokenHeight / 2)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .attr("font-size", isMobile ? "10px" : "12px")
                        .attr("font-weight", "bold")
                        .attr("fill", "white")
                        .text(d => d);

                    // Add method title
                    svg.selectAll(".method-title").remove();
                    svg.append("text")
                        .attr("class", "method-title")
                        .attr("x", width / 2)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text(`${method.toUpperCase()} Tokenization - ${tokens.length} tokens`);

                    // Add token count and efficiency metrics
                    svg.selectAll(".metrics").remove();
                    const metricsY = height - 30;
                    svg.append("text")
                        .attr("class", "metrics")
                        .attr("x", width / 2)
                        .attr("y", metricsY)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "10px" : "12px")
                        .attr("fill", "var(--text-secondary)")
                        .text(`Tokens: ${tokens.length} | Compression: ${((1 - tokens.length / sampleText.length) * 100).toFixed(1)}%`);
                };

                // Render BPE algorithm steps
                const renderBPEProcess = () => {
                    svg.selectAll(".bpe-process").remove();
                    
                    if (bpeSteps.length === 0) {
                        const bpeResult = tokenizeBPE(sampleText);
                        bpeSteps = bpeResult.merges;
                    }

                    const step = bpeSteps[currentBpeStep] || bpeSteps[bpeSteps.length - 1];
                    if (!step) return;

                    // Render current tokens
                    const tokens = step.tokens;
                    const tokenWidth = Math.min(60, width / tokens.length - 5);
                    const tokenHeight = 30;
                    const startX = (width - (tokens.length * (tokenWidth + 5))) / 2;
                    const startY = height / 2 - tokenHeight / 2;

                    const tokenGroups = svg.selectAll(".bpe-token-group")
                        .data(tokens)
                        .enter().append("g")
                        .attr("class", "bpe-token-group")
                        .attr("transform", (d, i) => `translate(${startX + i * (tokenWidth + 5)}, ${startY})`);

                    tokenGroups.append("rect")
                        .attr("width", tokenWidth)
                        .attr("height", tokenHeight)
                        .attr("fill", "var(--accent-cyan)")
                        .attr("stroke", "white")
                        .attr("stroke-width", 1)
                        .attr("rx", 3);

                    tokenGroups.append("text")
                        .attr("x", tokenWidth / 2)
                        .attr("y", tokenHeight / 2)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .attr("font-size", isMobile ? "9px" : "10px")
                        .attr("font-weight", "bold")
                        .attr("fill", "white")
                        .text(d => d);

                    // Add step information
                    svg.selectAll(".bpe-info").remove();
                    svg.append("text")
                        .attr("class", "bpe-info")
                        .attr("x", width / 2)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text(`BPE Step ${currentBpeStep + 1}/${bpeSteps.length}`);

                    if (step.pair) {
                        svg.append("text")
                            .attr("class", "bpe-info")
                            .attr("x", width / 2)
                            .attr("y", 50)
                            .attr("text-anchor", "middle")
                            .attr("font-size", isMobile ? "12px" : "14px")
                            .attr("fill", "var(--text-secondary)")
                            .text(`Merging: "${step.pair.join('')}" → "${step.newToken}"`);
                    }
                };

                // Render embedding space
                const renderEmbeddings = () => {
                    svg.selectAll(".embeddings").remove();
                    
                    const tokens = tokenizeWord(sampleText);
                    const embeddings = generateEmbeddings(tokens);

                    // Render embedding vectors as circles
                    const embeddingGroups = svg.selectAll(".embedding-group")
                        .data(embeddings)
                        .enter().append("g")
                        .attr("class", "embedding-group");

                    embeddingGroups.append("circle")
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y)
                        .attr("r", isMobile ? 20 : 25)
                        .attr("fill", "var(--accent-purple)")
                        .attr("stroke", "white")
                        .attr("stroke-width", 2)
                        .style("cursor", "pointer");

                    embeddingGroups.append("text")
                        .attr("x", d => d.x)
                        .attr("y", d => d.y)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .attr("font-size", isMobile ? "10px" : "12px")
                        .attr("font-weight", "bold")
                        .attr("fill", "white")
                        .text(d => d.token);

                    // Add title
                    svg.selectAll(".embedding-title").remove();
                    svg.append("text")
                        .attr("class", "embedding-title")
                        .attr("x", width / 2)
                        .attr("y", 30)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text("Embedding Space Visualization");
                };

                // Animation function for BPE
                const animateBPE = () => {
                    if (isAnimating) return;
                    isAnimating = true;
                    currentBpeStep = 0;
                    
                    const animate = () => {
                        renderBPEProcess();
                        currentBpeStep++;
                        
                        if (currentBpeStep < bpeSteps.length) {
                            animationId = setTimeout(animate, 1000);
                        } else {
                            isAnimating = false;
                        }
                    };
                    
                    animate();
                };

                // Render method comparison
                const renderComparison = () => {
                    svg.selectAll(".comparison").remove();
                    
                    const methods = ['word', 'bpe', 'sentencepiece', 'subword'];
                    const methodNames = ['Word', 'BPE', 'SentencePiece', 'Subword'];
                    const methodColors = ['var(--accent-orange)', 'var(--accent-cyan)', 'var(--accent-purple)', 'var(--accent-green)'];
                    
                    const comparisonWidth = width * 0.9;
                    const comparisonHeight = height * 0.7;
                    const offsetX = (width - comparisonWidth) / 2;
                    const offsetY = (height - comparisonHeight) / 2 + 30;
                    
                    const methodWidth = comparisonWidth / methods.length;
                    const methodHeight = comparisonHeight - 60;
                    
                    methods.forEach((method, methodIndex) => {
                        const methodX = offsetX + methodIndex * methodWidth;
                        const methodY = offsetY;
                        
                        // Get tokens for this method
                        let tokens;
                        switch (method) {
                            case 'word':
                                tokens = tokenizeWord(sampleText);
                                break;
                            case 'bpe':
                                tokens = tokenizeBPE(sampleText).tokens;
                                break;
                            case 'sentencepiece':
                                tokens = tokenizeSentencePiece(sampleText);
                                break;
                            case 'subword':
                                tokens = tokenizeSubword(sampleText);
                                break;
                        }
                        
                        // Add method title
                        svg.append("text")
                            .attr("class", "comparison")
                            .attr("x", methodX + methodWidth / 2)
                            .attr("y", methodY - 10)
                            .attr("text-anchor", "middle")
                            .attr("font-size", isMobile ? "10px" : "12px")
                            .attr("font-weight", "bold")
                            .attr("fill", "var(--text-primary)")
                            .text(methodNames[methodIndex]);
                        
                        // Add token count
                        svg.append("text")
                            .attr("class", "comparison")
                            .attr("x", methodX + methodWidth / 2)
                            .attr("y", methodY + 20)
                            .attr("text-anchor", "middle")
                            .attr("font-size", isMobile ? "9px" : "10px")
                            .attr("fill", "var(--text-secondary)")
                            .text(`${tokens.length} tokens`);
                        
                        // Render tokens
                        const tokenWidth = Math.min(60, methodWidth / tokens.length - 2);
                        const tokenHeight = 25;
                        const tokenStartX = methodX + (methodWidth - (tokens.length * (tokenWidth + 2))) / 2;
                        const tokenStartY = methodY + 40;
                        
                        tokens.forEach((token, tokenIndex) => {
                            const tokenX = tokenStartX + tokenIndex * (tokenWidth + 2);
                            const tokenY = tokenStartY;
                            
                            svg.append("rect")
                                .attr("class", "comparison")
                                .attr("x", tokenX)
                                .attr("y", tokenY)
                                .attr("width", tokenWidth)
                                .attr("height", tokenHeight)
                                .attr("fill", methodColors[methodIndex])
                                .attr("stroke", "white")
                                .attr("stroke-width", 1)
                                .attr("rx", 3);
                            
                            svg.append("text")
                                .attr("class", "comparison")
                                .attr("x", tokenX + tokenWidth / 2)
                                .attr("y", tokenY + tokenHeight / 2)
                                .attr("text-anchor", "middle")
                                .attr("dominant-baseline", "middle")
                                .attr("font-size", isMobile ? "8px" : "9px")
                                .attr("font-weight", "bold")
                                .attr("fill", "white")
                                .text(token);
                        });
                        
                        // Add efficiency metrics
                        const compression = ((1 - tokens.length / sampleText.length) * 100).toFixed(1);
                        svg.append("text")
                            .attr("class", "comparison")
                            .attr("x", methodX + methodWidth / 2)
                            .attr("y", methodY + methodHeight - 10)
                            .attr("text-anchor", "middle")
                            .attr("font-size", isMobile ? "8px" : "9px")
                            .attr("fill", "var(--text-secondary)")
                            .text(`Compression: ${compression}%`);
                    });
                    
                    // Add main title
                    svg.selectAll(".comparison-title").remove();
                    svg.append("text")
                        .attr("class", "comparison-title")
                        .attr("x", width / 2)
                        .attr("y", 20)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text("Tokenization Method Comparison");
                };

                // Event listeners
                d3.select("#tokenization-method-selector").on("change", function() {
                    currentMethod = this.value;
                    if (currentMode === 'tokens') {
                        renderTokens(currentMethod);
                    }
                });

                d3.select("#tokenization-viz-mode").on("change", function() {
                    currentMode = this.value;
                    switch (currentMode) {
                        case 'tokens':
                            renderTokens(currentMethod);
                            break;
                        case 'bpe-process':
                            renderBPEProcess();
                            break;
                        case 'embeddings':
                            renderEmbeddings();
                            break;
                        case 'comparison':
                            renderComparison();
                            break;
                    }
                });

                d3.select("#animate-tokenization").on("click", animateBPE);

                d3.select("#reset-tokenization").on("click", function() {
                    if (animationId) {
                        clearTimeout(animationId);
                        isAnimating = false;
                    }
                    currentBpeStep = 0;
                    currentMethod = 'word';
                    currentMode = 'tokens';
                    d3.select("#tokenization-method-selector").property("value", "word");
                    d3.select("#tokenization-viz-mode").property("value", "tokens");
                    renderTokens('word');
                });

                d3.select("#export-tokenization").on("click", function() {
                    const data = {
                        text: sampleText,
                        methods: {
                            word: tokenizeWord(sampleText),
                            bpe: tokenizeBPE(sampleText).tokens,
                            sentencepiece: tokenizeSentencePiece(sampleText),
                            subword: tokenizeSubword(sampleText)
                        },
                        currentMethod: currentMethod,
                        currentMode: currentMode
                    };
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'tokenization_data.json';
                    a.click();
                    URL.revokeObjectURL(url);
                });

                // Initial render
                renderTokens('word');
            }

            /** Renders the Attention Mechanism Visualization Demo with interactive multi-head attention exploration. */
            function renderAttentionMechanismDemoViz() {
                const container = d3.select("#attention-mechanism-demo-viz");
                container.selectAll("*").remove();
                const bounds = container.node().getBoundingClientRect();
                if (bounds.width <= 0) return;
                
                // Enhanced responsive margins with device-specific optimization
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || bounds.width < 600;
                const isTablet = deviceType.type === 'tablet' || (bounds.width >= 600 && bounds.width < 1024);
                
                const margin = { 
                    top: isMobile ? 30 : isTablet ? 40 : 50, 
                    right: isMobile ? 20 : isTablet ? 30 : 40, 
                    bottom: isMobile ? 30 : isTablet ? 40 : 50, 
                    left: isMobile ? 20 : isTablet ? 30 : 40 
                };
                const width = bounds.width - margin.left - margin.right;
                const height = bounds.height - margin.top - margin.bottom;
                const svg = container.append("svg").attr("width", bounds.width).attr("height", bounds.height).append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

                // Initialize demo state
                let currentHead = 0;
                let currentMode = 'heatmap';
                let isAnimating = false;
                let animationId = null;

                // Sample attention data for demonstration
                const sampleText = "The quick brown fox jumps over the lazy dog";
                const tokens = sampleText.split(' ');
                const numTokens = tokens.length;
                const numHeads = 4;

                // Generate realistic attention weights for demonstration
                const generateAttentionWeights = (headIndex) => {
                    const weights = [];
                    for (let i = 0; i < numTokens; i++) {
                        const row = [];
                        for (let j = 0; j < numTokens; j++) {
                            let weight;
                            switch (headIndex) {
                                case 0: // Syntactic head - focuses on adjacent words
                                    weight = Math.exp(-Math.abs(i - j) * 0.5) + Math.random() * 0.1;
                                    break;
                                case 1: // Semantic head - focuses on similar words
                                    weight = Math.random() * 0.8 + 0.1;
                                    break;
                                case 2: // Positional head - focuses on specific positions
                                    weight = Math.exp(-Math.abs(i - j) * 0.3) + Math.random() * 0.2;
                                    break;
                                case 3: // Long-range head - focuses on distant words
                                    weight = Math.random() * 0.6 + 0.2;
                                    break;
                                default:
                                    weight = Math.random();
                            }
                            row.push(weight);
                        }
                        // Normalize row to sum to 1
                        const sum = row.reduce((a, b) => a + b, 0);
                        for (let k = 0; k < row.length; k++) {
                            row[k] = row[k] / sum;
                        }
                        weights.push(row);
                    }
                    return weights;
                };

                const attentionData = Array.from({ length: numHeads }, (_, i) => generateAttentionWeights(i));

                // Color scale for attention weights
                const colorScale = d3.scaleSequential(d3.interpolateBlues)
                    .domain([0, 1]);

                // Render attention heatmap
                const renderHeatmap = (headIndex) => {
                    svg.selectAll(".heatmap").remove();
                    
                    const cellSize = Math.min(width / numTokens, height / numTokens, 40);
                    const heatmapWidth = cellSize * numTokens;
                    const heatmapHeight = cellSize * numTokens;
                    const offsetX = (width - heatmapWidth) / 2;
                    const offsetY = (height - heatmapHeight) / 2;

                    // Create heatmap cells
                    const cells = svg.selectAll(".heatmap-cell")
                        .data(attentionData[headIndex].flat().map((d, i) => ({
                            value: d,
                            row: Math.floor(i / numTokens),
                            col: i % numTokens
                        })))
                        .enter().append("rect")
                        .attr("class", "heatmap-cell")
                        .attr("x", d => offsetX + d.col * cellSize)
                        .attr("y", d => offsetY + d.row * cellSize)
                        .attr("width", cellSize)
                        .attr("height", cellSize)
                        .attr("fill", d => colorScale(d.value))
                        .attr("stroke", "white")
                        .attr("stroke-width", 0.5)
                        .style("cursor", "pointer")
                        .on("mouseover", function(event, d) {
                            const tooltip = d3.select("body").append("div")
                                .attr("class", "attention-tooltip")
                                .style("position", "absolute")
                                .style("background", "rgba(0, 0, 0, 0.8)")
                                .style("color", "white")
                                .style("padding", "8px")
                                .style("border-radius", "4px")
                                .style("font-size", "12px")
                                .style("pointer-events", "none")
                                .style("z-index", "1000");
                            
                            tooltip.html(`
                                <strong>${tokens[d.row]} → ${tokens[d.col]}</strong><br>
                                Attention Weight: ${(d.value * 100).toFixed(1)}%<br>
                                Head: ${headIndex + 1}
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 10) + "px");
                        })
                        .on("mouseout", function() {
                            d3.selectAll(".attention-tooltip").remove();
                        });

                    // Add token labels
                    svg.selectAll(".token-label").remove();
                    
                    // X-axis labels (columns)
                    svg.selectAll(".token-label-x")
                        .data(tokens)
                        .enter().append("text")
                        .attr("class", "token-label token-label-x")
                        .attr("x", (d, i) => offsetX + i * cellSize + cellSize / 2)
                        .attr("y", offsetY - 5)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "10px" : "12px")
                        .attr("fill", "var(--text-primary)")
                        .text(d => d);

                    // Y-axis labels (rows)
                    svg.selectAll(".token-label-y")
                        .data(tokens)
                        .enter().append("text")
                        .attr("class", "token-label token-label-y")
                        .attr("x", offsetX - 5)
                        .attr("y", (d, i) => offsetY + i * cellSize + cellSize / 2)
                        .attr("text-anchor", "end")
                        .attr("dominant-baseline", "middle")
                        .attr("font-size", isMobile ? "10px" : "12px")
                        .attr("fill", "var(--text-primary)")
                        .text(d => d);

                    // Add title
                    svg.selectAll(".heatmap-title").remove();
                    svg.append("text")
                        .attr("class", "heatmap-title")
                        .attr("x", width / 2)
                        .attr("y", 20)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text(`Attention Head ${headIndex + 1} - ${['Syntactic', 'Semantic', 'Positional', 'Long-range'][headIndex]}`);
                };

                // Render attention network
                const renderNetwork = (headIndex) => {
                    svg.selectAll(".network").remove();
                    
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const radius = Math.min(width, height) * 0.3;
                    
                    // Position tokens in a circle
                    const tokenPositions = tokens.map((token, i) => {
                        const angle = (i / tokens.length) * 2 * Math.PI - Math.PI / 2;
                        return {
                            token: token,
                            x: centerX + radius * Math.cos(angle),
                            y: centerY + radius * Math.sin(angle),
                            index: i
                        };
                    });

                    // Draw attention connections
                    const connections = [];
                    for (let i = 0; i < numTokens; i++) {
                        for (let j = 0; j < numTokens; j++) {
                            if (i !== j && attentionData[headIndex][i][j] > 0.1) {
                                connections.push({
                                    source: tokenPositions[i],
                                    target: tokenPositions[j],
                                    weight: attentionData[headIndex][i][j]
                                });
                            }
                        }
                    }

                    // Draw connections
                    svg.selectAll(".connection")
                        .data(connections)
                        .enter().append("line")
                        .attr("class", "connection")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y)
                        .attr("stroke", "var(--accent-cyan)")
                        .attr("stroke-width", d => d.weight * 5)
                        .attr("opacity", d => d.weight * 0.8);

                    // Draw tokens
                    svg.selectAll(".token-node")
                        .data(tokenPositions)
                        .enter().append("circle")
                        .attr("class", "token-node")
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y)
                        .attr("r", isMobile ? 15 : 20)
                        .attr("fill", "var(--accent-purple)")
                        .attr("stroke", "white")
                        .attr("stroke-width", 2)
                        .style("cursor", "pointer");

                    // Add token labels
                    svg.selectAll(".token-text")
                        .data(tokenPositions)
                        .enter().append("text")
                        .attr("class", "token-text")
                        .attr("x", d => d.x)
                        .attr("y", d => d.y)
                        .attr("text-anchor", "middle")
                        .attr("dominant-baseline", "middle")
                        .attr("font-size", isMobile ? "10px" : "12px")
                        .attr("font-weight", "bold")
                        .attr("fill", "white")
                        .text(d => d.token);

                    // Add title
                    svg.selectAll(".network-title").remove();
                    svg.append("text")
                        .attr("class", "network-title")
                        .attr("x", width / 2)
                        .attr("y", 20)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text(`Attention Network - Head ${headIndex + 1}`);
                };

                // Animation function
                const animateAttention = () => {
                    if (isAnimating) return;
                    isAnimating = true;
                    
                    let frame = 0;
                    const totalFrames = 60;
                    
                    const animate = () => {
                        const progress = frame / totalFrames;
                        const currentHead = Math.floor(progress * numHeads);
                        
                        if (currentMode === 'heatmap') {
                            renderHeatmap(currentHead);
                        } else if (currentMode === 'network') {
                            renderNetwork(currentHead);
                        }
                        
                        frame++;
                        if (frame < totalFrames) {
                            animationId = requestAnimationFrame(animate);
                        } else {
                            isAnimating = false;
                        }
                    };
                    
                    animate();
                };

                // Render attention flow visualization
                const renderFlow = (headIndex) => {
                    svg.selectAll(".flow").remove();
                    
                    const flowWidth = width * 0.8;
                    const flowHeight = height * 0.6;
                    const offsetX = (width - flowWidth) / 2;
                    const offsetY = (height - flowHeight) / 2 + 30;
                    
                    const tokenWidth = flowWidth / numTokens;
                    const tokenHeight = 40;
                    
                    // Create flow visualization
                    for (let i = 0; i < numTokens; i++) {
                        for (let j = 0; j < numTokens; j++) {
                            if (i !== j && attentionData[headIndex][i][j] > 0.05) {
                                const weight = attentionData[headIndex][i][j];
                                const opacity = weight * 0.8;
                                const strokeWidth = weight * 8;
                                
                                // Create curved path for attention flow
                                const x1 = offsetX + i * tokenWidth + tokenWidth / 2;
                                const y1 = offsetY + tokenHeight / 2;
                                const x2 = offsetX + j * tokenWidth + tokenWidth / 2;
                                const y2 = offsetY + tokenHeight / 2;
                                
                                const controlY = offsetY - 20 - (weight * 30);
                                
                                const path = `M ${x1} ${y1} Q ${(x1 + x2) / 2} ${controlY} ${x2} ${y2}`;
                                
                                svg.append("path")
                                    .attr("class", "flow")
                                    .attr("d", path)
                                    .attr("stroke", "var(--accent-cyan)")
                                    .attr("stroke-width", strokeWidth)
                                    .attr("opacity", opacity)
                                    .attr("fill", "none")
                                    .style("cursor", "pointer")
                                    .on("mouseover", function(event) {
                                        const tooltip = d3.select("body").append("div")
                                            .attr("class", "attention-tooltip")
                                            .style("position", "absolute")
                                            .style("background", "rgba(0, 0, 0, 0.8)")
                                            .style("color", "white")
                                            .style("padding", "8px")
                                            .style("border-radius", "4px")
                                            .style("font-size", "12px")
                                            .style("pointer-events", "none")
                                            .style("z-index", "1000");
                                        
                                        tooltip.html(`
                                            <strong>${tokens[i]} → ${tokens[j]}</strong><br>
                                            Attention Weight: ${(weight * 100).toFixed(1)}%<br>
                                            Head: ${headIndex + 1}
                                        `)
                                        .style("left", (event.pageX + 10) + "px")
                                        .style("top", (event.pageY - 10) + "px");
                                    })
                                    .on("mouseout", function() {
                                        d3.selectAll(".attention-tooltip").remove();
                                    });
                            }
                        }
                    }
                    
                    // Add token boxes
                    tokens.forEach((token, i) => {
                        const x = offsetX + i * tokenWidth;
                        const y = offsetY;
                        
                        svg.append("rect")
                            .attr("class", "flow")
                            .attr("x", x)
                            .attr("y", y)
                            .attr("width", tokenWidth - 2)
                            .attr("height", tokenHeight)
                            .attr("fill", "var(--accent-purple)")
                            .attr("stroke", "white")
                            .attr("stroke-width", 1)
                            .attr("rx", 4);
                        
                        svg.append("text")
                            .attr("class", "flow")
                            .attr("x", x + tokenWidth / 2)
                            .attr("y", y + tokenHeight / 2)
                            .attr("text-anchor", "middle")
                            .attr("dominant-baseline", "middle")
                            .attr("font-size", isMobile ? "10px" : "12px")
                            .attr("font-weight", "bold")
                            .attr("fill", "white")
                            .text(token);
                    });
                    
                    // Add title
                    svg.selectAll(".flow-title").remove();
                    svg.append("text")
                        .attr("class", "flow-title")
                        .attr("x", width / 2)
                        .attr("y", 20)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text(`Attention Flow - Head ${headIndex + 1}`);
                };

                // Render multi-head comparison
                const renderComparison = () => {
                    svg.selectAll(".comparison").remove();
                    
                    const comparisonWidth = width * 0.9;
                    const comparisonHeight = height * 0.7;
                    const offsetX = (width - comparisonWidth) / 2;
                    const offsetY = (height - comparisonHeight) / 2 + 30;
                    
                    const headWidth = comparisonWidth / numHeads;
                    const cellSize = Math.min(headWidth / numTokens, comparisonHeight / numTokens, 25);
                    
                    numHeads.forEach((_, headIndex) => {
                        const headX = offsetX + headIndex * headWidth;
                        
                        // Add head title
                        svg.append("text")
                            .attr("class", "comparison")
                            .attr("x", headX + headWidth / 2)
                            .attr("y", offsetY - 10)
                            .attr("text-anchor", "middle")
                            .attr("font-size", isMobile ? "10px" : "12px")
                            .attr("font-weight", "bold")
                            .attr("fill", "var(--text-primary)")
                            .text(`Head ${headIndex + 1}`);
                        
                        // Create mini heatmap for each head
                        for (let i = 0; i < numTokens; i++) {
                            for (let j = 0; j < numTokens; j++) {
                                const weight = attentionData[headIndex][i][j];
                                const x = headX + j * cellSize;
                                const y = offsetY + i * cellSize;
                                
                                svg.append("rect")
                                    .attr("class", "comparison")
                                    .attr("x", x)
                                    .attr("y", y)
                                    .attr("width", cellSize - 1)
                                    .attr("height", cellSize - 1)
                                    .attr("fill", colorScale(weight))
                                    .attr("stroke", "white")
                                    .attr("stroke-width", 0.5)
                                    .style("cursor", "pointer")
                                    .on("mouseover", function(event) {
                                        const tooltip = d3.select("body").append("div")
                                            .attr("class", "attention-tooltip")
                                            .style("position", "absolute")
                                            .style("background", "rgba(0, 0, 0, 0.8)")
                                            .style("color", "white")
                                            .style("padding", "8px")
                                            .style("border-radius", "4px")
                                            .style("font-size", "12px")
                                            .style("pointer-events", "none")
                                            .style("z-index", "1000");
                                        
                                        tooltip.html(`
                                            <strong>${tokens[i]} → ${tokens[j]}</strong><br>
                                            Attention Weight: ${(weight * 100).toFixed(1)}%<br>
                                            Head: ${headIndex + 1}
                                        `)
                                        .style("left", (event.pageX + 10) + "px")
                                        .style("top", (event.pageY - 10) + "px");
                                    })
                                    .on("mouseout", function() {
                                        d3.selectAll(".attention-tooltip").remove();
                                    });
                            }
                        }
                    });
                    
                    // Add title
                    svg.selectAll(".comparison-title").remove();
                    svg.append("text")
                        .attr("class", "comparison-title")
                        .attr("x", width / 2)
                        .attr("y", 20)
                        .attr("text-anchor", "middle")
                        .attr("font-size", isMobile ? "14px" : "16px")
                        .attr("font-weight", "bold")
                        .attr("fill", "var(--text-primary)")
                        .text("Multi-Head Attention Comparison");
                };

                // Event listeners
                d3.select("#attention-head-selector").on("change", function() {
                    const value = this.value;
                    if (value === "all") {
                        if (currentMode === 'comparison') {
                            renderComparison();
                        } else {
                            renderHeatmap(0); // Default to first head for now
                        }
                    } else {
                        currentHead = parseInt(value);
                        if (currentMode === 'heatmap') {
                            renderHeatmap(currentHead);
                        } else if (currentMode === 'network') {
                            renderNetwork(currentHead);
                        } else if (currentMode === 'flow') {
                            renderFlow(currentHead);
                        }
                    }
                });

                d3.select("#viz-mode-selector").on("change", function() {
                    currentMode = this.value;
                    if (currentMode === 'heatmap') {
                        renderHeatmap(currentHead);
                    } else if (currentMode === 'network') {
                        renderNetwork(currentHead);
                    } else if (currentMode === 'flow') {
                        renderFlow(currentHead);
                    } else if (currentMode === 'comparison') {
                        renderComparison();
                    }
                });

                d3.select("#animate-attention").on("click", animateAttention);

                d3.select("#reset-attention").on("click", function() {
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        isAnimating = false;
                    }
                    currentHead = 0;
                    currentMode = 'heatmap';
                    d3.select("#attention-head-selector").property("value", "0");
                    d3.select("#viz-mode-selector").property("value", "heatmap");
                    renderHeatmap(0);
                });

                d3.select("#export-attention").on("click", function() {
                    const data = {
                        tokens: tokens,
                        attentionWeights: attentionData,
                        currentHead: currentHead,
                        currentMode: currentMode
                    };
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'attention_data.json';
                    a.click();
                    URL.revokeObjectURL(url);
                });

                // Initial render
                renderHeatmap(0);
            }

            /** Renders the Adaptation Speed Advantage visualization with competitive positioning analysis. */
            function renderAdaptationSpeedAdvantageViz() {
                const container = d3.select("#adaptation-speed-advantage-viz");
                container.selectAll("*").remove();

                const bounds = container.node().getBoundingClientRect();
                const width = bounds.width;
                const height = bounds.height;
                
                // Enhanced responsive margins with device-specific optimization
                const deviceType = detectDeviceType();
                const isMobile = deviceType.type === 'mobile' || width < 600;
                const isTablet = deviceType.type === 'tablet' || (width >= 600 && width < 1024);
                
                const margin = { 
                    top: isMobile ? 15 : isTablet ? 25 : 30, 
                    right: isMobile ? 15 : isTablet ? 25 : 30, 
                    bottom: isMobile ? 15 : isTablet ? 25 : 30, 
                    left: isMobile ? 15 : isTablet ? 25 : 30 
                };
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;

                const svg = container.append("svg")
                    .attr("width", width)
                    .attr("height", height);

                const g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Calculate responsive grid layout for adaptation speed scenarios with optimized spacing
                const cardWidth = isMobile ? innerWidth * 0.9 : isTablet ? innerWidth * 0.42 : innerWidth * 0.42;
                const cardHeight = isMobile ? innerHeight * 0.22 : isTablet ? innerHeight * 0.42 : innerHeight * 0.42;
                const cardSpacing = isMobile ? 12 : isTablet ? 18 : 24;
                const gridPadding = isMobile ? 8 : isTablet ? 12 : 16;
                
                // Define adaptation speed scenarios with optimized responsive positioning
                const adaptationScenarios = {
                    "Traditional Monolithic": {
                        position: { 
                            x: isMobile ? gridPadding : gridPadding, 
                            y: isMobile ? gridPadding : gridPadding 
                        },
                        color: "#e74c3c",
                        adaptationTime: 45, // days
                        complexity: 85,
                        marketResponse: 25,
                        competitiveAdvantage: 15,
                        characteristics: [
                            "Rigid Architecture",
                            "Manual Deployment",
                            "Sequential Development",
                            "Limited Automation"
                        ]
                    },
                    "Microservices Architecture": {
                        position: { 
                            x: isMobile ? gridPadding : gridPadding + cardWidth + cardSpacing, 
                            y: isMobile ? gridPadding + cardHeight + cardSpacing : gridPadding 
                        },
                        color: "#f39c12",
                        adaptationTime: 20,
                        complexity: 60,
                        marketResponse: 55,
                        competitiveAdvantage: 40,
                        characteristics: [
                            "Modular Components",
                            "Independent Deployment",
                            "Parallel Development",
                            "Basic Automation"
                        ]
                    },
                    "Agentic AI Systems": {
                        position: { 
                            x: isMobile ? gridPadding : gridPadding, 
                            y: isMobile ? gridPadding + (cardHeight + cardSpacing) * 2 : gridPadding + cardHeight + cardSpacing 
                        },
                        color: "#27ae60",
                        adaptationTime: 8,
                        complexity: 40,
                        marketResponse: 85,
                        competitiveAdvantage: 75,
                        characteristics: [
                            "Intelligent Orchestration",
                            "Autonomous Adaptation",
                            "Self-Optimizing Systems",
                            "Predictive Analytics"
                        ]
                    },
                    "Fiscal 2025 Stack": {
                        position: { 
                            x: isMobile ? gridPadding : gridPadding + cardWidth + cardSpacing, 
                            y: isMobile ? gridPadding + (cardHeight + cardSpacing) * 3 : gridPadding + cardHeight + cardSpacing 
                        },
                        color: "#3498db",
                        adaptationTime: 3,
                        complexity: 25,
                        marketResponse: 95,
                        competitiveAdvantage: 90,
                        characteristics: [
                            "AI-Driven Development",
                            "Real-time Adaptation",
                            "Collaborative AI Agents",
                            "Predictive Market Analysis"
                        ]
                    }
                };

                // Create scenario cards
                Object.entries(adaptationScenarios).forEach(([scenarioName, scenarioData]) => {
                    const scenarioGroup = g.append("g").attr("class", `scenario-${scenarioName.toLowerCase().replace(/\s+/g, '-')}`);
                    
                    // Main scenario rectangle with responsive sizing
                    const scenarioRect = scenarioGroup.append("rect")
                        .attr("x", scenarioData.position.x)
                        .attr("y", scenarioData.position.y)
                        .attr("width", cardWidth)
                        .attr("height", cardHeight)
                        .attr("fill", scenarioData.color)
                        .attr("opacity", 0.08)
                        .attr("stroke", scenarioData.color)
                        .attr("stroke-width", isMobile ? 1.5 : 2)
                        .attr("rx", isMobile ? 6 : 8);

                    // Scenario title with responsive positioning and sizing
                    const titleFontSize = isMobile ? "11px" : isTablet ? "12px" : "14px";
                    const titlePadding = isMobile ? 8 : 10;
                    scenarioGroup.append("text")
                        .attr("x", scenarioData.position.x + titlePadding)
                        .attr("y", scenarioData.position.y + (isMobile ? 15 : 20))
                        .attr("font-size", titleFontSize)
                        .attr("font-weight", "bold")
                        .attr("fill", scenarioData.color)
                        .text(scenarioName);

                    // Key metrics
                    const metrics = [
                        { label: "Adaptation Time", value: `${scenarioData.adaptationTime} days`, color: scenarioData.color },
                        { label: "Market Response", value: `${scenarioData.marketResponse}%`, color: scenarioData.color },
                        { label: "Competitive Advantage", value: `${scenarioData.competitiveAdvantage}%`, color: scenarioData.color }
                    ];

                    // Responsive metrics positioning and sizing with improved alignment
                    const metricsFontSize = isMobile ? "9px" : isTablet ? "10px" : "12px";
                    const metricsLineHeight = isMobile ? 16 : isTablet ? 18 : 22;
                    const metricsStartY = isMobile ? 32 : 42;
                    const metricsLabelX = scenarioData.position.x + (isMobile ? 14 : 18);
                    const metricsValueX = scenarioData.position.x + (isMobile ? 85 : 110);
                    
                    metrics.forEach((metric, index) => {
                        scenarioGroup.append("text")
                            .attr("x", metricsLabelX)
                            .attr("y", scenarioData.position.y + metricsStartY + (index * metricsLineHeight))
                            .attr("font-size", metricsFontSize)
                            .attr("fill", "#333")
                            .text(`${metric.label}: `);

                        scenarioGroup.append("text")
                            .attr("x", metricsValueX)
                            .attr("y", scenarioData.position.y + metricsStartY + (index * metricsLineHeight))
                            .attr("font-size", metricsFontSize)
                            .attr("font-weight", "bold")
                            .attr("fill", metric.color)
                            .text(metric.value);
                    });

                    // Responsive characteristics list positioning and sizing with improved spacing
                    const characteristicsFontSize = isMobile ? "8px" : isTablet ? "9px" : "10px";
                    const characteristicsLineHeight = isMobile ? 12 : isTablet ? 13 : 14;
                    const characteristicsStartY = isMobile ? 85 : isTablet ? 105 : 125;
                    const characteristicsLabelX = scenarioData.position.x + (isMobile ? 14 : 18);
                    const characteristicsItemX = scenarioData.position.x + (isMobile ? 18 : 22);
                    
                    scenarioGroup.append("text")
                        .attr("x", characteristicsLabelX)
                        .attr("y", scenarioData.position.y + characteristicsStartY)
                        .attr("font-size", isMobile ? "9px" : isTablet ? "10px" : "11px")
                        .attr("font-weight", "bold")
                        .attr("fill", "#333")
                        .text("Key Characteristics:");

                    scenarioData.characteristics.forEach((characteristic, index) => {
                        scenarioGroup.append("text")
                            .attr("x", characteristicsItemX)
                            .attr("y", scenarioData.position.y + characteristicsStartY + 15 + (index * characteristicsLineHeight))
                            .attr("font-size", characteristicsFontSize)
                            .attr("fill", "#666")
                            .text(`• ${characteristic}`);
                    });

                    // Add interactive tooltips
                    scenarioRect.on("mouseover", function(event) {
                        const tooltipContent = `
                            <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.15); max-width: 300px;">
                                <h4 style="margin: 0 0 10px 0; color: ${scenarioData.color};">${scenarioName}</h4>
                                <div style="margin-bottom: 10px;">
                                    <p style="margin: 0 0 5px 0; font-weight: bold;">Performance Metrics:</p>
                                    <ul style="margin: 0; padding-left: 15px;">
                                        <li>Adaptation Time: <strong>${scenarioData.adaptationTime} days</strong></li>
                                        <li>Market Response: <strong>${scenarioData.marketResponse}%</strong></li>
                                        <li>Competitive Advantage: <strong>${scenarioData.competitiveAdvantage}%</strong></li>
                                    </ul>
                                </div>
                                <div>
                                    <p style="margin: 0 0 5px 0; font-weight: bold;">Key Characteristics:</p>
                                    <ul style="margin: 0; padding-left: 15px;">
                                        ${scenarioData.characteristics.map(char => `<li>${char}</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                        `;
                        showTooltip(event, tooltipContent);
                    })
                    .on("mouseout", function() {
                        tooltip.style("opacity", 0);
                    });
                });

                // Add competitive advantage comparison chart
                const comparisonGroup = g.append("g").attr("class", "competitive-comparison");
                
                const comparisonData = [
                    { name: "Traditional Monolithic", advantage: 15, time: 45 },
                    { name: "Microservices", advantage: 40, time: 20 },
                    { name: "Agentic AI", advantage: 75, time: 8 },
                    { name: "Fiscal 2025", advantage: 90, time: 3 }
                ];

                // Create advantage vs time scatter plot with optimized positioning
                const chartWidth = isMobile ? innerWidth * 0.8 : innerWidth * 0.4;
                const chartHeight = isMobile ? innerHeight * 0.25 : innerHeight * 0.35;
                const chartX = isMobile ? innerWidth * 0.1 : innerWidth * 0.55;
                const chartY = isMobile ? innerHeight * 0.7 : innerHeight * 0.05;
                
                const xScale = d3.scaleLinear()
                    .domain([0, 50])
                    .range([chartX + 20, chartX + chartWidth - 20]);

                const yScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([chartY + chartHeight - 20, chartY + 20]);

                // Add axes with optimized positioning
                comparisonGroup.append("line")
                    .attr("x1", chartX + 20)
                    .attr("x2", chartX + chartWidth - 20)
                    .attr("y1", chartY + chartHeight - 20)
                    .attr("y2", chartY + chartHeight - 20)
                    .attr("stroke", "#333")
                    .attr("stroke-width", 2);

                comparisonGroup.append("line")
                    .attr("x1", chartX + 20)
                    .attr("x2", chartX + 20)
                    .attr("y1", chartY + 20)
                    .attr("y2", chartY + chartHeight - 20)
                    .attr("stroke", "#333")
                    .attr("stroke-width", 2);

                // Add axis labels with responsive positioning
                comparisonGroup.append("text")
                    .attr("x", chartX + chartWidth / 2)
                    .attr("y", chartY + chartHeight - 5)
                    .attr("text-anchor", "middle")
                    .attr("font-size", isMobile ? "10px" : "12px")
                    .attr("fill", "#333")
                    .text("Adaptation Time (days)");

                comparisonGroup.append("text")
                    .attr("x", chartX + 10)
                    .attr("y", chartY + chartHeight / 2)
                    .attr("text-anchor", "middle")
                    .attr("font-size", isMobile ? "10px" : "12px")
                    .attr("fill", "#333")
                    .attr("transform", `rotate(-90, ${chartX + 10}, ${chartY + chartHeight / 2})`)
                    .text("Competitive Advantage (%)");

                // Add data points
                comparisonData.forEach((d, i) => {
                    const color = Object.values(adaptationScenarios)[i].color;
                    
                    comparisonGroup.append("circle")
                        .attr("cx", xScale(d.time))
                        .attr("cy", yScale(d.advantage))
                        .attr("r", 8)
                        .attr("fill", color)
                        .attr("opacity", 0.8);

                    comparisonGroup.append("text")
                        .attr("x", xScale(d.time))
                        .attr("y", yScale(d.advantage) - 15)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .attr("fill", color)
                        .attr("font-weight", "bold")
                        .text(d.name.split(' ')[0]);
                });

                // Add trend line
                const trendLine = d3.line()
                    .x(d => xScale(d.time))
                    .y(d => yScale(d.advantage))
                    .curve(d3.curveMonotoneX);

                comparisonGroup.append("path")
                    .datum(comparisonData)
                    .attr("d", trendLine)
                    .attr("fill", "none")
                    .attr("stroke", "#4a90e2")
                    .attr("stroke-width", 2)
                    .attr("stroke-dasharray", "5,5");

                // Add title for comparison
                comparisonGroup.append("text")
                    .attr("x", 200)
                    .attr("y", 430)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("font-weight", "bold")
                    .attr("fill", "#333")
                    .text("Competitive Advantage vs Adaptation Time");

                // Add responsive behavior
                function handleAdaptationSpeedResize() {
                    const newBounds = container.node().getBoundingClientRect();
                    const newWidth = newBounds.width;
                    const newHeight = newBounds.height;
                    
                    if (newWidth !== width || newHeight !== height) {
                        renderAdaptationSpeedAdvantageViz();
                    }
                }

                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(handleAdaptationSpeedResize, 250);
                });
            }

            function renderAllEmergingVisualizations() {
                renderLLMAppStackViz();
                renderPromptInjectionViz();
                renderCloudNativeViz();
                renderMultimodalDataViz();
                renderLLMOpsObservabilityViz();
                renderLLMEvalViz();
                renderCICDIaCViz();
                renderAgenticFrameworksViz();
                renderFineTuningTechniquesViz();
                renderAdvancedRAGPipelinesViz();
                renderCostPerformanceCalculatorViz();
                renderFrontendIntegrationViz();
                renderBiasInterpretabilityViz();
                renderMCPProtocolViz();
                renderA2AProtocolViz();
                renderAGUIProtocolViz();
                renderAttentionMechanismDemoViz();
                renderTokenizationEmbeddingDemoViz();
            }

            // Initial render for advanced visualizations and enhanced resize handler
            renderAllAdvancedVisualizations();
            renderAllEmergingVisualizations();
            
            // Advanced responsive resize handler with intelligent breakpoint management
            let resizeTimer;
            let lastWidth = window.innerWidth;
            let lastHeight = window.innerHeight;
            let currentBreakpoint = 'desktop';
            
            // Define breakpoint thresholds
            const breakpoints = {
                'mobile-portrait': 479,
                'mobile-landscape': 639,
                'tablet-portrait': 767,
                'tablet-landscape': 1023,
                'laptop': 1279,
                'desktop': 1439,
                'large-desktop': 1919,
                'ultra-wide': Infinity
            };
            
            function getCurrentBreakpoint(width) {
                for (const [name, threshold] of Object.entries(breakpoints)) {
                    if (width <= threshold) {
                        return name;
                    }
                }
                return 'ultra-wide';
            }
            
            function updateResponsiveVariables(width, height) {
                const newBreakpoint = getCurrentBreakpoint(width);
                
                // Only update if breakpoint changed or significant size change
                if (newBreakpoint !== currentBreakpoint || Math.abs(width - lastWidth) > 50) {
                    currentBreakpoint = newBreakpoint;
                    
                    // Update CSS custom properties based on breakpoint
                    switch (newBreakpoint) {
                        case 'mobile-portrait':
                            document.documentElement.style.setProperty('--text-xs', '8px');
                            document.documentElement.style.setProperty('--text-sm', '9px');
                            document.documentElement.style.setProperty('--text-base', '10px');
                            document.documentElement.style.setProperty('--text-md', '11px');
                            document.documentElement.style.setProperty('--text-lg', '12px');
                            document.documentElement.style.setProperty('--text-xl', '13px');
                            break;
                        case 'mobile-landscape':
                            document.documentElement.style.setProperty('--text-xs', '8px');
                            document.documentElement.style.setProperty('--text-sm', '9px');
                            document.documentElement.style.setProperty('--text-base', '10px');
                            document.documentElement.style.setProperty('--text-md', '11px');
                            document.documentElement.style.setProperty('--text-lg', '12px');
                            document.documentElement.style.setProperty('--text-xl', '13px');
                            break;
                        case 'tablet-portrait':
                            document.documentElement.style.setProperty('--text-xs', '9px');
                            document.documentElement.style.setProperty('--text-sm', '10px');
                            document.documentElement.style.setProperty('--text-base', '11px');
                            document.documentElement.style.setProperty('--text-md', '12px');
                            document.documentElement.style.setProperty('--text-lg', '13px');
                            document.documentElement.style.setProperty('--text-xl', '14px');
                            break;
                        case 'tablet-landscape':
                            document.documentElement.style.setProperty('--text-xs', '9px');
                            document.documentElement.style.setProperty('--text-sm', '10px');
                            document.documentElement.style.setProperty('--text-base', '11px');
                            document.documentElement.style.setProperty('--text-md', '12px');
                            document.documentElement.style.setProperty('--text-lg', '13px');
                            document.documentElement.style.setProperty('--text-xl', '14px');
                            break;
                        default:
                            // Reset to default sizes for larger screens
                            document.documentElement.style.setProperty('--text-xs', '9px');
                            document.documentElement.style.setProperty('--text-sm', '10px');
                            document.documentElement.style.setProperty('--text-base', '11px');
                            document.documentElement.style.setProperty('--text-md', '12px');
                            document.documentElement.style.setProperty('--text-lg', '13px');
                            document.documentElement.style.setProperty('--text-xl', '14px');
                    }
                    
                    // Update container max-width for ultra-wide displays
                    if (newBreakpoint === 'ultra-wide') {
                        document.documentElement.style.setProperty('--container-max-width', '1800px');
                    } else {
                        document.documentElement.style.setProperty('--container-max-width', '100%');
                    }
                }
            }
            
            function handleResize() {
                const currentWidth = window.innerWidth;
                const currentHeight = window.innerHeight;
                
                // Update responsive variables immediately for smooth transitions
                updateResponsiveVariables(currentWidth, currentHeight);
                
                // Only re-render visualizations if there's a significant size change
                if (Math.abs(currentWidth - lastWidth) > 50 || Math.abs(currentHeight - lastHeight) > 50) {
                    lastWidth = currentWidth;
                    lastHeight = currentHeight;
                    
                    // Clear existing timer
                    clearTimeout(resizeTimer);
                    
                    // Debounce resize events with adaptive timing based on device type
                    const debounceTime = currentWidth < 768 ? 100 : 150;
                    
                    resizeTimer = setTimeout(() => {
                        // Re-render all visualizations with responsive adjustments
                        renderAllAdvancedVisualizations();
                        renderAllEmergingVisualizations();
                        
                        // Update visualization container heights based on breakpoint
                        const containers = document.querySelectorAll('.viz-container');
                        containers.forEach(container => {
                            const rect = container.getBoundingClientRect();
                            if (rect.width > 0) {
                                // Ensure minimum height based on current breakpoint
                                const minHeight = currentWidth < 480 ? 200 : 
                                                currentWidth < 640 ? 250 : 
                                                currentWidth < 768 ? 300 : 
                                                currentWidth < 1024 ? 350 : 
                                                currentWidth < 1280 ? 400 : 
                                                currentWidth < 1440 ? 450 : 
                                                currentWidth < 1920 ? 500 : 600;
                                
                                container.style.minHeight = `${minHeight}px`;
                            }
                        });
                        
                        // Optimize performance for mobile devices
                        if (currentWidth < 768) {
                            // Reduce animation complexity on mobile
                            document.body.classList.add('mobile-optimized');
                        } else {
                            document.body.classList.remove('mobile-optimized');
                        }
                        
                    }, debounceTime);
                }
            }
            
            window.addEventListener('resize', handleResize);
            
            // Initial responsive setup
            handleResize();
            
            // Multi-device optimization testing and device detection
            function detectDeviceType() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                const userAgent = navigator.userAgent.toLowerCase();
                
                let deviceType = 'desktop';
                let orientation = 'landscape';
                
                // Detect device type
                if (width <= 479) {
                    deviceType = 'mobile-portrait';
                    orientation = 'portrait';
                } else if (width <= 639) {
                    deviceType = 'mobile-landscape';
                    orientation = 'landscape';
                } else if (width <= 767) {
                    deviceType = 'tablet-portrait';
                    orientation = 'portrait';
                } else if (width <= 1023) {
                    deviceType = 'tablet-landscape';
                    orientation = 'landscape';
                } else if (width <= 1279) {
                    deviceType = 'laptop';
                } else if (width <= 1439) {
                    deviceType = 'desktop';
                } else if (width <= 1919) {
                    deviceType = 'large-desktop';
                } else {
                    deviceType = 'ultra-wide';
                }
                
                // Detect specific device characteristics
                const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                const isHighDPI = window.devicePixelRatio > 1;
                const isRetina = window.devicePixelRatio >= 2;
                const isMobileOS = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
                
                return {
                    type: deviceType,
                    orientation: orientation,
                    width: width,
                    height: height,
                    isTouchDevice: isTouchDevice,
                    isHighDPI: isHighDPI,
                    isRetina: isRetina,
                    isMobileOS: isMobileOS,
                    pixelRatio: window.devicePixelRatio,
                    userAgent: userAgent
                };
            }
            
            // Apply device-specific optimizations
            function applyDeviceOptimizations(deviceInfo) {
                const body = document.body;
                
                // Remove existing device classes
                body.classList.remove('mobile-device', 'tablet-device', 'desktop-device', 
                                    'touch-device', 'high-dpi', 'retina', 'mobile-os');
                
                // Add device-specific classes
                body.classList.add(`${deviceInfo.type}-device`);
                if (deviceInfo.isTouchDevice) body.classList.add('touch-device');
                if (deviceInfo.isHighDPI) body.classList.add('high-dpi');
                if (deviceInfo.isRetina) body.classList.add('retina');
                if (deviceInfo.isMobileOS) body.classList.add('mobile-os');
                
                // Apply performance optimizations based on device
                if (deviceInfo.type.includes('mobile')) {
                    // Reduce animation complexity on mobile
                    body.style.setProperty('--animation-duration', '0.3s');
                    body.style.setProperty('--transition-duration', '0.2s');
                    
                    // Optimize for touch interactions
                    document.querySelectorAll('.interactive-node').forEach(node => {
                        node.style.minWidth = '44px';
                        node.style.minHeight = '44px';
                    });
                } else {
                    // Reset to default animations for desktop
                    body.style.setProperty('--animation-duration', '0.5s');
                    body.style.setProperty('--transition-duration', '0.3s');
                }
                
                // High DPI optimizations
                if (deviceInfo.isHighDPI) {
                    // Ensure crisp rendering on high DPI displays
                    document.querySelectorAll('.viz-container svg').forEach(svg => {
                        svg.style.shapeRendering = 'geometricPrecision';
                    });
                }
                
                // Log device information for debugging (remove in production)
                console.log('Device Detection:', deviceInfo);
            }
            
            // Enhanced resize handler with device detection
            const originalHandleResize = handleResize;
            handleResize = function () {
                originalHandleResize();
                
                // Detect and apply device optimizations
                const deviceInfo = detectDeviceType();
                applyDeviceOptimizations(deviceInfo);
            };
            
            // Initial device detection and optimization
            const initialDeviceInfo = detectDeviceType();
            applyDeviceOptimizations(initialDeviceInfo);
            
            // Orientation change handler for mobile devices
            window.addEventListener('orientationchange', function () {
                setTimeout(() => {
                    const deviceInfo = detectDeviceType();
                    applyDeviceOptimizations(deviceInfo);
                    handleResize();
                }, 100);
            });
            
            // Performance monitoring for different devices
            function monitorPerformance() {
                if ('performance' in window) {
                    const perfData = {
                        deviceType: detectDeviceType().type,
                        loadTime: performance.timing.loadEventEnd - performance.timing.navigationStart,
                        domContentLoaded: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                        firstPaint: performance.getEntriesByType('paint').find(entry => entry.name === 'first-paint')?.startTime,
                        firstContentfulPaint: performance.getEntriesByType('paint').find(entry => entry.name === 'first-contentful-paint')?.startTime
                    };
                    
                    console.log('Performance Metrics:', perfData);
                    
                    // Apply performance-based optimizations
                    if (perfData.loadTime > 3000) {
                        console.warn('Slow load time detected, applying performance optimizations');
                        document.body.classList.add('performance-optimized');
                    }
                }
            }
            
            // Monitor performance after page load
            window.addEventListener('load', monitorPerformance);
            
            // Brand Consistency Validation System
            function validateBrandConsistency() {
                const brandValidation = {
                    colors: {
                        primary: getComputedStyle(document.documentElement).getPropertyValue('--accent-blue').trim(),
                        secondary: getComputedStyle(document.documentElement).getPropertyValue('--accent-cyan').trim(),
                        success: getComputedStyle(document.documentElement).getPropertyValue('--accent-green').trim(),
                        warning: getComputedStyle(document.documentElement).getPropertyValue('--accent-yellow').trim(),
                        error: getComputedStyle(document.documentElement).getPropertyValue('--accent-red').trim(),
                        info: getComputedStyle(document.documentElement).getPropertyValue('--accent-cyan').trim()
                    },
                    typography: {
                        primary: getComputedStyle(document.documentElement).getPropertyValue('--font-primary').trim(),
                        mono: getComputedStyle(document.documentElement).getPropertyValue('--font-mono').trim(),
                        baseSize: getComputedStyle(document.documentElement).getPropertyValue('--text-base').trim()
                    },
                    spacing: {
                        containerMaxWidth: getComputedStyle(document.documentElement).getPropertyValue('--container-max-width').trim()
                    }
                };
                
                // Validate color consistency
                const colorValidation = {
                    isValid: true,
                    issues: []
                };
                
                // Check for hardcoded colors in visualizations
                const hardcodedColors = document.querySelectorAll('[style*="#"]');
                hardcodedColors.forEach(element => {
                    const style = element.getAttribute('style');
                    if (style && style.includes('#') && !style.includes('var(')) {
                        colorValidation.issues.push(`Hardcoded color found in element: ${element.tagName}`);
                    }
                });
                
                if (colorValidation.issues.length > 0) {
                    colorValidation.isValid = false;
                    console.warn('Brand Consistency Issues:', colorValidation.issues);
                }
                
                // Validate typography consistency
                const typographyValidation = {
                    isValid: true,
                    issues: []
                };
                
                // Check for consistent font usage
                const allElements = document.querySelectorAll('*');
                allElements.forEach(element => {
                    const computedStyle = getComputedStyle(element);
                    const fontFamily = computedStyle.fontFamily;
                    if (fontFamily && !fontFamily.includes('Inter') && !fontFamily.includes('Roboto Mono') && !fontFamily.includes('system-ui')) {
                        typographyValidation.issues.push(`Inconsistent font family: ${fontFamily} in ${element.tagName}`);
                    }
                });
                
                if (typographyValidation.issues.length > 0) {
                    typographyValidation.isValid = false;
                    console.warn('Typography Consistency Issues:', typographyValidation.issues);
                }
                
                // Overall brand consistency score
                const consistencyScore = {
                    colors: colorValidation.isValid ? 100 : Math.max(0, 100 - (colorValidation.issues.length * 10)),
                    typography: typographyValidation.isValid ? 100 : Math.max(0, 100 - (typographyValidation.issues.length * 5)),
                    overall: 0
                };
                
                consistencyScore.overall = Math.round((consistencyScore.colors + consistencyScore.typography) / 2);
                
                console.log('Brand Consistency Validation:', {
                    score: consistencyScore,
                    brandValues: brandValidation,
                    recommendations: consistencyScore.overall < 90 ? [
                        'Replace hardcoded colors with CSS variables',
                        'Ensure consistent typography usage',
                        'Validate semantic color mappings',
                        'Check responsive design consistency'
                    ] : ['Brand consistency is excellent!']
                });
                
                return {
                    score: consistencyScore,
                    brandValues: brandValidation,
                    colorValidation: colorValidation,
                    typographyValidation: typographyValidation
                };
            }
            
            // Run brand consistency validation after page load
            window.addEventListener('load', () => {
                setTimeout(validateBrandConsistency, 1000);
            });
            
            // Brand consistency monitoring for development
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                // Add brand consistency indicator to page
                const brandIndicator = document.createElement('div');
                brandIndicator.id = 'brand-consistency-indicator';
                brandIndicator.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: var(--accent-blue);
                    color: white;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 12px;
                    font-family: var(--font-mono);
                    z-index: 10000;
                    opacity: 0.8;
                    cursor: pointer;
                `;
                brandIndicator.textContent = 'Brand Check';
                brandIndicator.title = 'Click to run brand consistency validation';
                brandIndicator.onclick = validateBrandConsistency;
                document.body.appendChild(brandIndicator);
            }

    </script>
</body>

</html>